---
title: 高性能mysql-Mysql的架构和历史
copyright: true
date: 2018-11-12 10:13:47
tags: mysql架构
categories: mysql

---

- MySQL最重要，最与众不同的特性是它的可插拔式存储引擎架构（将查询处理，系统任务，数据的存储，提取相分离）。

# MySQL逻辑结构

![mysql服务器逻辑架构图](/images/mysql/mysql服务器逻辑架构图.png)

第一层服务：大多数的客户端/服务端的工具或者服务都有类似的架构，比如连接处理、授权处理、安全等。

第二层服务：核心服务都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现。

第三层服务：包含了存储引擎，存储引擎负责mysql的数据存储和提取。

## 连接管理和安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在单独的线程中执行，该线程都只能轮流在某个cpu中运行，服务器会缓存线程，不需要为每一个新建的连接创建和销毁线程。

当客户端进行连接后，服务器需要对其进行认证。

## 优化与执行

mysql会解析查询，并创建内部数据结构（解析树），然后进行各种优化，包括重写查询、决定表的读取顺序、以及选择合适的索引等。用户可以使用关键字提示优化器（hint）影响他的决策进程，
也可以使用请求优化解释器优化过程的各个因素。mysql在解析查询之前，服务器会先检查查询缓存，如果有就不必执行查询解析。

# 并发控制

同一时刻修改数据都会产生并发控制的问题，本章主要考虑服务层与存储引擎层。

## 读写锁

共享锁与排它锁也叫读写锁。读锁是共享的，或者是互不阻塞的，多个客户在读取同一个资源互不干扰，写锁是排他的，一个写锁会阻塞其它的写锁和读锁。这样同一时间才会只有一个用户执行写入操作。

实际数据库中，当某个用户在修改某一部分数据时，mysql会通过锁定防止其它用户读取同一数据。

## 锁的粒度

提高共享资源的并发性就是让锁定对象更具有选择性，尽量指锁定需要修改的部分数据。锁定的数据越少，则系统的并发度越高。当然，加锁也需要消耗资源，比如获得锁，检查锁是否解除，释放锁等都会有开销。

锁策略是指在锁的开销和数据的安全性之间寻找平衡。一般数据库只是在表上加行锁，而mysql提供了更多选择。

将锁的粒度固定在某个级别可以为某种特定的场景提供更好的性能。

- 表锁（table lock）

它是最基本的锁策略，开销最小的锁策略，锁定整张表。一个用户在对表执行写操作需要获得的锁，他会阻塞其它用户对表的读写操作。

- 行级锁 (row lock)

行级锁可以最大程度支持并发处理，也是开销最大的锁。

# 事务

事务内的语句要么执行，要么全部不执行。事务是一个原子性的工作单元，

## 事务的特性（ACID）

- 原子性（atomicity）

一个事务是不可分割的最小单元，整个事务要么执行，要么全部失败回滚。

- 一致性（consistency）

事务总是从一个一致性的状态到另一个一致性的状态，如 A:500->200  B:100-> 400

- 隔离性（isolation）

一个事务所做的修改操作在最终提交以前，对其它事务是不可见的。

- 持久性（durability）

一旦事务提交，则所做的修改就会永久的保存到数据库中，即使数据库奔溃，修改的数据也不会丢失。数据库实现ACID需要做更多的额外工作，会增加系统开销。


### 隔离级别

sql标准中有4种隔离级别，较低级别的隔离通常可以执行更高的并发，系统的开销也更小。

- 未提交读（read uncommitted）：事务中的修改，即使没有提交，对其它事务也是可见的。事务可以读取未提交的数据，这也被称为脏读，这个级别也会导致很多问题，性能也不会好太多，不常用。

- 提交读(read committed): 大多数的数据库系统的隔离级别都是read committed（mysql不是），一个事务开始时，只能看见已经提交的修改。也叫不可重复读，执行两次的查询可能得到不一样的结果。

- 可重复读（repeatable read）:解决了脏读的问题，该级别的保证了同一个事务中多次读取同样的结果是一致的，可重复读还是无法解决幻读的问题。所谓幻读是指当某个事务在读取某个范围内的记录时，
另一个事务又在该范围内又插入了新的记录，当前事务再次读取该范围的记录时会产生换读。（可重复读是mysql默认事务隔离级别）。

- 可串行化(serializable)：最高的隔离级别，强制事务串行执行。通过强制事务串行执行避免了幻读。可串行化会在读取的每一行数据上都加锁，所以导致大量的超时和锁争用的问题，很少用。悲观锁。

### 死锁

死锁指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。多个事务同时锁定同一个资源时，也会产生死锁。

处理办法：完备的RDMS包含了死锁检测与死锁超时机制。innoDB存储引擎，越能检测到死锁的循环依赖，立即返回一个错误。innoDB目前采用持有最少行级排他锁的事务进行回滚。

### 事务日志

事务日志可以帮助提高事务的效率。可以将修改行为的记录持久化到硬盘的事务日志中，不需要每次都将修改的数据本身持久化到硬盘。事务日志采用追加的方式。

### mysql中的事务

mysql提供了两种事务型的存储引擎，innoDB 和NDB cluster。另外还有一些第三方的存储引擎。

- 自动提交

mysql默认的采用自动提交的模式，如果不显式的开始一个事务，每个查询都会被当做一个事务提交操作。autocommit = 0表示禁用，需要手动提交。对于使用mylsam的，不影响使用。

可以通过命令行设置事务的隔离级别：set session transaction isolation level read committed;

#### 在事务中混合使用存储引擎

mysql服务期层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

如果在事务中混了使用了innoDB以及mylsam表，正常提交的情况下不会有问题，但是事务回滚，则非事务型的表的变更就无法撤销，这样导致数据库处于不一致的状态。所以选择合适的存储引擎非常重要。

非事务型的表上的变更不会被报错，只会有提示“某些非事务型的表上的变更不会被回滚”。

#### 隐式和显式锁定

innoDB是两阶段锁定协议，在事务执行的过程中，随时都可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁是在同一时刻被释放。这是隐式锁定。innoDB会在需要的时候自动加锁。

建议： 除了使用中禁用了autocommit，可以使用lock tables之外，其它人事时候都不需要显示的执行lock tables和unlock tables语句。


## 多版本的并发控制 （MVCC）

mysql的大多数事务型存储引擎实现的都不是简单的行级锁，基于并发性能的考虑都实现了多版本的并发控制（MVCC）

MVCC是行级锁的一个变种，大多数情况下避免了加锁，大部分实现了非阻塞的读操作，写操作也只能锁定必要的行。

MVCC是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始时间的不同，每个事务对同一张表，同一个时刻看到的数据可能是不一样的。

### MVCC的实现

典型的有悲观锁和乐观锁的并发控制。

innoDB的MVCC的实现是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，时间值其实是系统版本号。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号作为事务的版本号，要用来和查询的每行记录表的版本号进行比较。

#### 在 REPEATABLE READ 隔离级别下的INNODB的MVCC操作
 
- SELECT

innoDB会根据以下两个条件检查每行记录：

1) innoDB只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于等于事务的系统版本号），这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2) 行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保读取到的行，在事务开始之前未被删除。

- INSERT

INNODB为新插入的每一行保存当前系统版本号作为行版本号。

- DELETE

INNODB为删除的每一行保存当前系统版本号作为删除标识。

- UPDATE

INNODB 为新插入的一行新纪录，保存当前版本号为行版本号，同时保存当前系统版本号为原来的行作为行删除标识。

1. 保存这两个额外的系统版本号，使得大多数操作都可以不用加锁。可以挺高性能，但是需要每行都增加额外的操作空间，需要额外的检查工作。
2. MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。


## MySql的存储引擎

mysql将为每个数据库（schema）保存为数据目录下的一个子目录，创建表时，mysql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义

````
show table status like 'tableName'

````

展示表的本身的信息

### InnoDB存储引擎

- innoDB的数据存储在表空间（tablespace）中，表空间是有innoDB管理的一个黑盒子，由一系列的数据文件组成。

- innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认是可重复读，并且通过间隙锁(next-key locking)策略防止幻读，间隙锁使得innoD不仅锁定查询涉及的行，还会针对索引中的间隙进行锁定，防止幻影行的出现。

- innoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过他的二级索引（非主键索引）必须包含主键列，所以主键列如果很大的话，其它所有索引都会很大。如果表上的索引较多的话，主键应尽量的小。

- innoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应hash索引。

### MylSAM存储引擎

在5.1版本之前，MylSAM是默认的存储引擎，MylSAM提供了大量的特性包括，全文索引，压缩，空间函数等。不支持事务以及行级锁，且在奔溃后无法安全恢复。对于小表，只读的数据可以忍受修复操作，则依然可以继续使用MylSAM。

#### 存储

MylSAM会将表存储在两个文件：数据文件和索引文件 分别以.MYD和.MYI为扩展名。MylSAM可以包含静态或者动态的行。它可以根据表的定义来确定使用何种格式行。 MAX_ROWS *AVG_ROW_LENGTH决定存储的数据量的大小。

#### 特性

- 加锁和并发：只支持对整张表加锁，而不是针对行。读取操作时对表加共享锁，写入时加排他锁，但是在表有读取查询的同时，可以往表中插入数据（并发插入）。

- 索引特性：即使是blob、text等长字段，也可以基于前500个字符创建索引。

- 延迟更新索引：更新的索引不会直接flush，更新的缓存会放到缓冲区中，只有在需要flush或者关闭表时候才会放到硬盘。

#### MylSAM 压缩表

如果表在创建并导入数据后，不会再进行修改操作，这样的表适合使用MylSAM存储引擎。MylSAM可以打包pack，压缩表不能直接进行修改，需要解压后修改。压缩表可以减少磁盘占用空间。

MylSAM引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。

### 选择合适的存储引擎

- MySql5.5将innoDB作为默认的存储引擎了；

- 除非需要用到某些innoDB不具备的特性，并且其它办法无法替代，否则都应该优先选择innoDB引擎；

- 除非万不得已，不建议混合使用多种存储引擎；








