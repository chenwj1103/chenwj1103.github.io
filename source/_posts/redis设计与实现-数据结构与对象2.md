---
title: redis设计与实现-数据结构与对象2
date: 2018-01-03 01:50:08
tags: redis数据结构与对象
categories: redis 

---

# 跳跃表

- 概念

跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。

跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找

Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。

## 跳跃表的实现

Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等

 ![跳跃表的结构](/images/redis/struct1/跳跃表的结构.png)
 
- 展示了一个跳跃表示例， 位于图片最左边的是 **zskiplist** 结构
 
`header` ：指向跳跃表的表头节点。
 
`tail` ：指向跳跃表的表尾节点。
 
`level` ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。

`length` ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

- 位于 zskiplist 结构右方的是四个 **zskiplistNode** 结构， 该结构包含以下属性：

`层（level）`：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。

`后退（backward）指针`：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。

`分值（score）`：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。


## 跳跃表节点

- zskiplistNode 结构定义：

````
typedef struct zskiplistNode {

    // 后退指针
    struct zskiplistNode *backward;

    // 分值
    double score;

    // 成员对象
    robj *obj;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];

} zskiplistNode;

````

### 层

跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个**介于 1 和 32 之间的值**作为 level 数组的大小， 这个大小就是层的“高度”。

图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。

 ![不同层高的节点](/images/redis/struct1/不同层高的节点.png)
 
 
### 前进指针

每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。


图 5-3 用虚线表示出了程序从表头向表尾方向， **遍历跳跃表**中所有节点的路径：

1.迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。

2.在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。

3.在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。

4.当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。

 ![遍历跳跃表](/images/redis/struct1/遍历跳跃表.png)
 
 
### 跨度

层的跨度（level[i].span 属性）用于记录两个节点之间的距离：

1.两个节点之间的跨度越大， 它们相距得就越远。

2.指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。

- 跨度的作用

跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。

例子:

图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。

 ![计算节点的排位](/images/redis/struct1/计算节点的排位.png)
 
### 后退指针 

节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。

图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。

 ![从表尾部向表头的遍历](/images/redis/struct1/从表尾部向表头的遍历.png)
 
### 分值和成员

节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。

节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。

在同一个跳跃表中， **各个节点保存的成员对象必须是唯一的**， **但是多个节点保存的分值却可以是相同的**： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。


## 跳跃表


虽然仅靠多个跳跃表节点就可以组成一个跳跃表如图 5-8 所示。
但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示

 ![多个跳跃节点组成的跳跃表](/images/redis/struct1/多个跳跃节点组成的跳跃表.png)
 
 ![带有skiplist结构的跳跃表](/images/redis/struct1/带有skiplist结构的跳跃表.png)
 
zskiplist结构定义

````
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;

````

header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。

通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。

level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意**表头节点的层高并不计算在内**。
 


# 整数集合

整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。

## 整数集合的实现

整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。

结构如下:

````
typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;

````

**contents** 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大`有序地排列`， 并且数组中`不包含任何重复项`。

**length** 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。

**encoding**

 如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。

 如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。

 如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。

### 例子

图 6-1 展示了一个整数集合示例：

encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。

length 属性的值为 5 ， 表示整数集合包含五个元素。

contents 数组按从小到大的顺序保存着集合中的五个元素。

因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) * 5 = 16 * 5 = 80 位。

 ![16bit的整数集合](/images/redis/struct1/16bit的整数集合.png)
 
- 注意
 
当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是 -2675256175807981027 。



## 升级

每当我们要将一个新元素添加到整数集合里面， 并且**新元素的类型比整数集合现有所有元素的类型都要长时**， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。


- 升级整数集合并添加新元素共分为三步进行：

1.根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。

2.将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。

3.将新元素添加到底层数组里面。

### 升级例子

假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示。

 ![int16整数集合](/images/redis/struct1/int16整数集合.png)


因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。

 ![contents数组中各个元素所在的位置](/images/redis/struct1/contents数组中各个元素所在的位置.png)
 
现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。

整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。

 ![空间重新分配后的数组](/images/redis/struct1/空间重新分配后的数组.png)
 
虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。

首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。

 ![类型转换元素3的操作](/images/redis/struct1/类型转换元素3的操作.png)

 接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内， 如图 6-7 所示。
 
 ![类型转换元素2的操作](/images/redis/struct1/类型转换元素2的操作.png)
 
 
 然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图 6-9 所示。
 ![类型转换新添加元素的操作](/images/redis/struct1/类型转换新添加元素的操作.png)

 最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。
 
 ![类型转换后的对象](/images/redis/struct1/类型转换后的对象.png)
  
## 降级 

整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

举个例子，即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的



# 压缩列表

压缩列表（ziplist）是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。

## 压缩列表的构成

压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。

 ![压缩列表的各个组成部分](/images/redis/struct1/压缩列表的各个组成部分.png)
 
 
 **lbytes**	uint32_t	4 字节	记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。
 
 **zltail**	uint32_t	4 字节	记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。
 
 **zllen**	uint16_t	2 字节	记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。
 
 **entryX**	列表节点	不定	压缩列表包含的各个节点，节点的长度由节点保存的内容决定。
 
 **zlend**	uint8_t	1 字节	特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。
 
三个节点的压缩列表

 ![三个节点的压缩列表](/images/redis/struct1/三个节点的压缩列表.png)

列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。

列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。

列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。



## 压缩列表节点的构成

- 每个压缩列表节点可以保存一个字节数组或者一个整数值， 

其中， 字节数组可以是以下三种长度的其中一种：

1. 长度小于等于 63 （2^{6}-1）字节的字节数组； 

2. 长度小于等于 16383 （2^{14}-1） 字节的字节数组；

3. 长度小于等于 4294967295 （2^{32}-1）字节的字节数组；

而整数值则可以是以下六种长度的其中一种：

1. 4 位长，介于 0 至 12 之间的无符号整数；

2. 1 字节长的有符号整数；

3. 3 字节长的有符号整数；

4. int16_t 类型整数；

5. int32_t 类型整数；

6. int64_t 类型整数。

每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如图 7-4 所示。

 ![压缩列表节点的各个组成部分](/images/redis/struct1/压缩列表节点的各个组成部分.png)
 

### previous_entry_length

节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。

previous_entry_length 属性的长度可以是 1 字节或者 5 字节：

1. 如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。

2. 如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。

图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。

 ![前一节点的长度为1字节](/images/redis/struct1/前一节点的长度为1字节.png)

图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。

 ![前一节点的长度为5字节](/images/redis/struct1/前一节点的长度为5字节.png)

因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。

举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p ， 如图 7-7 所示。
![计算前一节点的位置](/images/redis/struct1/计算前一节点的位置.png)


#### 一个从表尾节点向表头节点进行遍历的完整过程

首先，我们拥有指向压缩列表表尾节点 entry4 起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；

通过用 p1 减去 entry4 节点 previous_entry_length 属性的值， 我们得到一个指向 entry4 前一节点 entry3 起始地址的指针 p2 ；

通过用 p2 减去 entry3 节点 previous_entry_length 属性的值， 我们得到一个指向 entry3 前一节点 entry2 起始地址的指针 p3 ；

通过用 p3 减去 entry2 节点 previous_entry_length 属性的值， 我们得到一个指向 entry2 前一节点 entry1 起始地址的指针 p4 ， entry1 为压缩列表的表头节点；

最终， 我们从表尾节点向表头节点遍历了整个列表。

![表尾向表头遍历的1](/images/redis/struct1/表尾向表头遍历的1.png)

![表尾向表头遍历的2](/images/redis/struct1/表尾向表头遍历的2.png)

![表尾向表头遍历的3](/images/redis/struct1/表尾向表头遍历的3.png)

![表尾向表头遍历的4](/images/redis/struct1/表尾向表头遍历的4.png)


### encoding

节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：

一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是**字节数组**编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；

一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着**整数值**， 整数值的类型和长度由编码除去最高两位之后的其他位记录；


### content

节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定

- 图 7-9 展示了一个保存字节数组的节点示例：

![保存字节数组的节点](/images/redis/struct1/保存字节数组的节点.png)

编码的最高两位 00 表示节点保存的是一个字节数组；

编码的后六位 001011 记录了字节数组的长度 11 ；

content 属性保存着节点的值 "hello world" 。



- 图 7-10 展示了一个保存整数值的节点示例：

![保存整数值的节点](/images/redis/struct1/保存整数值的节点.png)

编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；

content 属性保存着节点的值 10086 。


### 连锁更新 

添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。






