---
title: 从根上了解mysql-innodb记录存储记录
copyright: true
date: 2020-08-07 11:50:12
tags: mysql
categories: mysql

---

## innodb的数据结构 

InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB

设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式

< !-- more -->

### Compact 格式

![compact结构](/images/mysql2/compact结构.png)

我们知道表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中

![记录头信息](/images/mysql2/记录头信息.png)

主要包括删除标记位、当前记录拥有的记录数、记录类型（普通记录、非叶子节点记录、最小记录、最大记录）、next_record(表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量)


InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键

一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出

## innndb是如何存储数据的

InnoDB其实是使用页为基本单位来管理存储空间的，默认的页大小为16KB。

对于InnoDB存储引擎来说，每个索引都对应着一棵B+树，该B+树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有双向链表来维护着这些页的顺序。

InnoDB的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，提出了一个表空间或者文件空间（，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多很多很多个页。


### 匹配左边的列

有个表中有联合索引 idx_name_birthday_phone_number

- 先按照name列的值进行排序。
- 如果name列的值相同，则按照birthday列的值进行排序。
- 如果birthday列的值也相同，则按照phone_number的值进行排序。

B+树的数据页和记录先是按照name列的值排序的，在name列的值相同的情况下才使用birthday列进行排序，也就是说name列的值不同的记录中birthday的值可能是无序的。而现在你跳过name列直接根据birthday的值去查找，臣妾做不到呀～ 那如果我就想在只使用birthday的值去通过B+树索引进行查找咋办呢？这好办，你再对birthday列建一个B+树索引就行了，创建索引的语法不用我唠叨了吧。

但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。

### 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找

### 使用联合索引进行排序注意事项

对于联合索引有个问题需要注意，ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY phone_number, birthday, name的顺序，那也是用不了B+树索引

### ASC、DESC混用

使用联合索引的各个排序列的排序顺序必须是一致的。

### 排序列包含非同一个索引的列

无法使用索引进行排序

### 用于分组

使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组

### 回表

会使用到两个B+树索引，一个二级索引，一个聚簇索引。 访问二级索引使用顺序I/O，访问聚簇索引使用随机I/O。需要回表的记录越多，使用二级索引的性能就越低。

### 排序字段的选择

- 只为用于搜索、排序或分组的列创建索引
- 考虑列的基数，为基数大的列建立索引；
- 索引列的类型尽量小，比如int  bigint
- 索引字符串值的前缀(B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大)。只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。
- 只有索引列在比较表达式中单独出现才可以使用索引
- 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。
- 定位并删除表中的重复和冗余索引
- 尽量使用覆盖索引进行查询，避免回表带来的性能损耗。

## 使用mysql的查询

### const 类型的查询

通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：const。这种const访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效

### ref

我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的id值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，如果记录比较少效率还是挺高的。但如果记录多，有可能走的是随机io，所以性能会比较低。



### ref_or_null

不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来 。

```
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;

```

### eq_ref

在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：eq_ref


### index

```
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';

由于key_part2并不是联合索引idx_key_part最左索引列，所以我们无法使用ref或者range访问方法来执行这个语句

```
我们可以直接通过遍历idx_key_part索引的叶子节点的记录来比较key_part2 = 'abc'这个条件是否成立，把匹配成功的二级索引记录的key_part1, key_part2, key_part3列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，

而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多


## 索引使用的特殊情况

```
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;

```

根据single_table表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询。

然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的WHERE条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少。

因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用idx_key1索引进行查询时只会用到与key1列有关的搜索条件，其余条件，比如key2 > 1000这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤

## 索引合并

某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集

````
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';

````

第一种方案： 按照某个搜索条件读取一个二级索引，根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件。

第二种方案： 按照不同的搜索条件分别读取不同的二级索引，将从多个二级索引得到的主键值取交集，然后进行回表操作。

虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是顺序I/O，而回表操作是随机I/O，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为回表而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低

- 出现索引合并的情况 

1. 二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。
2. 主键列可以是范围匹配 （索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很easy）

## 连接

`内连接`中的WHERE子句和ON子句是等价的。

对于`外连接`的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。

对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接来说左外连接和右外连接的驱动表和被驱动表不能轻易互换。

### 连接的原理

两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍。

### 全表扫描的代价。计算表的统计信息

- I/O成本： 将数据和索引从硬盘加载到内存中；读取一个页大小的默认成本1.0
- CPU成本： 读取以及检测记录是否满足对应的搜索条件、对结果集进行排序；访问一条记录的成本是0.2

````
show table status like 'single_table'

````

- Rows 代表记录的行数，如果是myisam表示的是实际的记录数，innodb表示的是预估值；
- Data_length 表示表占用的存储空间字节数。对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小。 Data_length = 聚簇索引的页面数量 x 每个页面的大小。



## innodb统计数据


SHOW TABLES FROM mysql LIKE 'innodb%';  // 从mysql库里查询innodb

SELECT * FROM mysql.innodb_index_stats  //从mysql库里查询索引统计信息

ANALYZE TABLE;  // ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的


## undo log日志

在事务对表中的记录做改动时才会为这个事务分配一个唯一的事务id






















