---
title: 高性能mysql-优化服务器配置以及高可用
copyright: true
date: 2018-12-16 22:53:36
tags: 优化服务器配置
categories: mysql

---

# mysql的配置文件

查找mysql的配置文件的详细参数

````
mysqld --help --verbose | less
````
查找myqsql配置文件放置的默认位置

````
mysql --help|grep 'my.cnf'
````


大部分的配置的默认值是最佳配置了，所以最好不要改动太多配置。

![基础配置文件](/images/mysql/mysql基础配置文件.png)

需要设置数据的位置，pid的配置。使用mysql用户来运行mysqld进程，需要确保这个账户存在，并且拥有操作数据目录的权限，端口设置为默认的3306。innoDB作为默认的存储引擎。

为innoDB配置合适的缓冲池（buffer pool）和日志文件（log file）是必须的。其它的innoDB配置都是可选的。缓冲池大小设置为服务器内存的约75%-80%。


## 检查服务器的状态

查看服务器的配置

````
show global status 
````

# 配置内存使用

mysql的内存消耗分为可以控制和补课控制的内存。可以按照如下步骤来配置内存：

1.确定可以使用内存的上限；
2.确定每个连接mysql需要使用多少内存，例如排序缓冲和临时表；
3.确定操作系统需要使用多少内存（包括其他应用）；
4.把剩下的内存全部给mysql的缓存，例如innoDB缓冲池；

## mysql可以使用多少内存

mysql都有允许使用的内存上限。mysql是单进程多线程的运行模式。整体可以使用的内存量也许会受操作系统的额限制。

## 每个连接需要的内存

myisam_sort_buffer_size设置为256M，连接最多为100个，最坏的情况是使用25G内存，但是这是几乎不可能发生的，使用临时表或复杂的存储过程的查询是导致高内存消耗最可能的原因。

## 为操作系统保留内存

给操作系统留2GB或者总内存的5%作为基准，以较大者为准。

## 为缓存分配内存

innoDB缓冲池、innoDB日志文件和MyLSAM数据的操作系统缓存、MyLSAM键缓存、查询缓存等；

## innoDB缓冲池

innoDB缓冲池并不仅仅缓存索引，还会缓存行的数据、自适应hash索引、插入缓冲、锁以及其它内部数据结构；innoDB还是用缓冲池来帮助延迟写入，这样就能合并多个写入操作，然后一起顺序的

缓冲池太大，重启服务器也需要花很长时间来预热缓冲池。

## MylSAM键缓存

MylSAM键缓存也成为键缓冲，默认只有一个键缓存，它只是缓存索引，不缓存数据。

索引存储占用的空间：
````
select sum(index_length) from informathon_schema.tables where engine ='mylsam'
````
key_buffer_size =1G，表示键缓冲的大小。默认的所有的MyLSAM的索引都存储在缓存中。

## 线程缓存

线程缓存保存那些当前没有与连接关联但是准备为后面新的连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，mysql从缓存中删除一个线程，并且把它分配给这个新的连接。当连接关闭时，如果线程缓存还有空间，则把线程返回缓存。

thread_cache_size变量指定了mysql可以保持在缓存中的线程数。

## 表缓存

表缓存和线程缓存的概念是相似的，但存储的对象代表的是表。每个在缓存中的对象包含相关表.frm文件的解析结果，加上一些其他数据。

表缓存对于innoDB表没有太大意义。

## innoDB数据字典

innoDB有自己的表缓存，可以成为表定义缓存或者数据字典。当innoDB打开一张表就增加一个对应的对象到数据字典，每张表可能占用4KB或者更多内存，关闭也不会清除，最新的版本添加来了一种缓存过期策略，清除长时间不适用的缓存。

另一个性能问题是打开表时会计算统计信息，这需要很多IO操作，所以代价很高。innoDB没有将统计信息持久化到硬盘，每次打开表都会重新计算（MyLSAM做了持久化）。

# 配置mysql的IO行为

有一些配置影响着mysql同步数据到磁盘以及如何做恢复操作，这些操作对性能的响应非常大，因为涉及昂贵的IO操作。

## innoDB的IO配置

![innoDB的缓存和文件](/images/mysql/innoDB的缓存和文件.png)

### innoDB的事务日志

innoDB使用日志来减少提交事务时的开销，因为日志中已经记录了事务，就无须在每个事务提交时 把缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置。而innoDB用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使变更没有写到数据文件。

innoDB最终还是把变更写到数据文件。innoDB使用一个后台线程智能地刷新这些变更到数据文件，这个线程可以批量组合写入。整体的日志文件受innodb_log_file_size和innoDB_log_fules_in_group两个参数影响。

innoDB变更任何数据时，会写一条记录变更记录到内存日志缓冲区，在缓冲区满的时候、事务提交的时候，或者一秒钟，innoDB都会刷写缓冲区的内容到磁盘日志文件。如果有大事务，增减日志缓冲区（innodb_log_buffer_size）来控制日志缓冲区的大小。

innodb_flush_log_at_trx_commit参数的设置

````
0 把日志缓冲写到日志文件，每秒钟刷新一次，但是事务提交时不做任何事；

1 日志缓冲写到日志文件，并且每次事务提交都刷新持久化存储。这个是默认的设置，该设置能保证不会丢失任何已经提交的事务，除非磁盘或者操作系统是伪刷新

2 每次提交时把日志缓冲写到日志文件，但是并不刷新。但是并不刷新，innodb每秒钟做一次刷新，0与2最重要的不同是，如果mysql进程挂了，2的事务不会丢失。 

````

- 把日志缓冲写到日志文件和把日志刷新到持久化存储之间的不同是很重要的，在大部分操作系统中，把缓冲写到日志只是简单地把数据从innodb的内存缓冲转移到了操作系统的缓存，也是在内存里，并没有真的把数据写入到持久化存储。

### innodb表空间

innodb把数据保存表空间内，本质上是一个由多个磁盘文件组成的虚拟文件系统。innodb用表空间实现很多功能，并不只是存储表和索引。它还保存了回滚日志、插入缓冲、双写缓冲。

通过使用innodb_data_file_path配置项可以定制表空间文件，这些文件都放在innodb_data_home_dir指定的目录下。

![表空间的配置](/images/mysql/表空间的配置.png)

回收空间的唯一方式：导出一份数据，关闭mysql，删除所有文件，修改配置，重启，让innodb创建新的数据文件，然后倒入数据。

# 配置mysql并发

使用innodb_thread_concurrency变量来控制并发量，它会限制一次性可以有多少线程进入内核，0表示不限制。一般设置 并发值 = cpu数量*磁盘数量*2

服务器不能在内存临时表中存储blob值，如果一个查询涉及blob值，又需要使用临时表，不管它多小，它都会在磁盘上创建临时表，这样效率很低。临时表可能是查询中最大的开销。可以使用substring（）函数将值转化为varchar


max_connections 默认是100，一般可以设置为300或者500也是可以的。

expire_logs_days 如果启用了二进制日志，应该打开这个选项，可以让服务器在指定的天数之后清理旧的二进制日志。建议设置为7-14天。

max_allowed_packet 控制多大的包可以被接收，默认值可能太大了，如果设置的太小复制可能出问题。通常设置为16MB或者更大。

read_only 这个选项禁止没有特权的用户在备库做变更，只接收从主库传输过来的变更。强烈建议把备库设置为只读模式。

skip_slave_start 阻止mysql视图自动启动复制，因为在不安全的崩溃或其他问题后，启动复制是不安全的，禁用自动启动。

# innodb的最重要的两个选项

innodb_buffer_pool_size 和innodb_log_file_size

# 高可用

高可用是相对的，100%的高可用是不可能的。高可用性越高，所付出的成本越高。

## 导致宕机的主要原因

1.运行环境，包括操作系统、硬盘以及网络。在运行环境的问题中，最普遍的是磁盘空间耗尽；
2.性能。最主要的是很糟糕的sql。糟糕的schema以及索引设计。
3.数据丢失及损坏；主备数据不一致导致。数据丢失主要是drop table的误操作导致；























