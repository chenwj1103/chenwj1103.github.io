---
title: 高性能mysql-创建高性能的索引
copyright: true
date: 2018-11-28 09:38:14
tags: mysql索引
categories: mysql

---

索引是存储引擎用于快速找到记录的一种数据结构。

数据量越大，索引对性能的影响越重要；不恰当的索引对性能的影响不明显，数据量增大时性能急剧下降；

# 索引基础

存储引擎首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。

创建一个包含两个列的索引和创建两个只包含一列的索引是大不相同的。

## 索引的类型

mysql中，索引是在存储引擎层，而不是在服务器层的。索引没有统一的标准。

### B-Tree索引

大部分mysql引擎都支持这种索引，它使用的是B-Tree数据结构来存储数据。但是NDB集群存储引擎实际采用T-Tree结构存储这种索引，InnoDB则使用B+Tree。

存储引擎以不同的方式使用B-Tree索引，性能也是各不相同的，例如MylSAM使用前缀压缩技术使得索引更小，但是innoDB则按照原数据格式进行存储，MylSAM索引通过数据的物理位置引用被索引的行，而innoDB则根据主键来引用被索引的行。


![B-Tree索引的抽象表示](/images/mysql/B-Tree索引的抽象表示.png)

[bTree索引](https://blog.csdn.net/xu_flash/article/details/62216969)

- 简单表述实现

B-Tree索引可以加快访问速度。因为不需要全表扫描，而是从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下查找，通过比较节点页的值和要查找的值可以找到合适指针进入下层子节点，这些指针实际上定义了子节点页中值的上线和下限。

最终存储引擎要么找到对应的额值，要么记录不存在。

#### 索引对如下类型查询有效

- 全值匹配

- 匹配最左前缀

- 匹配列前缀 

- 匹配范围值

- 精确匹配某一列并匹配范围外的另外一列

- 只访问索引的查询

#### B-tree索引的限制

- 如果不是按照索引的最左列开始查找，则无法使用索引；

- 不能跳过索引中的列，如果不指定索引名字，在mysq只能使用索引的第一列；

- 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查询，如：where last_name='AD' and first_name like 'J%' and dob = '1976-12-23',只能使用索引的前两列；

### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash码。hash索引将所有的hash码存储在索引中，hash表中存储指向每个数据行的指针。

在mysql中，只有memory引擎显示支持hash索引，也是memory引擎的默认引擎。

memory引擎过是支持非唯一hash索引的，这在数据库中与众不同。如果多列的hash值相同，索引会以链表的方式存放多个记录指针在同一个hash条目中。


#### hash索引的限制

- hash索引只包含hash值和行指针，而不存储字段，所以不能使用索引中的值来避免读取行；

- hash索引数据并不是按照索引值顺序存储，所以也就无法用于排序；

- hash索引也不支持部分索引列匹配查找，所以hash索引始终是使用索引列的全部内容来计算hash值的。

- hash索引只是支持等值比较查询，不支持范围查询；

- 访问hash索引的顺序非常快，除非有很多hash冲突。当出现hash冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的才可以。

- 如果hash冲突很多的话，一些索引维护的代价也会很高；

由于以上的限制，hash索引只是适合特定的场合，一旦适合hash索引，它带来的性能提升非常明显。

innodb引擎有一个特殊的功能叫做‘自适应hash索引’，当innoDB注意到某些索引使用的非常频繁时，它会在B-Tree索引的基础上再创建一个hash索引，这样就让B-Tree索引页具有hash索引的一些优点，比如快速的hash查找。

**自定义hash索引**：如果存储一个url，可以存储一个url和hash码，查询时执行如下命令：

````
select id from url_table where url = "http://www.mysql.com" and url_crc = CRC32("http://www.mysql.com");

````

这样性能会非常高，mysql优化性很高而体积很小的基于url_crc列的索引来查找。

缺陷是需要手动维护hash值，不过可以使用触发器实现；

### 空间数据索引

MylSAM 表支持空间索引，可以用作地理数据存储。mysql的gis支持不完善，所以大部分不适用这个特性。

### 全文索引

全文索引是一种特殊类型的索引，它查找的是文中的关键词，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样。

### 其它索引类别


# 索引的优点

索引可以让服务器快速定位到表的指定位置，而且由于索引的数据结构不同，索引也有一些其它的附加作用。

## 优点如下：

- 索引大大减小了服务器需要扫描的数据量；
- 索引可以帮助服务器避免排序和临时表；
- 索引可以将随机IO变为顺序IO；

# 高性能的索引策略

## 独立的列

独立的列是指不能是表达式的一部分。

- 下列的表达式不能使用actor_id列的索引。

````

select actor_id from actor_table where actor_id +1 = 5;

````

- 以下是另一个常见的错误,使用不到DATE_COL列的索引；

````
select * from TO_DAYS(CURRENT_DATE) - TO_DAYS(DATE_COL) <=10;

````

## 前缀索引和索引的选择性

- 索引比较长的字符串，模拟hash索引是一个策略。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。索引的选择性越高则查询效率越高。

- 索引的选择性是指不重复的索引值和数据表的记录总数的比值。

- 前缀索引的缺点：无法使用前缀索引做order by和 group by，也无法使用前缀索引做覆盖扫描。

- 对于blob和text的字符串类型的列，必须使用前缀索引，因为mysql不允许索引这些列的完整长度。


1.前缀选择时需要做测试,可以一直增加前缀长度，至到前缀的选择性接近完整列的选择性。

````
select count(*) as cnt, LEFT(city,3) as pref from sakil.city_demo group by pref order by cnt desc limit 10;

````

2.计算合适的前缀长度的另外一个办法是计算完整列的选择性，并使得前缀的选择性接近于完整列的选择性。通常接近于0.031就可以用了.最坏的情况，平均选择性如果是4或5的索引已经足够了。

````
select count(distinct LEFT(city,3))/count(*) from sakila.city_demo;

````

## 多列索引

比较错误的多列索引使用方法：为每个列创建独立的索引，或者按照错误的顺序创建多列索引；

MySQL会对索引做优化，将多个单列的索引做优化合并，但更多时候说明了表上的索引建的很糟糕。

- 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含多个相关列的多列索引，而不是多个独立的单列索引；

- 当服务器需要多个索引做联合操作时（通常有多个OR条件），通常消耗大量的CPU和内存资源在算法的缓存、排序和合并操作上，


## 选择合适的索引顺序

正确的顺序依赖于使用该索引的查询，并且同时需要考虑满足排序和分组的需要。

在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序。其次是第二列。

在不考虑排序和分组时，将选择性最高的列放到索引的最前列是很好的。这时候索引的作用只是优化where条件的查询。

### 查询例子：

````
select sum(staff_id =2),sum(customer_id = 584) from payment ;

sum(staff_id):7922

sum(customer_id):30

````

根据前面的经验，customer_id应该放到前面，因为对应条件值的customer_id数量更小。

或者判断选择性更高的 customer_id，所以选择customer_id在最前面。

````
select count(distinct staff_id)/count(*) as staff_id_selectvity,count(distinct customer_id)/count(*) as customer_id_selectvity, count(*) from payment

````

## 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但innoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

当表有聚簇索引时，它的数据实际上存放在索引的叶子页中。术语‘聚簇’表示数据行和相邻的键值紧凑的存储在一起。因为无法同事把数据航存放在两个不同的地方，所以一个表只能有一个聚簇索引。

因为存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。innoDB是支持聚簇索引的。

### 聚簇索引的优点

- 可以把相关数据保存在一起，例如实现电子邮箱时，可以根据用户id来聚集数据，这样可以从磁盘读取很少的数据也就能获取某个用户的全部邮件，如果没有使用聚簇索引，每封邮件都可能导致一次磁盘IO。

- 数据访问更快，聚簇索引将索引和数据保存在一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快；

- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值；

### 聚簇索引的缺点

- 极大提高了IO密集型的应用的性能，**但是如果数据全部放在内存中**，则访问顺序就没那么重要了，聚簇索引也就没有优势了；

- 插入速度严重依赖于插入顺序，按照主键的顺序插入到innoDB表中速度最快，如果不是按照主键顺序加载数据，则加载完后最好使用optimize table命令重新组织一下表；

- 更新聚簇索引的代价很高，因为会强制innoDB将每个更新的行移动到新的位置；

- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于分裂导致数据存储不连续的时候；

- 非聚簇索引可能比想象的要更大，因为在非聚簇索引的叶子节点包含了引用行的主键列；

- 二级索引访问需要两次索引查找，而不是一次，因为二级索引的叶子节点存储的的不是行指针，而是主键值；


![聚簇索引和非聚簇索引的对比图](/images/mysql/聚簇索引和非聚簇索引的对比图.png)

## 在innoDB表中按主键顺序插入行或UUID最为主键

使用自增主键（顺序的），避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于IO密集型的应用。从性能角度考虑，使用UUID作为聚簇索引则会很糟糕。它使得聚簇索引的插入变得随机。

使用自增主键，因为主键的值是顺序的，所以innoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录会被写入新的页中。

使用UUID作为聚簇索引插入新的行时，因为新行的主键值不一定比之前插入的大，所以innoDB无法简单地总是把新行插入到碎银的后面，而是需要为新的俄航寻找合适的位置，通常是使用已有数据的中间位置，并分配空间，这回增减很多额外的工作，导致数据部分不够优化；

- 使用UUID作为聚簇索引的缺点

1.写入的目标页可能已经刷到磁盘上并从缓存中溢出，或者是没有被加载到缓存中，innoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这**导致大量的随机IO**；
2.因为写入是乱序的，**innoDB不得不频繁的做页分裂操作**，以便为新的行分配空间。页分裂导致移动大量的数据，一次插入最少需要更改三个页而不是一个页；
3.由于频繁的页分裂，页会变得洗漱并被不规则的填充，最终**数据会有碎片**；

## 顺序的主键什么时候回造成更坏的结果

对于高并发的的工作负载，在innoDB中按照主键插入会造成明显的争用。

## 覆盖索引

如果索引的叶子节点中已经包含要查询的数据，就不需要再回表查询。如果一个索引包含所有需要查询的字段的值，我们就称之为覆盖索引。

### 覆盖索引的好处（不需要回表查询）

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那么mysql会极大的减少数据访问量。

- 因为索引是按照列值顺序存储的（至少单个页内是如此），所以IO密集型的查询范围查询会比随机从磁盘读取每一行数据的IO少得多。

- 一些存储引擎入MySAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，这回导致严重的性能问题。

- 由于innoDB的聚簇索引，覆盖索引对innoDB表特别有用，innoDB的二级索引在叶子节点保存了行的主键索引，如果二级主键能够覆盖查询，可以避免对主键索引的二次查询。

### 使用场景

不是所有的类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而hash索引、空间索引、全文索引都不存储索引列的值。

````
select store_id,film_id from sakila.inventory;
````
如表inventory中有一个多列索引（store_id,film_id）。mysql 如果只是需要访问这两列，就可以使用这个索引做覆盖索引；

![覆盖索引的使用](/images/mysql/覆盖索引的使用.png)

在extra列显示 using index,而不是type列的index。

## 使用索引扫描来做排序

mysql有两种方式可以生成有序的结果，通过排序操作；或者通过索引顺序扫描。如果mysql使用explain处理啊的type值为index，则说明mysql使用了索引扫描来做排序。

扫描本身很快，只需要从一条索引到下一条记录，但是如果索引不能覆盖查询的所有列，那就不得不每扫描一条索引记录就都回表查询一次。

- 如果查询需要关联多张表，则只有order by 子句引用的字段全部为第一张表时，才可以使用索引做排序。

- 即使order by子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。

![orderBy的表](/images/mysql/orderBy的表.png)

![非最左索引-的orderBy子句](/images/mysql/非最左索引-的orderBy子句.png)

![不能使用索引做排序的例子](/images/mysql/不能使用索引做排序的例子.png)

## 冗余和重复索引

mysql是允许在相同的列上创建多个索引，无论是有意义的还是无意义的，mysql需要单独维护重复的索引。

重复索引是指在相同的列上按照相同的顺序创建相同类型的索引，应该避免创建重复索引。

冗余索引和重复索引有一些不同，如果创建了索引（A，B）,在创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。如果创建索引（B,A）就不是冗余索引，索引（B）也不是。

### 冗余索引的情况

有人可能会增加一个新的索引（A,B）,而不是扩展已有的索引（A）。还有一种情况是扩展为（A,ID）,其中ID是主键，对于innoDB来说，主键列已经包含在二级索引中了，这也是冗余索引。

![需要冗余索引的情况](/images/mysql/需要冗余索引的情况.png)

有两个索引的缺点就是维护成本更高。插入数据需要的时间大大增加。

## 索引和锁

索引可以让查询锁定更少的行，如果你的查询从来不访问那些不需要的行，那么就可以锁定更少的行。锁定行仍然会带来额外的开销，而且锁定超过需要的行会增加锁争用并减少并发性；

innoDB只有在访问行的时候才会对其加锁，而索引能够见啥innoDB访问的行数，从而减少锁的数量，但这只有当innoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在innoDB检索到数据返回给服务器层时，mysql服务器才会应用where子句，这时候已经无法避免应用where子句。


# 索引案例学习

![索引案例学习需求](/images/mysql/索引案例学习需求.png)

## 支持多种过滤条件

哪些列在where子句中出现的最频繁，在有更多的不同值的列上创建索引的选择性会更好。

country列的选择性通常不高，但是很多查询用到，sex的选择性更低，但是很多查询中也会用到。建议将（sex，country）列作为前缀。

- 正常情况下是把选择性更高的字段放前面。因为几乎所有的查询都会用到sex字段。也可以使用in（‘male’，‘female’）让mysql来进行选择。所以可以使用（sex，country）作为索引。

**索引设计的基本原则**

当设计索引时，不要只为现有的查询考虑需要哪些索引，还要考虑对查询进行优化。如果发现某些查询需要创建新的索引时，但是这个索引优惠降低另外一些的查询效率，那么应该考虑优化原来的查询。

- 考虑where条件组合，并了解哪些索引在没有合适的索引的情况下会很慢。

- age一般是范围查询的，所以age可以放到最后。可以使用IN来代替范围查询。尽可能的将范围查询的列放到索引的后面，以便优化器可以使用更多的列。

## 避免多个范围条件

范围条件 actor_id>45, explain 的type是range类型；in（2，3，4）是列表条件，explain 的type也是range类型。

第一个是范围条件，第二个是多个等值条件查询。**对于范围条件，mysql无法再使用范围列后面的其他索引列了，但是对于多个等值条件查询则没有这个限制。**

![多个范围条件的例子](/images/mysql/多个范围条件的例子.png)

上述查询有2个范围条件，last_online列和age列。可以使用一个它们中的一个索引，但是无法同事使用。

## 优化排序

优化大量翻页的排序的一种方法是限制用户能够翻页的数量；另一种是使用延迟关联，可以使用覆盖索引去查询返回需要的主键，再根据主键关联原表获得需要的行。

# 维护索引和表

即使使用争取的类型创建了表并加上合适的索引，工作也没有结束，还需要维护表和索引来确保他们都正常工作。维护表主要有三个目的：找到并修复损坏的表，维护准确的索引统信息，减少碎片。

## 找到并修复损坏的表

索引损坏会发生一些奇怪的问题，可以使用check table命令来检查是否发生了表损坏，可以使用repair table命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令。可以使用数据备份然后重新导入，如果不是索引损坏了那么就没有用了。

如果数据损坏，最重要的是找出是什么导致了损坏，而不是简单的修复。

## 更新索引统计信息

mysql的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。

1.第一个是records_in_range(),通过向存储引擎传入两个边界值来获取这个范围大概有多少记录。这对于InnoDB来说会返回估算值，而MylSAM会返回精确值；
2.第二个是info（），该接口返回各种类型的数据，包括索引的基数（每个键值有多少记录）。

如果统计信息有误或者不准确，优化器可能会做出错误的决定，可以通过使用analyze table来重新生成统计信息来解决问题。

不同的存储引擎对统计信息的存储时不同的，memory引擎根本不存储索引统计信息；mylSAM将索引统计信息存储在磁盘，analyze table需要全索引扫面，且整个过程锁表；innoDB不在磁盘存储索引统计信息，而是通过随机访问进行评估并存储在内存中。

````
mysql> SHOW INDEX FROM t_sys;
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| t_sys |          0 | PRIMARY        |            1 | id          | A         |          33 | NULL     | NULL   |      | BTREE      |         |               |
| t_sys |          0 | unique_app_id  |            1 | app_id      | A         |          31 | NULL     | NULL   | YES  | BTREE      |         |               |
| t_sys |          1 | index_sys_name |            1 | sys_name    | A         |          32 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
3 rows in set (0.00 sec)

````
Cardinality是索引列的基数，显示了存储引擎估算索引列有多少个不同的值。

## 减少索引和数据的碎片

B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。

表数据的碎片化分为三种：行碎片、行间碎片、剩余空间碎片；

- 行碎片：这种碎片指的是数据行被存储在多个地方的多个片段中，及时查询只从索引中范文一行记录，行碎片也会导致性能下降；

- 行间碎片：行间碎片是指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。

- 剩余空间碎片：剩余空间碎片是指数据页中有大量的空余空间，这会导致服务器读取大量不需要的数据，从而造成浪费。

对于MylSAM表，这三类碎片都会发生。但是innoDB不会出现短小的行碎片，innoDB会移动短小的行并重新写到一个片段中。

**处理办法**

可以通过执行 optimize table或者导出在导入的方式来整理数据，这对大多数存储引擎是有效的。

# 总结

1.大部分情况下都会使用B-tree索引，其它的索引只适合特殊的目的。

2.在选择和编写利用这些索引的查询时，有如下三个原则需要记住：

![创建索引的三个原则](/images/mysql/创建索引的三个原则.png)

编写查询语句时尽可能的选择合适的索引以避免单行查找、尽可能的使用数据原生顺序从而避免额外的排序操作、尽可能使用索引覆盖查询；

3.没有完美的索引时，需要创建大量的索引，（两个列，一个是正序，一个是倒叙，不能达到三星索引）。必须有所取舍选择合适的索引。








