---
title: java数据结构和算法11-红黑树
copyright: true
date: 2019-04-09 23:36:35
tags: 红黑树
categories: 数据结构和算法

---

二叉搜索树对于某个节点而言，其左子树的节点的关键值都小于该节点的关键值，右子树的所有节点的关键值都大于该节点的关键值。二叉搜索树作为一种数据结构，

增删改查的时间复杂度都是log以2为底n的对数，但是这个复杂度都是爱平衡的二叉搜索树上提现的，也就是如果插入的数据是随机的，则效率很高，但是如果是有序的从下到大的则，树为全部在右边。


![偏向的树](/images/datastructure/偏向的树.png)

从小到大的都在右边，则这链表没有区别了。时间复杂度是o(n)。所示时间复杂度是在log以2为底n的对数和o(n)

# 红黑树

那么为了能够以较快的时间O(logN)来搜索一棵树，我们需要保证树总是平衡的（或者大部分是平衡的），也就是说每个节点的左子树节点个数和右子树节点个数尽量相等。红-黑树的就是这样的一棵平衡树

对一个要插入的数据项（删除也是），插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。

## 红黑树的特征

有两个特征

1. 节点都有颜色；
2. 在插入和删除的过程中，要遵循保持这些颜色的不同排列规则；

第一个很好理解，在红-黑树中，每个节点的颜色或者是黑色或者是红色的。当然也可以是任意别的两种颜色，这里的颜色用于标记，我们可以在节点类Node中增加一个boolean型变量isRed，以此来表示颜色的信息。

第二点，在插入或者删除一个节点时，必须要遵守的规则称为红-黑规则：
1.每个节点不是红色就是黑色的；
2.根节点总是黑色的；
3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)；
4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

新插入的节点颜色总是红色的，

这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。

另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，那么红-黑树是如何修正的呢？

## 红黑树的自我修正

红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋。

### 改变节点颜色

新插入的节点为15，一般新插入颜色都为红色，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则4。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。

![改变节点颜色](/images/datastructure/改变节点颜色.png)

### 右旋

首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。

![右旋](/images/datastructure/右旋.png)

### 左旋

左旋的顶端节点必须要有右子节点。

![左旋](/images/datastructure/左旋.png)

我们改变颜色也是为了帮助我们判断何时执行什么旋转，而旋转是为了保证树的平衡。光改变节点颜色是不能起到任何作用的，旋转才是关键的操作，在新增节点或者删除节点之后，可能会破坏二叉树的平衡，那么何时执行旋转以及执行什么旋转，这是我们需要重点关注的。

````
package com.chen.algorithm.tree.rbtree;

/**
 * 红黑树节点类
 * <p>
 * 节点类和二叉树的节点类差不多，只不过在其基础上增加了一个 boolean 类型的变量来表示节点的颜色
 *
 * @author :  chen weijie
 * @Date: 2019-04-10 12:18 AM
 */
public class RBNode<T extends Comparable<T>> {

    /**
     * 颜色
     */
    boolean color;

    /**
     * 关键值
     */
    T key;

    /**
     * 左子节点
     */
    RBNode<T> left;

    /**
     * 右子节点
     */
    RBNode<T> right;

    /**
     * 父节点
     */
    RBNode<T> parent;


    RBNode<T> root;


    public RBNode(boolean color, T key, RBNode<T> left, RBNode<T> right, RBNode<T> parent) {
        this.color = color;
        this.key = key;
        this.left = left;
        this.right = right;
        this.parent = parent;
    }


    /**
     * 获取节点的关键值
     *
     * @return
     */
    public T getKey() {
        return key;
    }

    /**
     * 打印节点的关键值和颜色信息
     */
    @Override
    public String toString() {
        return "" + key + (this.color ? "R" : "B");
    }


    /*************对红黑树节点x进行左旋操作 ******************/

    /***
     *
     * 左旋示意图：对节点x进行左旋
     *     p                       p
     *    /                       /
     *   x                       y
     *  / \                     / \
     * lx  y      ----->       x  ry
     *    / \                 / \
     *   ly ry               lx ly
     *
     * 左旋做了三件事：
     * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)
     * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
     * 3. 将y的左子节点设为x，将x的父节点设为y
     */
    private void leftRotate(RBNode<T> x) {
        //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)
        RBNode<T> y = x.right;

        x.right = y.left;
        if (y.left != null) {
            y.left.parent = x;
        }

        //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
        y.parent = x.parent;
        if (x.parent == null) {
            this.root = y;
        } else {
            if (x == x.parent.left) {
                x.parent.left = y;
            } else {
                x.parent.right = y;
            }
        }

        // 3. 将y的左子节点设为x，将x的父节点设为y
        y.left = x;
        x.parent = y;
    }


    /*************对红黑树节点y进行右旋操作 ******************/
    /**
     * 左旋示意图：对节点y进行右旋
     * p                   p
     * /                   /
     * y                   x
     * / \                 / \
     * x  ry   ----->      lx  y
     * / \                     / \
     * lx  rx                   rx ry
     * 右旋做了三件事：
     * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)
     * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)
     * 3. 将x的右子节点设为y，将y的父节点设为x
     */
    private void rightRotate(RBNode<T> y) {

        //1. 将y的左子节点赋给x的右子节点，并将y赋给x右子节点的父节点(x右子节点非空时)
        RBNode<T> x = y.left;
        y.left = x.right;
        if (x.right != null) {
            x.right.parent = y;
        }

        //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
        x.parent = y.parent;

        if (y.parent == null) {
            //如果y的父节点为空(即y为根节点)，则旋转后将x设为根节点
            this.root = x;
        } else {
            if (y == y.parent.left) {
                //则将x也设置为左子节点
                y.parent.left = x;
            } else {
                //否则将x设置为右子节点
                y.parent.right = x;
            }
        }

        //3. 将x的左子节点设为y，将y的父节点设为y
        x.right = y;
        y.parent = x;

    }
}

````

### 插入操作




这与二叉搜索树中实现的思路一样，这里不再赘述，主要看看方法里面最后一步insertFixUp(node)操作。因为插入后可能会导致树的不平衡，insertFixUp(node) 方法里主要是分情况讨论，分析何时变色，何时左旋，何时右旋。我们先从理论上分析具体的情况，然后再看insertFixUp(node) 的具体实现。

　　如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况，我们就要开始变色和旋转了：

　　①、插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。

　　②、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。

　　③、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子节点。

　　下面我们挨个分析这三种情况都需要如何操作，然后给出实现代码。

　　在下面的讨论中，使用N,P,G,U表示关联的节点。N(now)表示当前节点，P(parent)表示N的父节点，U(uncle)表示N的叔叔节点，G(grandfather)表示N的祖父节点，也就是P和U的父节点。


由于插入过程和删除过程比较复杂就不做分析。。。


### 红黑树的效率

红黑树的查找、插入和删除时间复杂度都为O(log2N)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是O(log2N),(时间复杂度的计算要省略常数)，但实际上比普通的二叉树是要慢的。
 
大多数应用中，查找的次数比插入和删除的次数多，所以应用红黑树取代普通的二叉搜索树总体上不会有太多的时间开销。而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。






[参考](https://www.cnblogs.com/ysocean/p/8004211.html)