---
title: redis集群-Sentinel
copyright: true
date: 2018-02-08 00:58:20
tags: redis sentinel
categories: redis

---

# 简介

Redis Sentinel是用来实现Redis(2.8+)高可用的一套解决方案。Redis Sentinel由两个部分组成：由一个或者多个Sentinel实例组成Sentinel系统；**由一个主Redis服务器**(Master Redis)和多个从Redis服务器(Slave Redis)组成主从备份的Redis系统。

Sentinel系统本身是一个分布式的系统，它的作用是监视Redis服务器，在Master Redis下线时，自动将某个Slave Redis提升为新的主服务器。Redis系统由Master Redis处理客户端的命令请求，Slave Redis作为主服务器的备份而存在。

# Redis Sentinel主要作用

- 监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- 提醒(Notification)：当被监控的某个Redis服务器出现问题时， Sentinel可以通过API向管理员或者其他应用程序发送通知。
- 自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。

# 构建Redis Sentinel集群

主多从的Redis系统中，可以使用多个Sentinel进行监控任务以保证系统足够稳健。此时，不仅Sentinel会同时监控主数据库和从数据库，Sentinel之间也会相互监控.

## redis服务器配置 redis.conf文件

主节点(由于主从节点有可能切换所以涉及密码的两个参数每个节点都需要配置)

````
port 7000
requirepass test
masterauth test

````
从节点1 

````
port 7001
requirepass test
masterauth test
slaveof 127.0.0.1 7000

````
从节点2

````
port 7002
requirepass test
masterauth test
slaveof 127.0.0.1 7000

````
## 配置Sentinel.conf (三个文件只有port和日志目录不一样)

````
bind 127.0.0.1
port 27000
sentinel monitor mymaster 127.0.0.1 7000 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 2
sentinel auth-pass mymaster test
logfile "/usr/local/redisSentinel/7000/sentinelLog/log.log"

````
## 配置文件解释

````
port 27000
Sentinel实例之间的通讯端口，该端口号默认为26379。

bind 127.0.0.1
Sentinel默认会绑定到127.0.0.1，这里要在多台机器间通信，我们将它绑定到主机IP上。

sentinel monitor mymaster 127.0.0.1 7000 2
Sentinel去监视一个名为mymaster的主服务器，这个主服务器的IP地址为127.0.0.1  ，端口号为7000。将这个主服务器判断为失效至少需要2个Sentinel同意，一般设置为N/2+1(N为Sentinel总数)。只要同意Sentinel的数量不达标，自动故障迁移就不会执行。

不过要注意，无论你设置要多少个Sentinel同意才能判断一个服务器失效， 一个Sentinel都需要获得系统中多数Sentinel的支持，才能发起一次自动故障迁移，并预留一个给定的配置纪元。(configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号)。

sentinel down-after-milliseconds mymaster 5000
down-after-milliseconds选项指定了Sentinel认为服务器已经断线所需的毫秒数。如果服务器在给定的毫秒数之内，没有返回Sentinel发送的PING命令的回复，或者返回一个错误，那么Sentinel将这个服务器标记为主观下线(subjectively down，简称SDOWN)。

不过只有一个Sentinel将服务器标记为主观下线并不一定会引起服务器的自动故障迁移，只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线(objectively down，简称ODOWN)， 这时自动故障迁移才会执行。将服务器标记为客观下线所需的Sentinel数量由对主服务器的配置(sentinel monitor参数)决定。

sentinel failover-timeout mymaster 180000
如果在多少毫秒内没有把宕掉的那台Master恢复，那Sentinel认为这是一次真正的宕机。在下一次选取时排除该宕掉的Master作为可用的节点，然后等待一定的设定值的毫秒数后再来探测该节点是否恢复，如果恢复就把它作为一台Slave加入Sentinel监测节点群，并在下一次切换时为他分配一个”选取号”。

sentinel parallel-syncs mymaster 2
parallel-syncs选项指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步。这个数字越小，完成故障转移所需的时间就越长。

如果从服务器被设置为允许使用过期数据集(slave-serve-stale-data选项)， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求。因为尽管复制过程的绝大部分步骤都不会阻塞从服务器，但从服务器在载入主服务器发来的RDB文件时，仍然会造成从服务器在一段时间内不能处理命令请求。

如果全部从服务器一起对新的主服务器进行同步，那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。你可以通过将这个值设为1来保证每次只有一个从服务器处于不能处理命令请求的状态。

sentinel auth-pass mymaster test
当Master设置了密码时，Sentinel连接Master和Slave时需要通过设置参数auth-pass配置相应密码。

logfile /usr/local/redisSentinel/7000/sentinelLog/log.log
日志文件所在位置，

````
## 启动sentinel集群

````
sudo ./src/redis-sentinel sentinel.conf &

````

## 通过redis客户端工具查看当前Sentinel的信息

````
zhuningning@ubuntu:/usr/local/redisSentinel/7000$ ./src/redis-cli -p 27000 -h 127.0.0.1 INFO Sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3

````

## Sentinel启动后会输出类似的日志

````
21	6839:X 09 Feb 01:14:11.494 # Sentinel ID is b9095b246a20441e432f693f9b9042d7bb605372
22	6839:X 09 Feb 01:14:11.494 # +monitor master mymaster 127.0.0.1 7000 quorum 2
23	6839:X 09 Feb 01:14:11.495 * +slave slave 127.0.0.1:7001 127.0.0.1 7001 @ mymaster 127.0.0.1 7000
24	6839:X 09 Feb 01:14:11.527 * +slave slave 127.0.0.1:7002 127.0.0.1 7002 @ mymaster 127.0.0.1 7000
25	6839:X 09 Feb 01:18:56.295 * +sentinel sentinel 5a18eecd2dcb3ce949a30d15e12dc4e14d3dc73b 127.0.0.1 27001 @ mymaster 127.0.0.1 7000
26	6839:X 09 Feb 01:20:54.521 * +sentinel sentinel 7df87dde32ceeced13dfd020f99c914414b9f474 127.0.0.1 27002 @ mymaster 127.0.0.1 7000

````

+slave和+sentinel分别代表成功发现了从数据库和其他Sentinel。

## sentinel.conf文件生成信息

重新打开sentinel.conf文件，发现Sentinel自动生成了一些信息，记录了监控过程中的状态变化。

````
199	# Generated by CONFIG REWRITE
200	sentinel config-epoch mymaster 0
201	sentinel leader-epoch mymaster 0
202	sentinel known-slave mymaster 127.0.0.1 7001
203	sentinel known-slave mymaster 127.0.0.1 7002
204	sentinel known-sentinel mymaster 127.0.0.1 27002 7df87dde32ceeced13dfd020f99c914414b9f474
205	sentinel known-sentinel mymaster 127.0.0.1 27001 5a18eecd2dcb3ce949a30d15e12dc4e14d3dc73b
206	sentinel current-epoch 0

````

## 查看Sentinel监控的主从服务器

````
zhuningning@ubuntu:/usr/local/redisSentinel/7000$ ./src/redis-cli -h 127.0.0.1 -p 27000 
127.0.0.1:27000> sentinel master mymaster
 1) "name"
 2) "mymaster"
 3) "ip"
 4) "127.0.0.1"
 5) "port"
 6) "7000"
 7) "runid"
 8) "1d998c438067f7fd3ad51742380bf16257fd0877"
 9) "flags"
10) "master"
11) "link-pending-commands"
12) "0"
13) "link-refcount"
14) "1"
15) "last-ping-sent"
16) "0"
17) "last-ok-ping-reply"
18) "168"
19) "last-ping-reply"
20) "168"
21) "down-after-milliseconds"
22) "5000"
23) "info-refresh"
24) "6675"
25) "role-reported"
26) "master"
27) "role-reported-time"
28) "1804688"
29) "config-epoch"
30) "0"
31) "num-slaves"
32) "2"
33) "num-other-sentinels"
34) "2"
35) "quorum"
36) "2"
37) "failover-timeout"
38) "180000"
39) "parallel-syncs"
40) "2"

````
# Sentinel验证

我们让7000节点上的mymaster主动休眠30秒来观察failover过程：
````
$ redis-cli -p 7000 -h 127.0.0.1 -a test DEBUG sleep 30
````
日志如下:

````
zhuningning@ubuntu:/usr/local/redisSentinel/7000$ ./src/redis-cli -p 7000 -h 127.0.0.1 -a test DEBUG sleep 30
5303:M 09 Feb 01:47:41.392 # Connection with master lost.
5303:M 09 Feb 01:47:41.393 * Caching the disconnected master state.
5303:M 09 Feb 01:47:41.393 * Discarding previously cached master state.
5303:M 09 Feb 01:47:41.393 * MASTER MODE enabled (user request from 'id=5 addr=127.0.0.1:36346 fd=8 name=sentinel-5a18eecd-cmd age=1727 idle=0 flags=x db=0 sub=0 psub=0 multi=3 qbuf=0 qbuf-free=32768 obl=36 oll=0 omem=0 events=r cmd=exec')
5303:M 09 Feb 01:47:41.395 # CONFIG REWRITE executed with success.
5303:M 09 Feb 01:47:41.463 * 1 changes in 900 seconds. Saving...
5303:M 09 Feb 01:47:41.464 * Background saving started by pid 9725
9725:C 09 Feb 01:47:41.506 * DB saved on disk
9725:C 09 Feb 01:47:41.507 * RDB: 8 MB of memory used by copy-on-write
5303:M 09 Feb 01:47:41.565 * Background saving terminated with success
5312:S 09 Feb 01:47:42.196 # Connection with master lost.
5312:S 09 Feb 01:47:42.196 * Caching the disconnected master state.
5312:S 09 Feb 01:47:42.196 * Discarding previously cached master state.
5312:S 09 Feb 01:47:42.197 * SLAVE OF 127.0.0.1:7001 enabled (user request from 'id=5 addr=127.0.0.1:38372 fd=8 name=sentinel-5a18eecd-cmd age=1728 idle=0 flags=x db=0 sub=0 psub=0 multi=3 qbuf=133 qbuf-free=32635 obl=36 oll=0 omem=0 events=r cmd=exec')
5312:S 09 Feb 01:47:42.200 # CONFIG REWRITE executed with success.
5312:S 09 Feb 01:47:42.284 * 1 changes in 900 seconds. Saving...
5312:S 09 Feb 01:47:42.286 * Background saving started by pid 9726
5312:S 09 Feb 01:47:42.286 * Connecting to MASTER 127.0.0.1:7001
5312:S 09 Feb 01:47:42.287 * MASTER <-> SLAVE sync started
5312:S 09 Feb 01:47:42.287 * Non blocking connect for SYNC fired the event.
5312:S 09 Feb 01:47:42.287 * Master replied to PING, replication can continue...
5312:S 09 Feb 01:47:42.287 * Partial resynchronization not possible (no cached master)
5303:M 09 Feb 01:47:42.287 * Slave 127.0.0.1:7002 asks for synchronization
5303:M 09 Feb 01:47:42.287 * Full resync requested by slave 127.0.0.1:7002
5303:M 09 Feb 01:47:42.287 * Starting BGSAVE for SYNC with target: disk
5303:M 09 Feb 01:47:42.289 * Background saving started by pid 9727
5312:S 09 Feb 01:47:42.290 * Full resync from master: 4e882289bf41e7cef05f83f5e1d81fb8ad97e63e:348338
9726:C 09 Feb 01:47:42.345 * DB saved on disk
9726:C 09 Feb 01:47:42.346 * RDB: 6 MB of memory used by copy-on-write
9727:C 09 Feb 01:47:42.366 * DB saved on disk
9727:C 09 Feb 01:47:42.366 * RDB: 8 MB of memory used by copy-on-write
5303:M 09 Feb 01:47:42.368 * Background saving terminated with success
5312:S 09 Feb 01:47:42.368 * MASTER <-> SLAVE sync: receiving 77 bytes from master
5303:M 09 Feb 01:47:42.368 * Synchronization with slave 127.0.0.1:7002 succeeded
5312:S 09 Feb 01:47:42.368 * MASTER <-> SLAVE sync: Flushing old data
5312:S 09 Feb 01:47:42.368 * MASTER <-> SLAVE sync: Loading DB in memory
5312:S 09 Feb 01:47:42.368 * MASTER <-> SLAVE sync: Finished with success
5312:S 09 Feb 01:47:42.387 * Background saving terminated with success
OK
5296:M 09 Feb 01:48:05.885 # Connection with slave client id #2 lost.
5296:M 09 Feb 01:48:05.885 # Connection with slave client id #3 lost.
5296:S 09 Feb 01:48:15.954 * SLAVE OF 127.0.0.1:7001 enabled (user request from 'id=26 addr=127.0.0.1:34652 fd=26 name=sentinel-b9095b24-cmd age=10 idle=0 flags=x db=0 sub=0 psub=0 multi=3 qbuf=0 qbuf-free=32768 obl=36 oll=0 omem=0 events=r cmd=exec')
5296:S 09 Feb 01:48:15.956 # CONFIG REWRITE executed with success.
5296:S 09 Feb 01:48:16.010 * 1 changes in 900 seconds. Saving...
5296:S 09 Feb 01:48:16.011 * Background saving started by pid 9733
9733:C 09 Feb 01:48:16.046 * DB saved on disk
9733:C 09 Feb 01:48:16.047 * RDB: 4 MB of memory used by copy-on-write
5296:S 09 Feb 01:48:16.111 * Background saving terminated with success
5296:S 09 Feb 01:48:16.813 * Connecting to MASTER 127.0.0.1:7001
5296:S 09 Feb 01:48:16.813 * MASTER <-> SLAVE sync started
5296:S 09 Feb 01:48:16.813 * Non blocking connect for SYNC fired the event.
5296:S 09 Feb 01:48:16.813 * Master replied to PING, replication can continue...
5296:S 09 Feb 01:48:16.814 * Partial resynchronization not possible (no cached master)
5303:M 09 Feb 01:48:16.815 * Slave 127.0.0.1:7000 asks for synchronization
5303:M 09 Feb 01:48:16.815 * Full resync requested by slave 127.0.0.1:7000
5303:M 09 Feb 01:48:16.815 * Starting BGSAVE for SYNC with target: disk
5303:M 09 Feb 01:48:16.816 * Background saving started by pid 9734
5296:S 09 Feb 01:48:16.818 * Full resync from master: 4e882289bf41e7cef05f83f5e1d81fb8ad97e63e:355186
9734:C 09 Feb 01:48:16.855 * DB saved on disk
9734:C 09 Feb 01:48:16.856 * RDB: 6 MB of memory used by copy-on-write
5303:M 09 Feb 01:48:16.859 * Background saving terminated with success
5296:S 09 Feb 01:48:16.859 * MASTER <-> SLAVE sync: receiving 77 bytes from master
5303:M 09 Feb 01:48:16.859 * Synchronization with slave 127.0.0.1:7000 succeeded
5296:S 09 Feb 01:48:16.859 * MASTER <-> SLAVE sync: Flushing old data
5296:S 09 Feb 01:48:16.859 * MASTER <-> SLAVE sync: Loading DB in memory
5296:S 09 Feb 01:48:16.860 * MASTER <-> SLAVE sync: Finished with success


````

## 生产环境推荐

对于一个最小集群，Redis应该是一个Master带上两个Slave，并且开启下列选项：

````
min-slaves-to-write 1
min-slaves-max-lag 10
````
这样能保证写入Master的同时至少写入一个Slave，如果出现网络分区阻隔并发生failover的时候，可以保证写入的数据最终一致而不是丢失，写入老的Master会直接失败。

Slave可以适当设置优先级，除了0之外(0表示永远不提升为Master)，越小的优先级，越有可能被提示为Master。如果Slave分布在多个机房，可以考虑将和Master同一个机房的Slave的优先级设置的更低以提升他被选为新的Master的可能性。

考虑到可用性和选举的需要，Sentinel进程至少为3个，推荐为5个。如果有网络分区，应当适当分布(比如2个在A机房， 2个在B机房，一个在C机房)等。

## 增加和移除Sentinel

增加新的Sentinel实例非常简单，修改好配置文件，启动即可，其他Sentinel会自动发现该实例并加入集群。如果要批量启动一批Sentinel节点，最好以30秒的间隔一个一个启动为好，这样能确保整个 Sentinel集群的大多数能够及时感知到新节点，满足当时可能发生的选举条件。

移除一个Sentinel实例会相对麻烦一些，因为Sentinel不会忘记已经感知到的Sentinel实例，所以最好按照下列步骤来处理：

- 停止将要移除的sentinel进程。
- 给其余的sentinel进程发送SENTINEL RESET *命令来重置状态，忘记将要移除的sentinel，每个进程之间间隔30秒。
- 确保所有sentinel对于当前存货的sentinel数量达成一致，可以通过SENTINEL MASTER <mastername>命令来观察，或者查看配置文件。

## 客户端实现

客户端从过去直接连接Redis ，变成：

- 先连接一个Sentinel实例
- 使用 SENTINEL get-master-addr-by-name master-name 获取Redis地址信息。
- 连接返回的Redis地址信息，通过ROLE命令查询是否是Master。如果是，连接进入正常的服务环节。否则应该断开重新查询。
- (可选)客户端可以通过SENTINEL sentinels <master-name>来更新自己的Sentinel实例列表。

## 其它

由于Redis是异步复制，所以Sentinel其实无法达到强一致性，它承诺的是最终一致性：最后一次failover的Redis Master赢者通吃，其他Slave的数据将被丢弃，重新从新的Master复制数据

[参考Sentinel](http://www.yunweipai.com/archives/20444.html)