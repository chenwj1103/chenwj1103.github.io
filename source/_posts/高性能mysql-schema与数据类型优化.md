---
title: 高性能mysql-schema与数据类型优化
copyright: true
date: 2018-11-19 09:48:53
tags: mysql
categories: 高性能mysql

---

# 选择优化的数据类型

- 更小的通常更好

一般情况下，使用可以正确存储数据的最小数据类型，更小的类型通常更快，需要更小的磁盘、内存以及cpu缓存。但是需要确保没有低估需要存储的值的范围。

- 简单就好

简单的数据类型操作通常需要更少的cpu周期。整型比字符串操作代价更低，字符集和校对规则使字符比较耿复杂；应该使用mysql内建类型而不是使用字符串来存储日期和时间。

- 尽量避免null

null值是列的默认属性，最好指定not null,除非真的需要null值。

可为null的列，对mysql来说更难优化，null使得索引、索引统计和值比较都更为复杂，可为null的列会使用更多的存储空间。

## 整数类型

有两种存储类型，整数和实数。整数类型 tinyint（8）、smallint（16）、mediumint（24）、int（32）、bigint（64）。位存储空间，范围从-2的（n-1）次幂到2的（n-1）次幂。其中n是存储空间的位数。

整数类型有可选的unsigned属性，表示允许负值，大致可以使得存储范围上限提高一倍。例如tinyint unsigned可以是0-255，而tinyint的存储范围是-128至127

有符号和无符号类型使用相同的存储空间，并具有相同的性能，根据实际情况选择。

mysql可以为整数类型指定宽度，例如int(11)对大多数应用是没有意义的：它不会限制值的合法范围，只是规定mysql的一些交互工具（如mysql命令行客户端）来显示字符的格式，对于存储来说，int(1)和int(20)是一样的。

## 实数类型

- 实数是带有小数部分的数字。DECIMAL可以存储比bigInt还大的整数。DECIMAL类型用于存储精确的小数，DECIMAL支持精确的计算。cpu不支持对DECIMAL的直接结算，mysql服务器自身实现了DECIMAL的高精度计算。

- 浮点和DECIMAL类型都可以指定精度。DECIMAL在5.0以上版本允许存储65个数字，DECIMAL实际上不能再计算中使用这么大的数字，因为DECIMAL只是一种存储格式：因为在计算中DECIMAL会转换为DOUBLE类型。

- 因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL-例如财务数据，尽量在数据量比较大的情况下使用bigInt代替DECIMAL，将需要存储的货币单位乘以相应的倍数即可。

## 字符串类型

每个字符串可以定义自己的字符集和排序规则或者说校对规则。

### VARCHAR和CHAR类型

存储VARCHAR和CHAR值的方式在内存中和磁盘上可能不一样，所以mysql服务器从存储引擎读出的值可能需要转换为另一种存储格式。

#### VARCHAR

- VARCHAR存储可变长字符串,最常见。比定长的类型节省空间，只使用必要的空间，row_format=fixed的时候，每一行使用必要的空间。

- varchar使用1-2字节记录字符串长度,长度>255用2，<255用1.可以提升性能。但是由于变长，如果update操作使得某个字段空间增长，innodb使用分裂页来使得行放进页内。

**适合使用varchar**

字符串的最大长度比平均长度的大很多的、列的更新少的（碎片不是问题）、使用UTF-8这样的复杂的字符集，每个字符使用不同的字节数压缩；

#### CHAR

定长，总是根据定义的字符串长度分配足够的空间。存储char值时，删除末尾的空格，会根据长度进行填充以方便比较。

适合存储很短的字符串或者值长度接近的。经常变更的数据，char也比varchar更好，定长的char不容易产生过碎片。

`注意`：

某个字符串尾部的空格，varchar类型的会显示，char类型的会被去掉（在末尾填充空格只是存储，显示的时候不会显示）。

#### binary和varbinary

存储二进制字符串。存储的是字节码不是字符串；填充binary采用的是\0（零字节）而不是空格，检索时不会去掉填充值；

**优势**

存储二进制数据，希望mysql使用字节码而不是字符串比较。二进制不仅仅体现在大小写敏感上，比较binary字符串时，每次按照一个字节，根据字节的数值比较，比字符快很多。

`注意`：

使用varchar（5）和varchar（200）存储‘hello’的存储开销是一样的，但是更短的列有很大的优势。更长的列会消耗更多的内存，尤其在使用内存临时表进行排序等操作时更糟糕。

### blob和text类型

都是为大数据存储设计的字符串类型，分别采用二进制和字符方式存储。text是smalltext的同义词，blob是smallblob的同义词

- 字符类型：tinytext、smalltext、text、mediumtext、longtext.

- 二进制类型：tinyblob、smallblob、blob、mediumblob、longblob。

会把每个blob和text当做独立对象处理。存储引擎存储时会做特殊处理，当text、blob太大时，会在行内存储1-4个字节的指针，在专门的外部存储区域存储实际的值。

`区别`：

blob和text区别是使用二进制存储，没有排序规则或字符集，而text类型有字符集和排序规则；

mysql对blob和text的排序与其他类型不同，它支队没格列的最前的max_sort_length字节而不是整个字符串做排序，而不是整个字符串。如果字需要一部分字符，则可以减少max_sort_length的配置。

mysql不能使用它们的全部长度进行索引。

`注意`

尽量不要使用blob和text类型存储，无法避免的话在所有用到blob字段的地方使用subString(column,length)将列值转换为字符串。

## 日期和时间类型

mysql最小的时间粒度为秒。但是可以使用微秒级的粒度进行计算。mysql提供datetime和timestamp两种日期类型格式。除了特殊情况，通常尽量使用TIMESTAMP，因为它比DATETIME空间效率高。有人会使用整数存储时间截的格式不方便处理。

但是如果需要存储微秒级别的数据则尅使用bigint类型存储微秒级别的时间戳。

### DATETIME

存储范围 1001-9999，精度秒，它吧日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节的存储空间，默认以一种尅排序的无歧义的格式显示，如`2008-01-16 22:37:08``

#### TIMESTAMP

可以存储从1970年以来的秒数，使用4个字节存储空间，范围比DATETIME小得多，只能表示1970至2038年，mysql提供了from_unixtime()函数把时间戳转换为日，并提供unix_timestamp（）把日期转换为unix时间戳。

TIMESTAMP依赖时区，服务器、操作系统、客户端连接都有时区设置。它在不同的时区显示的时间是不同的。

TIMESTAMP类型默认为not null，默认为当前的时间。

## 位数据类型

mysql有几种存储类型使用紧凑的位存储类型数据，所有这些位类型，不管底层存储的格式和处理方式如何，从技术上来说都还是字符串类型。

### BIT

在mysql5.0之前bit是tinyint的同义词，之后的版本bit是完全不同的数据类型。

bit列在一列中存储一个或多个true/false值， bit(1)定义一个包含单个位的字段，bit位最大的长度为64个位。

bit的行为因存储引擎而异，mylSam会打包所有的bit位，所以17个单独的bit列只需要17个存储位，这样mylSam只能使用三个字节就能存储17个bit列。其它存储引擎如Memory何innoDB，为每个bit位使用一个足够存储的最小整数来存储，所以不能节省存储空间。

mysql把bit位要当做字符串存储，而不是数字类型，咋整数数字上下文的场景检索时，结果是将位字符转化为数字。这个不太好理解，所以大部分应用，最好避免使用这种类型。

### SET

打包set数据集和类型，他在mysql内部是使用一系列的打包的位的集合来表示的。



## 选择标识符

标识符类型就是关联表所使用的类型，要考虑这种类型如何计算和比较。例如存储整数使用enum和set类型，在比较时转化为字符串。

enum和set使用存储固定信息。

尽可能避免使用字符串类型作为表示列，因为他们很消耗空间，通常比数字类型慢。尤其在使用MylSAM表里使用字符串作为标识列时要特别小心，MylSAM默认对字符串使用压缩索引，这样会导致查询慢很多。


## 特殊类型的数据

某些类型的数据并不能直接与内置类型一直。低于秒级别的时间戳就是一个列子。


# Mysql schema设计中的缺陷

虽然有一些普遍的好或坏的设计原，但有一些问题还是由MySQL的实现机制导致的。

- 太多的列

mysql的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成个格列。从缓冲中将编码过的列转换成数据结构的操作代价是非常高的。

- 太多的关联

表过多的关联回合降低性能，单个查询最好在12个表以内做关联。

- 枚举

如果有枚举的情况存在，尽量使用一张字典表或者查找表来找具体的值。

- NUll

尽可能的避免使用null，如果一定要使用空值，可以使用0或者某个特殊的值代替。

但是不要走极端，因为-1带表未知的整数，可能导致代码复杂很多。比如date类型的 not null default '0000-00-00 00:00:00'

 -*/
# 范式和反范式

[数据库的三大范式](https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html)

## 范式的优点和缺点

- 范式的更新操作通常比反范式的块；
- 更好的范式化，更少或者没有重复数据，所以修改更少的数据；
- 范式化的表通常更小，更好的存储在内存中；
- 很少有多余的数据以为这检索表数据时更少需要distinct或者group by语句。

范式化设计的schema缺点是需要关联，稍微负载一些的查询语句符合范式化的schema可能需要一次关联。

## 反范式的有点和缺点

反范式的schema因为所有数据都在一张表中，可以很好的避免关联。

关联是的需要在一个索引中又排序又过滤。如果采用反范式化组织数据，将两张表的字段合并一下，只需要增加一个索引，这样不通过关联写出这个查询，这将会非常高效。

## 混合范式化和反范式化

在实际的使用中不用完全范式话，这避免了完全反范式化的插入和删除的问题。

# 缓存表和汇总表

有时提升性能最好的方法是在同一张表保存衍生的冗余数据，然后有时也需要创建一张完全独立的汇总表或缓存表。

**缓存表**表示存储那些可以简单的从schema其他表获取（但是每次获取的速度比较慢）数据的表。

**汇总表**保存的是使用group by语句聚合数据的表，或者被称为累计表。

# 加快alter table的操作速度

mysql的alter table操作的性能对大表来说是个大问题。mysql执行大部分修改表结构的操作的方法是用新的结构创建一个空表，然后从旧表中查询出所有数据插入新表，然后删除旧表。

这样操作会话费很长时间，如果内存不足而且表又很大，还有很多索引的情况下尤其如此。

## 大部分alter table操作导致mysql服务中断。

提供2中使用的技巧：

- 现在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换；
- ‘影子拷贝'，用要求的表结构创建一张和原表无关的新表，然后通过重命名和删除表交换两张表；

假如需要修改某列的默认值，可以直接修改.frm文件中。但是mysql不支持。

````
alter table sakila.film alter column rental_duration set DEFAULT 5;
````

这个语句会直接修改.frm文件不涉及表结构，所以操作是非常快的。

## 快速创建MylSAM索引

一个技巧是先禁用索引、载入数据然后重启索引：

````
alter table test.load_data disable keys;

-- load the data

alter table test.load_data enable keys;

````

这个对唯一索引无效， disable keys 只对非唯一索引有效。MylSAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性，一旦索引的大小超过了有效内存的大小，载入操作就非常慢。

# schema设计原则总结

- 尽快避免过度设计，例如会导致极其复杂查询的schema设计，或者很多列的表设计；
- 使用小而简单的合适数据类型，除非真是数据模型中确切需要，否则尽量避免使用NUll值；
- 尽量使用相同的数据类型存储相似或者相关的值，尤其是要在关联查询中使用到的列；
- 注意使用可变长字符串，其在临时表和排序时会导致悲观的按照最大长度分配内存；
- 尽量使用整型定义标识列；
- 尽量避免使用mysql遗弃的特性（指定浮点数的精度，或者整数显示宽度）小新使用enum和set，最好避免使用bit；































