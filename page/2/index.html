<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.chenwj.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习，坚持。">
<meta property="og:type" content="website">
<meta property="og:title" content="茄子的博客">
<meta property="og:url" content="http://www.chenwj.cn/page/2/index.html">
<meta property="og:site_name" content="茄子的博客">
<meta property="og:description" content="学习，坚持。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈伟杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.chenwj.cn/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>茄子的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="茄子的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茄子的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">75</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-04-14/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-hash%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-04-14/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-hash%E8%A1%A8/" class="post-title-link" itemprop="url">java数据结构和算法-hash表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 00:10:48" itemprop="dateCreated datePublished" datetime="2019-04-14T00:10:48+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hash表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。</p>
<h1 id="哈希函数的引入"><a href="#哈希函数的引入" class="headerlink" title="哈希函数的引入"></a>哈希函数的引入</h1><p>hash表时一种根据关键字值（key-value）进行访问的数据结构。通过把关键字映射到数组的某个小标来加快查找速度。</p>
<p>映射的话，将关键字hash话。</p>
<p>我们知道 ASCII 是一种编码，其中 a 表示97，b表示98，以此类推，一直到122表示z，而每个单词都是由这26个字母组成，我们可以不用 ASCII 编码那么大的数字，自己设计一套类似 ASCII的编码，比如a表示1，b表示2，依次类推，z表示26，那么表示方法我们就知道了。</p>
<p>但是这个肯定数量范围不够，那么肯定有一个位置存储了多个单词，每个数组的数据项平均要存储192个单词，如果要查找一个但是还是很慢。</p>
<ol>
<li>第一种方法：考虑每个数组包含一个子数组或者一个子链表，这种存储数据很快，但是姚村192个单词中找到一个还是很慢。</li>
<li>第二种方法：为啥要让那么多单词占据同一个数据项呢？也就是我们没有把单词分得足够开，数组表示的元素太少，我们需要扩展数组的下标，是其中每个位置都只存放一个单词。</li>
</ol>
<p>arrayIndex = largerNumber % smallRange</p>
<p>它把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。</p>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>把巨大的数字范围压缩到较小的数字范围，那么肯定会有几个不同的单词哈希化到同一个数组下标，即产生了冲突。</p>
<h2 id="开放地址法和链地址法"><a href="#开放地址法和链地址法" class="headerlink" title="开放地址法和链地址法"></a>开放地址法和链地址法</h2><p>冲突可能会导致哈希化方案无法实施，前面我们说指定的数组范围大小是实际存储数据的两倍，因此可能有一半的空间是空着的，所以，当冲突产生时，一个方法是通过系统的方法找到数组的一个空位，并把这个单词填入，而不再用哈希函数得到数组的下标，这种方法称为开放地址法。比如加入单词 cats 哈希化的结果为5421，但是它的位置已经被单词parsnip占用了，那么我们会考虑将单词 cats 存放在parsnip后面的一个位置 5422 上。</p>
<p>另一种方法，前面我们也提到过，就是数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中，这种方法称为链地址法。</p>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><p>开放地址法中，若数据项不能直接存放在由哈希函数所计算出来的数组下标时，就要寻找其他的位置。分别有三种方法：线性探测、二次探测以及再哈希法。</p>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>在线性探测中，它会线性的查找空白单元。比如如果 5421 是要插入数据的位置，但是它已经被占用了，那么就使用5422，如果5422也被占用了，那么使用5423，以此类推，数组下标依次递增，直到找到空白的位置。这就叫做线性探测，因为它沿着数组下标一步一步顺序的查找空白单元。</p>
<p>需要注意的是，当哈希表变得太满时，我们需要扩展数组，但是需要注意的是，数据项不能放到新数组中和老数组相同的位置，而是要根据数组大小重新计算插入位置。这是一个比较耗时的过程，所以一般我们要确定数据的范围，给定好数组的大小，而不再扩容。</p>
<h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><p>已填入哈希表的数据项和表长的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 2/3。当装填因子不太大时，聚集分布的比较连贯，而装填因子比较大时，则聚集发生的很大了。</p>
<h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p>二测探测是防止聚集产生的一种方式，思想是探测相距较远的单元，而不是和原始位置相邻的单元。</p>
<p>线性探测中，如果哈希函数计算的原始下标是x, 线性探测就是x+1, x+2, x+3, 以此类推；而在二次探测中，探测的过程是x+1, x+4, x+9, x+16，以此类推，到原始位置的距离是步数的平方。</p>
<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>我们知道二次聚集的原因是，二测探测的算法产生的探测序列步长总是固定的：1,4，9,16以此类推。那么我们想到的是需要产生一种依赖关键字的探测序列，而不是每个关键字都一样，那么，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。</p>
<h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>在开放地址法中，通过再哈希法寻找一个空位解决冲突问题，另一个方法是在哈希表每个单元中设置链表（即链地址法），某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这个位置的数据项只需要加到链表中，不需要在原始的数组中寻找空位。</p>
<p><img src="/images/datastructure/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>哈希表基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。用来解决冲突的有两种方法：开放地址法和链地址法。在开发地址法中，把冲突的数据项放在数组的其它位置；在链地址法中，每个单元都包含一个链表，把所有映射到同一数组下标的数据项都插入到这个链表中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-04-09/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%9511-%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-04-09/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%9511-%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">java数据结构和算法11-红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 23:36:35" itemprop="dateCreated datePublished" datetime="2019-04-09T23:36:35+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>二叉搜索树对于某个节点而言，其左子树的节点的关键值都小于该节点的关键值，右子树的所有节点的关键值都大于该节点的关键值。二叉搜索树作为一种数据结构，</p>
<p>增删改查的时间复杂度都是log以2为底n的对数，但是这个复杂度都是爱平衡的二叉搜索树上提现的，也就是如果插入的数据是随机的，则效率很高，但是如果是有序的从下到大的则，树为全部在右边。</p>
<p><img src="/images/datastructure/%E5%81%8F%E5%90%91%E7%9A%84%E6%A0%91.png" alt="偏向的树"></p>
<p>从小到大的都在右边，则这链表没有区别了。时间复杂度是o(n)。所示时间复杂度是在log以2为底n的对数和o(n)</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>那么为了能够以较快的时间O(logN)来搜索一棵树，我们需要保证树总是平衡的（或者大部分是平衡的），也就是说每个节点的左子树节点个数和右子树节点个数尽量相等。红-黑树的就是这样的一棵平衡树</p>
<p>对一个要插入的数据项（删除也是），插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。</p>
<h2 id="红黑树的特征"><a href="#红黑树的特征" class="headerlink" title="红黑树的特征"></a>红黑树的特征</h2><p>有两个特征</p>
<ol>
<li>节点都有颜色；</li>
<li>在插入和删除的过程中，要遵循保持这些颜色的不同排列规则；</li>
</ol>
<p>第一个很好理解，在红-黑树中，每个节点的颜色或者是黑色或者是红色的。当然也可以是任意别的两种颜色，这里的颜色用于标记，我们可以在节点类Node中增加一个boolean型变量isRed，以此来表示颜色的信息。</p>
<p>第二点，在插入或者删除一个节点时，必须要遵守的规则称为红-黑规则：<br>1.每个节点不是红色就是黑色的；<br>2.根节点总是黑色的；<br>3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)；<br>4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>
<p>新插入的节点颜色总是红色的，</p>
<p>这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。</p>
<p>另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，那么红-黑树是如何修正的呢？</p>
<h2 id="红黑树的自我修正"><a href="#红黑树的自我修正" class="headerlink" title="红黑树的自我修正"></a>红黑树的自我修正</h2><p>红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋。</p>
<h3 id="改变节点颜色"><a href="#改变节点颜色" class="headerlink" title="改变节点颜色"></a>改变节点颜色</h3><p>新插入的节点为15，一般新插入颜色都为红色，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则4。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。</p>
<p><img src="/images/datastructure/%E6%94%B9%E5%8F%98%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png" alt="改变节点颜色"></p>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。</p>
<p><img src="/images/datastructure/%E5%8F%B3%E6%97%8B.png" alt="右旋"></p>
<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的顶端节点必须要有右子节点。</p>
<p><img src="/images/datastructure/%E5%B7%A6%E6%97%8B.png" alt="左旋"></p>
<p>我们改变颜色也是为了帮助我们判断何时执行什么旋转，而旋转是为了保证树的平衡。光改变节点颜色是不能起到任何作用的，旋转才是关键的操作，在新增节点或者删除节点之后，可能会破坏二叉树的平衡，那么何时执行旋转以及执行什么旋转，这是我们需要重点关注的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.algorithm.tree.rbtree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 红黑树节点类</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 节点类和二叉树的节点类差不多，只不过在其基础上增加了一个 boolean 类型的变量来表示节点的颜色</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-04-10 12:18 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RBNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 颜色</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean color;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 关键值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    T key;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 左子节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RBNode&lt;T&gt; left;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 右子节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RBNode&lt;T&gt; right;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 父节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RBNode&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    RBNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public RBNode(boolean color, T key, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right, RBNode&lt;T&gt; parent) &#123;</span><br><span class="line">        this.color &#x3D; color;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取节点的关键值</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打印节点的关键值和颜色信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&quot; + key + (this.color ? &quot;R&quot; : &quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*************对红黑树节点x进行左旋操作 ******************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     *</span><br><span class="line">     * 左旋示意图：对节点x进行左旋</span><br><span class="line">     *     p                       p</span><br><span class="line">     *    &#x2F;                       &#x2F;</span><br><span class="line">     *   x                       y</span><br><span class="line">     *  &#x2F; \                     &#x2F; \</span><br><span class="line">     * lx  y      -----&gt;       x  ry</span><br><span class="line">     *    &#x2F; \                 &#x2F; \</span><br><span class="line">     *   ly ry               lx ly</span><br><span class="line">     *</span><br><span class="line">     * 左旋做了三件事：</span><br><span class="line">     * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span><br><span class="line">     * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span><br><span class="line">     * 3. 将y的左子节点设为x，将x的父节点设为y</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void leftRotate(RBNode&lt;T&gt; x) &#123;</span><br><span class="line">        &#x2F;&#x2F;1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)</span><br><span class="line">        RBNode&lt;T&gt; y &#x3D; x.right;</span><br><span class="line"></span><br><span class="line">        x.right &#x3D; y.left;</span><br><span class="line">        if (y.left !&#x3D; null) &#123;</span><br><span class="line">            y.left.parent &#x3D; x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span><br><span class="line">        y.parent &#x3D; x.parent;</span><br><span class="line">        if (x.parent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.root &#x3D; y;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (x &#x3D;&#x3D; x.parent.left) &#123;</span><br><span class="line">                x.parent.left &#x3D; y;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                x.parent.right &#x3D; y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 将y的左子节点设为x，将x的父节点设为y</span><br><span class="line">        y.left &#x3D; x;</span><br><span class="line">        x.parent &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*************对红黑树节点y进行右旋操作 ******************&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 左旋示意图：对节点y进行右旋</span><br><span class="line">     * p                   p</span><br><span class="line">     * &#x2F;                   &#x2F;</span><br><span class="line">     * y                   x</span><br><span class="line">     * &#x2F; \                 &#x2F; \</span><br><span class="line">     * x  ry   -----&gt;      lx  y</span><br><span class="line">     * &#x2F; \                     &#x2F; \</span><br><span class="line">     * lx  rx                   rx ry</span><br><span class="line">     * 右旋做了三件事：</span><br><span class="line">     * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span><br><span class="line">     * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span><br><span class="line">     * 3. 将x的右子节点设为y，将y的父节点设为x</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void rightRotate(RBNode&lt;T&gt; y) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 将y的左子节点赋给x的右子节点，并将y赋给x右子节点的父节点(x右子节点非空时)</span><br><span class="line">        RBNode&lt;T&gt; x &#x3D; y.left;</span><br><span class="line">        y.left &#x3D; x.right;</span><br><span class="line">        if (x.right !&#x3D; null) &#123;</span><br><span class="line">            x.right.parent &#x3D; y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span><br><span class="line">        x.parent &#x3D; y.parent;</span><br><span class="line"></span><br><span class="line">        if (y.parent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果y的父节点为空(即y为根节点)，则旋转后将x设为根节点</span><br><span class="line">            this.root &#x3D; x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (y &#x3D;&#x3D; y.parent.left) &#123;</span><br><span class="line">                &#x2F;&#x2F;则将x也设置为左子节点</span><br><span class="line">                y.parent.left &#x3D; x;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;否则将x设置为右子节点</span><br><span class="line">                y.parent.right &#x3D; x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3. 将x的左子节点设为y，将y的父节点设为y</span><br><span class="line">        x.right &#x3D; y;</span><br><span class="line">        y.parent &#x3D; x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>这与二叉搜索树中实现的思路一样，这里不再赘述，主要看看方法里面最后一步insertFixUp(node)操作。因为插入后可能会导致树的不平衡，insertFixUp(node) 方法里主要是分情况讨论，分析何时变色，何时左旋，何时右旋。我们先从理论上分析具体的情况，然后再看insertFixUp(node) 的具体实现。</p>
<p>　　如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况，我们就要开始变色和旋转了：</p>
<p>　　①、插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。</p>
<p>　　②、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。</p>
<p>　　③、插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子节点。</p>
<p>　　下面我们挨个分析这三种情况都需要如何操作，然后给出实现代码。</p>
<p>　　在下面的讨论中，使用N,P,G,U表示关联的节点。N(now)表示当前节点，P(parent)表示N的父节点，U(uncle)表示N的叔叔节点，G(grandfather)表示N的祖父节点，也就是P和U的父节点。</p>
<p>由于插入过程和删除过程比较复杂就不做分析。。。</p>
<h3 id="红黑树的效率"><a href="#红黑树的效率" class="headerlink" title="红黑树的效率"></a>红黑树的效率</h3><p>红黑树的查找、插入和删除时间复杂度都为O(log2N)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是O(log2N),(时间复杂度的计算要省略常数)，但实际上比普通的二叉树是要慢的。</p>
<p>大多数应用中，查找的次数比插入和删除的次数多，所以应用红黑树取代普通的二叉搜索树总体上不会有太多的时间开销。而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/8004211.html">参考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-03-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%9510-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-03-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%9510-%E6%A0%91/" class="post-title-link" itemprop="url">java数据结构和算法10-树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-26 23:25:02" itemprop="dateCreated datePublished" datetime="2019-03-26T23:25:02+08:00">2019-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们介绍数组的数据结构，我们知道对于有序数组，查找很快，并介绍可以通过二分法查找，但是想要在有序数组中插入一个数据项，就必须先找到插入数据项的位置，然后将所有插入位置后面的数据项全部向后移动一位，来给新数据腾出空间，平均来讲要移动N/2次，这是很费时的。同理，删除数据也是。</p>
<p>然后我们介绍了另外一种数据结构——链表，链表的插入和删除很快，我们只需要改变一些引用值就行了，但是查找数据却很慢了，因为不管我们查找什么数据，都需要从链表的第一个数据项开始，遍历到找到所需数据项为止，这个查找也是平均需要比较N/2次。</p>
<p>那么我们就希望一种数据结构能同时具备数组查找快的优点以及链表插入和删除快的优点，于是 树 诞生了。</p>
<h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><p><img src="/images/datastructure/%E6%A0%91.png" alt="树"></p>
<p>①、路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。</p>
<p>②、根：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p>
<p>③、父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；B是D的父节点。</p>
<p>④、子节点：一个节点含有的子树的根节点称为该节点的子节点；D是B的子节点。</p>
<p>⑤、兄弟节点：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点。</p>
<p>⑥、叶节点：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。</p>
<p>⑦、子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p>
<p>⑧、节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p>
<p>⑨、深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</p>
<p>⑩、高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树：树的每个节点最多只能有两个子节点。</p>
<p>二叉搜索树(binary search tree)：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>树的效率：查找节点的时间取决于这个节点所在的层数，每一层最多有2n-1个节点，总共N层共有2n-1个节点，那么时间复杂度为O(logn),底数为2。</p>
<h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><p>查找某个节点，我们必须从根节点开始遍历。</p>
<p>①、查找值比当前节点值大，则搜索右子树；</p>
<p>②、查找值等于当前节点值，停止搜索（终止条件）；</p>
<p>③、查找值小于当前节点值，则搜索左子树；</p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p> 要插入节点，必须先找到插入的位置。与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置，在比较的过程中要注意保存父节点的信息<br> 及 待插入的位置是父节点的左子树还是右子树，才能插入到正确的位置。</p>
<h2 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①、中序遍历:左子树——》根节点——》右子树 （根节点在中间）</span><br><span class="line">②、前序遍历:根节点——》左子树——》右子树 （根节点在前边）</span><br><span class="line">③、后序遍历:左子树——》右子树——》根节点 （根节点在后边）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/datastructure/%E9%81%8D%E5%8E%86%E6%A0%91.png" alt="遍历树"></p>
<h2 id="用数组表示树"><a href="#用数组表示树" class="headerlink" title="用数组表示树"></a>用数组表示树</h2><p>用数组表示树，那么节点是存在数组中的，节点在数组中的位置对应于它在树中的位置。下标为 0 的节点是根，下标为 1 的节点是根的左子节点，以此类推，按照从左到右的顺序存储树的每一层。</p>
<p><img src="/images/datastructure/%E7%94%A8%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%A0%91.png" alt="用数组表示树"></p>
<p>在大多数情况下，使用数组表示树效率是很低的，不满的节点和删除掉的节点都会在数组中留下洞，浪费存储空间。更坏的是，删除节点如果要移动子树的话，子树中的每个节点都要移到数组中新的位置，这是很费时的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>树是由边和节点构成，根节点是树最顶端的节点，它没有父节点；二叉树中，最多有两个子节点；某个节点的左子树每个节点都比该节点的关键字值小，右子树的每个节点都比该节点的关键字值大，那么这种树称为二叉搜索树，其查找、插入、删除的时间复杂度都为logN；可以通过前序遍历、中序遍历、后序遍历来遍历树，前序是根节点-左子树-右子树，中序是左子树-根节点-右子树，后序是左子树-右子树-根节点；删除一个节点只需要断开指向它的引用即可；哈夫曼树是二叉树，用于数据压缩算法，最经常出现的字符编码位数最少，很少出现的字符编码位数多一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.algorithm.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉树搜索树</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-04-08 11:22 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTree implements Tree &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Node find(int key) &#123;</span><br><span class="line"></span><br><span class="line">        Node current &#x3D; root;</span><br><span class="line"></span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前值比查找值大，搜索左子树</span><br><span class="line">            if (current.data &gt; key) &#123;</span><br><span class="line">                current &#x3D; current.leftNode;</span><br><span class="line">                &#x2F;&#x2F;当前值比查找值小，搜索右子树</span><br><span class="line">            &#125; else if (current.data &lt; key) &#123;</span><br><span class="line">                current &#x3D; current.rightNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean insert(int data) &#123;</span><br><span class="line"></span><br><span class="line">        Node newNode &#x3D; new Node(data);</span><br><span class="line">        &#x2F;&#x2F;当前树为空树，没有任何节点</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; newNode;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node current &#x3D; root;</span><br><span class="line">            Node parentNode &#x3D; null;</span><br><span class="line"></span><br><span class="line">            while (current !&#x3D; null) &#123;</span><br><span class="line">                parentNode &#x3D; current;</span><br><span class="line">                &#x2F;&#x2F;当前值比插入值大，搜索左子节点</span><br><span class="line">                if (current.data &gt; data) &#123;</span><br><span class="line">                    current &#x3D; current.leftNode;</span><br><span class="line">                    &#x2F;&#x2F;左子节点为空，直接将新值插入到该节点</span><br><span class="line">                    if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        parentNode.leftNode &#x3D; newNode;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    current &#x3D; current.rightNode;</span><br><span class="line">                    if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        parentNode.rightNode &#x3D; newNode;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(int key) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param current</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder(Node current) &#123;</span><br><span class="line"></span><br><span class="line">        if (current !&#x3D; null) &#123;</span><br><span class="line">            infixOrder(current.leftNode);</span><br><span class="line">            System.out.println(current.data + &quot; &quot;);</span><br><span class="line">            infixOrder(current.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param current</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder(Node current) &#123;</span><br><span class="line">        if (current !&#x3D; null) &#123;</span><br><span class="line">            System.out.println(current.data + &quot; &quot;);</span><br><span class="line">            preOrder(current.leftNode);</span><br><span class="line">            preOrder(current.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *</span><br><span class="line">     * @param current</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder(Node current) &#123;</span><br><span class="line"></span><br><span class="line">        if (current !&#x3D; null) &#123;</span><br><span class="line">            postOrder(current.leftNode);</span><br><span class="line">            postOrder(current.rightNode);</span><br><span class="line">            System.out.println(current.data + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找到最大的节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node findMax() &#123;</span><br><span class="line">        Node current &#x3D; root;</span><br><span class="line">        Node maxNode &#x3D; current;</span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            maxNode &#x3D; current;</span><br><span class="line">            current &#x3D; current.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找最小节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node finMin() &#123;</span><br><span class="line">        Node current &#x3D; root;</span><br><span class="line">        Node minNode &#x3D; current;</span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            minNode &#x3D; current;</span><br><span class="line">            current &#x3D; current.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(Node root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        BinaryTree bt &#x3D; new BinaryTree();</span><br><span class="line">        bt.insert(50);</span><br><span class="line">        bt.insert(20);</span><br><span class="line">        bt.insert(80);</span><br><span class="line">        bt.insert(10);</span><br><span class="line">        bt.insert(30);</span><br><span class="line">        bt.insert(60);</span><br><span class="line">        bt.insert(90);</span><br><span class="line">        bt.insert(25);</span><br><span class="line">        bt.insert(85);</span><br><span class="line">        bt.insert(100);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;infixOrder:&quot;);</span><br><span class="line">        bt.infixOrder(bt.root);</span><br><span class="line">        System.out.println(&quot;preOrder:&quot;);</span><br><span class="line">        bt.preOrder(bt.root);</span><br><span class="line">        System.out.println(&quot;postOrder:&quot;);</span><br><span class="line">        bt.postOrder(bt.root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;max:&quot; + bt.findMax().data);</span><br><span class="line">        System.out.println(&quot;min:&quot; + bt.finMin().data);</span><br><span class="line">        System.out.println(bt.find(100));</span><br><span class="line">        System.out.println(bt.find(200));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/8032642.html">参考资料</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-03-14/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%958-%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-03-14/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%958-%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">java数据结构和算法8-递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-14 00:14:41" itemprop="dateCreated datePublished" datetime="2019-03-14T00:14:41+08:00">2019-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%92%E5%BD%92/" itemprop="url" rel="index"><span itemprop="name">递归</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h1><p>递归就是在运行的过程中调用自己，必须具备三个要素：</p>
<p>1.边界条件；<br>2.递归前进段；<br>3.递归返回段；</p>
<p>当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<h1 id="第一个数的阶乘"><a href="#第一个数的阶乘" class="headerlink" title="第一个数的阶乘"></a>第一个数的阶乘</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.algorithm.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 求一个数的阶乘</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-14 11:53 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Recursion &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * for循环处理阶乘</span><br><span class="line">     * @param n</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int getFactorialFor(int n) &#123;</span><br><span class="line"></span><br><span class="line">        int temp &#x3D; 1;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">                temp &#x3D; temp * i;</span><br><span class="line">                System.out.println(&quot;i&#x3D;&#x3D;&#x3D;&quot; + i + &quot;,temp&#x3D;&#x3D;&quot; + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int getFactorial(int n) &#123;</span><br><span class="line">        if (n &gt;&#x3D; 0) &#123;</span><br><span class="line">            if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return n * getFactorial(n - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(getFactorialFor(3));</span><br><span class="line">        System.out.println(getFactorial(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="递归的二分查找"><a href="#递归的二分查找" class="headerlink" title="递归的二分查找"></a>递归的二分查找</h1><p>二分查找的数组一定是有序的</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在有序数组array[]中，不断将数组的中间值（mid）和被查找的值比较，如果被查找的值等于array[mid],就返回下标mid; 否则，就将查找范围缩小一半。如果被查找的值小于array[mid], 就继续在左半边查找;如果被查找的值大于array[mid],  就继续在右半边查找。 直到查找到该值或者查找范围为空时， 查找结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 找到目标值返回数组下标，找不到返回-1</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int findTwoPoint(int[] array, int key) &#123;</span><br><span class="line"></span><br><span class="line">    if (array &#x3D;&#x3D; null || array.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int min &#x3D; 0;</span><br><span class="line">    int max &#x3D; array.length - 1;</span><br><span class="line"></span><br><span class="line">    while (max &gt;&#x3D; min) &#123;</span><br><span class="line"></span><br><span class="line">        int mid &#x3D; (max + min) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        if (key &#x3D;&#x3D; array[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (key &gt; array[mid]) &#123;</span><br><span class="line"></span><br><span class="line">            min &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (key &lt; array[mid]) &#123;</span><br><span class="line">            max &#x3D; mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 递归二分查找</span><br><span class="line"> *</span><br><span class="line"> * @param low   低位</span><br><span class="line"> * @param high  高位</span><br><span class="line"> * @param array 有序数组</span><br><span class="line"> * @param key   要查找的值</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int sort(int low, int high, int[] array, int key) &#123;</span><br><span class="line"></span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">        int mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        if (key &#x3D;&#x3D; array[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (key &gt; array[mid]) &#123;</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">            sort(low, high, array, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (key &lt; array[mid]) &#123;</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">            sort(low, high, array, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><p>我们都将其看做只有两个盘子。假设有 N 个盘子在塔座A上，我们将其看为两个盘子，其中(N-1)~1个盘子看成是一个盘子，最下面第N个盘子看成是一个盘子，那么解决办法为：</p>
<p>　　①、先将A塔座的第(N-1)~1个盘子看成是一个盘子，放到中介塔座B上，然后将第N个盘子放到目标塔座C上。</p>
<p>　　②、然后A塔座为空，看成是中介塔座，B塔座这时候有N-1个盘子，将第(N-2)~1个盘子看成是一个盘子，放到中介塔座A上，然后将B塔座的第(N-1)号盘子放到目标塔座C上。</p>
<p>　　③、这时候A塔座上有(N-2)个盘子，B塔座为空，又将B塔座视为中介塔座，重复①，②步骤，直到所有盘子都放到目标塔座C上结束。</p>
<p>简单来说，跟把大象放进冰箱的步骤一样，递归算法为：</p>
<p>　　①、从初始塔座A上移动包含n-1个盘子到中介塔座B上。</p>
<p>　　②、将初始塔座A上剩余的一个盘子（最大的一个盘子）放到目标塔座C上。</p>
<p>　　③、将中介塔座B上n-1个盘子移动到目标塔座C上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void move(int dish, String from, String temp, String to) &#123;</span><br><span class="line"></span><br><span class="line">    if (dish &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        System.out.println(&quot;将盘子&quot; + dish + &quot;从塔座&quot; + from + &quot;移动到目标塔座&quot; + to);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;A为初始塔，B为目标塔，C为中介塔</span><br><span class="line">        move(dish - 1, from, to, temp);</span><br><span class="line">        System.out.println(&quot;将盘子&quot; + dish + &quot;从塔座&quot; + from + &quot;移动到目标塔座&quot; + to);</span><br><span class="line">        &#x2F;&#x2F;B为初始塔，C为目标塔，A是中介塔</span><br><span class="line">        move(dish - 1, temp, from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.algorithm.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 　归并算法的中心是归并两个已经有序的数组。归并两个有序数组A和B，就生成了第三个有序数组C。数组C包含数组A和B的所有数据项。</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-25 11:31 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int[] sort(int[] a, int[] b) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int aNum &#x3D; 0, bNum &#x3D; 0, cNum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int[] c &#x3D; new int[a.length + b.length];</span><br><span class="line"></span><br><span class="line">        while (aNum &lt; a.length &amp;&amp; bNum &lt; b.length) &#123;</span><br><span class="line">            &#x2F;&#x2F;将更小的复制给c数组</span><br><span class="line">            if (a[aNum] &gt; b[bNum]) &#123;</span><br><span class="line">                c[cNum++] &#x3D; b[bNum++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                c[cNum++] &#x3D; a[aNum++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果a数组全部赋值到c数组了，但是b数组还有元素，则将b数组剩余元素按顺序全部复制到c数组</span><br><span class="line">            while (aNum &#x3D;&#x3D; a.length &amp;&amp; bNum &lt; b.length) &#123;</span><br><span class="line">                c[cNum++] &#x3D; b[bNum++];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果b数组全部赋值到c数组了，但是a数组还有元素，则将a数组剩余元素按顺序全部复制到c数组</span><br><span class="line">            while (bNum &#x3D;&#x3D; b.length &amp;&amp; aNum &lt; a.length) &#123;</span><br><span class="line">                c[cNum++] &#x3D; a[aNum++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] a &#x3D; &#123;2, 5, 7, 8, 9, 10&#125;;</span><br><span class="line">        int[] b &#x3D; &#123;1, 2, 3, 5, 6, 10, 29&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int[] c &#x3D; sort(a, b);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; c.length - 1; i++) &#123;</span><br><span class="line">            System.out.println(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-03-06/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%955-%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-03-06/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%955-%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">java数据结构和算法5-队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-06 23:56:59" itemprop="dateCreated datePublished" datetime="2019-03-06T23:56:59+08:00">2019-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h1><p>队列（queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出。</p>
<h1 id="队列的分类"><a href="#队列的分类" class="headerlink" title="队列的分类"></a>队列的分类</h1><p>队列分为：</p>
<p>①、单向队列（Queue）：只能在一端插入数据，另一端删除数据。</p>
<p>②、双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。</p>
<p>③、这里我们还会介绍一种队列——优先级队列，优先级队列是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。</p>
<h1 id="java模拟单向队列"><a href="#java模拟单向队列" class="headerlink" title="java模拟单向队列"></a>java模拟单向队列</h1><p>①、与栈不同的是，队列中的数据不总是从数组的0下标开始的，移除一些队头front的数据后，队头指针会指向一个较高的下标位置，如下图：</p>
<p><img src="/images/datastructure/%E9%98%9F%E5%88%971.png" alt="队列1"></p>
<p>②、我们在设计时，队列中新增一个数据时，队尾的指针rear 会向上移动，也就是向下标大的方向。移除数据项时，队头指针 front 向上移动。那么这样设计好像和现实情况相反，比如排队买电影票，队头的买完票就离开了，然后队伍整体向前移动。在计算机中也可以在队列中删除一个数之后，队列整体向前移动，但是这样做效率很差。我们选择的做法是移动队头和队尾的指针。</p>
<p>③、如果向第②步这样移动指针，相信队尾指针很快就移动到数据的最末端了，这时候可能移除过数据，那么队头会有空着的位置，然后新来了一个数据项，由于队尾不能再向上移动了，为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.queue;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-07 12:13 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] queArray;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列总大小</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int maxSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前端</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int front;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后端</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int fear;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列中实际元素个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int nItems;</span><br><span class="line"></span><br><span class="line">    public MyQueue(int s) &#123;</span><br><span class="line">        this.maxSize &#x3D; s;</span><br><span class="line">        this.queArray &#x3D; new Object[maxSize];</span><br><span class="line">        front &#x3D; 0;</span><br><span class="line">        fear &#x3D; -1;</span><br><span class="line">        nItems &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回队列的大小</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return nItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否为空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return nItems &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否满了</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return maxSize &#x3D;&#x3D; nItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查看队头元素</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object peekFront() &#123;</span><br><span class="line">        return queArray[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移除元素</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object remove() &#123;</span><br><span class="line"></span><br><span class="line">        Object removeValue &#x3D; null;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            removeValue &#x3D; peekFront();</span><br><span class="line">            front++;</span><br><span class="line">            if (front &#x3D;&#x3D; maxSize) &#123;</span><br><span class="line">                front &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            nItems--;</span><br><span class="line">            return removeValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return removeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列中新增元素</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insert(Object value) &#123;</span><br><span class="line"></span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列已满！！！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (fear &#x3D;&#x3D; maxSize - 1) &#123;</span><br><span class="line">                fear &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;队尾指针加1，然后在队尾指针处插入新的数据</span><br><span class="line">            queArray[++fear] &#x3D; value;</span><br><span class="line">            nItems++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyQueue myQueue &#x3D; new MyQueue(4);</span><br><span class="line"></span><br><span class="line">        myQueue.insert(10);</span><br><span class="line">        myQueue.insert(20);</span><br><span class="line">        myQueue.insert(30);</span><br><span class="line">        myQueue.insert(40);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取队头元素</span><br><span class="line">        System.out.println(&quot;myQueue.peekFront():&quot; + myQueue.peekFront());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;移除元素</span><br><span class="line">        myQueue.remove();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;插入元素</span><br><span class="line">        myQueue.insert(50);</span><br><span class="line">        myQueue.insert(60);</span><br><span class="line"></span><br><span class="line">        for (Object a : myQueue.queArray) &#123;</span><br><span class="line">            System.out.println(&quot;a:&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>优先级队列（priority queue）是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。</p>
<p>数组实现优先级队列，声明为int类型的数组，关键字是数组里面的元素，在插入的时候按照从大到小的顺序排列，也就是越小的元素优先级越高。</p>
<h1 id="总结之前的数据结构"><a href="#总结之前的数据结构" class="headerlink" title="总结之前的数据结构"></a>总结之前的数据结构</h1><p>①、栈、队列（单向队列）、优先级队列通常是用来简化某些程序操作的数据结构，而不是主要作为存储数据的。</p>
<p>②、在这些数据结构中，只有一个数据项可以被访问。</p>
<p>③、栈允许在栈顶压入（插入）数据，在栈顶弹出（移除）数据，但是只能访问最后一个插入的数据项，也就是栈顶元素。</p>
<p>④、队列（单向队列）只能在队尾插入数据，对头删除数据，并且只能访问对头的数据。而且队列还可以实现循环队列，它基于数组，数组下标可以从数组末端绕回到数组的开始位置。</p>
<p>⑤、优先级队列是有序的插入数据，并且只能访问当前元素中优先级别最大（或最小）的元素。</p>
<p>⑥、这些数据结构都能由数组实现，但是可以用别的机制（后面讲的链表、堆等数据结构）实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-03-01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%954-%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-03-01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%954-%E6%A0%88/" class="post-title-link" itemprop="url">java数据结构和算法4-栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 01:09:50" itemprop="dateCreated datePublished" datetime="2019-03-01T01:09:50+08:00">2019-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>栈和队列被用作程序员的工具，它们作为构思算法的辅助工具，而不是完全的数据存储工具。这些数据结构的生命周期比数据库类型的结构要短得多，在程序执行期间它们才被创建，通常用它们去执行某项特殊的业务，执行完成之后，它们就被销毁。这里的它们就是——栈和队列。</p>
<h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><p>栈（英语：stack）又称为堆栈或堆叠，栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。</p>
<p>它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
<p>栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。</p>
<p>由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。栈也称为后进先出表</p>
<p><img src="/images/datastructure/%E6%A0%88.png" alt="栈"></p>
<h2 id="代码实现简单的栈"><a href="#代码实现简单的栈" class="headerlink" title="代码实现简单的栈"></a>代码实现简单的栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-05 11:47 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyStack &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈的实际元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int[] array;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前元素的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int top;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈的容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int maxSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MyStack(int size) &#123;</span><br><span class="line">        this.maxSize &#x3D; size;</span><br><span class="line">        array &#x3D; new int[size];</span><br><span class="line">        top &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入元素</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        if (top &lt; maxSize - 1) &#123;</span><br><span class="line">            array[++top] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 弹出元素</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return array[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 访问栈顶元素</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int peep() &#123;</span><br><span class="line">        return array[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈是否是空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return (top &#x3D;&#x3D; -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return (maxSize - 1) &#x3D;&#x3D; top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyStack myStack &#x3D; new MyStack(4);</span><br><span class="line"></span><br><span class="line">        myStack.push(10);</span><br><span class="line">        myStack.push(20);</span><br><span class="line">        myStack.push(1);</span><br><span class="line">        myStack.push(-1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;isFull:&quot; + myStack.isFull());</span><br><span class="line">        System.out.println(&quot;peek:&quot; + myStack.peep());</span><br><span class="line"></span><br><span class="line">        while (!myStack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;弹出：&quot; + myStack.pop());</span><br><span class="line">            System.out.println(&quot;栈内元素个数：&quot; + myStack.top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个栈是用数组实现的，内部定义了一个数组，一个表示最大容量的值以及一个指向栈顶元素的top变量。构造方法根据参数规定的容量创建一个新栈，push()方法是向栈中压入元素，指向栈顶的变量top加一，使它指向原顶端数据项上面的一个位置，并在这个位置上存储一个数据。</p>
<p>pop()方法返回top变量指向的元素，然后将top变量减一，便移除了数据项。要知道 top 变量指向的始终是栈顶的元素。</p>
<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a>产生的问题</h2><p>①、上面栈的实现初始化容量之后，后面是不能进行扩容的（虽然栈不是用来存储大量数据的），如果说后期数据量超过初始容量之后怎么办？（自动扩容）</p>
<p>②、我们是用数组实现栈，在定义数组类型的时候，也就规定了存储在栈中的数据类型，那么同一个栈能不能存储不同类型的数据呢？（声明为Object）</p>
<p>③、栈需要初始化容量，而且数组实现的栈元素都是连续存储的，那么能不能不初始化容量呢？（改为由链表实现）</p>
<h1 id="增强功能版栈"><a href="#增强功能版栈" class="headerlink" title="增强功能版栈"></a>增强功能版栈</h1><p>这个模拟的栈在JDK源码中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-06 12:31 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * object类型的数组可以存储任意类型</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Object[] elementData;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 指向栈顶的指针</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int top;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈的容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ArrayStack() &#123;</span><br><span class="line"></span><br><span class="line">        this.elementData &#x3D; new Object[10];</span><br><span class="line">        this.top &#x3D; -1;</span><br><span class="line">        this.size &#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayStack(int initialCapacity) &#123;</span><br><span class="line"></span><br><span class="line">        if (initialCapacity &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;栈的初始容量不得小于0：&quot; + initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">        this.top &#x3D; -1;</span><br><span class="line">        this.size &#x3D; initialCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object push(Object value) &#123;</span><br><span class="line">        isGrow(top + 1);</span><br><span class="line">        elementData[++top] &#x3D; value;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void remove(int top) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;栈顶元素置为null</span><br><span class="line">        elementData[top] &#x3D; null;</span><br><span class="line">        this.top--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object peek() &#123;</span><br><span class="line"></span><br><span class="line">        if (top &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return elementData[top];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        Object object &#x3D; peek();</span><br><span class="line">        remove(top);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isGrow(int minCapacity) &#123;</span><br><span class="line"></span><br><span class="line">        int oldCapacity &#x3D; size;</span><br><span class="line">        &#x2F;&#x2F;如果当前元素压入栈之后总容量大于前面定义的容量，则需要扩容</span><br><span class="line">        if (oldCapacity &lt;&#x3D; minCapacity) &#123;</span><br><span class="line">            &#x2F;&#x2F;定义扩大之后栈的总容量</span><br><span class="line">            int newCapacity &#x3D; 0;</span><br><span class="line">            if ((oldCapacity &lt;&lt; 1) - Integer.MAX_VALUE &gt; 0) &#123;</span><br><span class="line">                newCapacity &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newCapacity &#x3D; (oldCapacity &lt;&lt; 1);&#x2F;&#x2F;左移一位，相当于*2</span><br><span class="line">            &#125;</span><br><span class="line">            this.size &#x3D; newCapacity;</span><br><span class="line">            int[] newArray &#x3D; new int[size];</span><br><span class="line">            elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayStack stack &#x3D; new ArrayStack(3);</span><br><span class="line">        stack.push(1);</span><br><span class="line">        &#x2F;&#x2F;System.out.println(stack.peek());</span><br><span class="line">        stack.push(2);</span><br><span class="line">        stack.push(3);</span><br><span class="line">        stack.push(&quot;abc&quot;);</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="利用栈反转输出字符串"><a href="#利用栈反转输出字符串" class="headerlink" title="利用栈反转输出字符串"></a>利用栈反转输出字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RevertString &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;how are you &quot;;</span><br><span class="line">        char[] charArray &#x3D; str.toCharArray();</span><br><span class="line">        ArrayStack myStack &#x3D; new ArrayStack();</span><br><span class="line">        for (char c : charArray) &#123;</span><br><span class="line">            myStack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!myStack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(myStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="利用栈判断分隔符是否匹配"><a href="#利用栈判断分隔符是否匹配" class="headerlink" title="利用栈判断分隔符是否匹配　　"></a>利用栈判断分隔符是否匹配　　</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 利用栈判断分隔符是否匹配</span><br><span class="line"> * 比如：&lt;abc[123]abc&gt;这是符号相匹配的，如果是 &lt;abc[123&gt;abc] 那就是不匹配的。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 　对于 12&lt;a[b&#123;c&#125;]&gt;，我们分析在栈中的数据：遇到匹配正确的就消除</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-06 1:04 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestMatch &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遇到左边分隔符了就push进栈，遇到右边分隔符了就pop出栈，看出栈的分隔符是否和这个有分隔符匹配</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayStack arrayStack &#x3D; new ArrayStack(3);</span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;12&lt;a[b&#123;c&#125;]&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line"></span><br><span class="line">        for (char c : chars) &#123;</span><br><span class="line"></span><br><span class="line">            switch (c) &#123;</span><br><span class="line"></span><br><span class="line">                case &#39;&#123;&#39;:</span><br><span class="line">                case &#39;[&#39;:</span><br><span class="line">                case &#39;&lt;&#39;:</span><br><span class="line">                    arrayStack.push(c);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;&#125;&#39;:</span><br><span class="line">                case &#39;]&#39;:</span><br><span class="line">                case &#39;&gt;&#39;:</span><br><span class="line">                    if (!arrayStack.isEmpty()) &#123;</span><br><span class="line">                        char ch &#x3D; arrayStack.pop().toString().toCharArray()[0];</span><br><span class="line">                        if (c &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; ch !&#x3D; &#39;&#123;&#39; || c &#x3D;&#x3D; &#39;]&#39; &amp;&amp; ch !&#x3D; &#39;[&#39; ||</span><br><span class="line">                                c &#x3D;&#x3D; &#39;&gt;&#39; &amp;&amp; ch !&#x3D; &#39;&lt;&#39;) &#123;</span><br><span class="line">                            System.out.println(&quot;Error:&quot; + ch + &quot;-&quot; + c);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>栈要利用它的先进后出的特性处理数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-02-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%953-%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-02-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%953-%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">java数据结构和算法3-冒泡、选择、插入排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 23:31:13" itemprop="dateCreated datePublished" datetime="2019-02-26T23:31:13+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">排序算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>实现步骤如下：</p>
<p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个；<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数（也就是第一波冒泡完成）；<br>3.针对所有的元素重复以上的步骤，除了最后一个；<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p><img src="/images/datastructure/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.algorithm.sort;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-02-26 11:29 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BubbleSort2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int[] sort(int[] intArray) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (intArray.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里for循环表示总共需要比较多少轮</span><br><span class="line">        for (int i &#x3D; 0; i &lt; intArray.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;这里for循环表示每轮比较参与的元素下标</span><br><span class="line">            for (int j &#x3D; 1; j &lt; intArray.length; j++) &#123;</span><br><span class="line">                if (intArray[j - 1] &gt; intArray[j]) &#123;</span><br><span class="line">                    int temp;</span><br><span class="line">                    temp &#x3D; intArray[j - 1];</span><br><span class="line">                    intArray[j - 1] &#x3D; intArray[j];</span><br><span class="line">                    intArray[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;次排序完为:&quot;);</span><br><span class="line">            display(intArray);</span><br><span class="line">        &#125;</span><br><span class="line">        return intArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 遍历显示数组</span><br><span class="line">    public static void display(int[] array) &#123;</span><br><span class="line">        for (int anArray : array) &#123;</span><br><span class="line">            System.out.print(anArray + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; &#123;3, 0, 1, 90, 2, -1, 4&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(&quot;最后的结果为：&quot;);</span><br><span class="line">        display(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序解释"><a href="#冒泡排序解释" class="headerlink" title="冒泡排序解释"></a>冒泡排序解释</h2><p>冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，……，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，</p>
<p>这也是为什么 j 的范围是逐渐减小的。相信大家理解之后快速写出一个冒泡排序并不难。</p>
<h2 id="冒泡排序性能分析"><a href="#冒泡排序性能分析" class="headerlink" title="冒泡排序性能分析"></a>冒泡排序性能分析</h2><p>假设参与比较的数组元素个数为 N，则第一轮排序有 N-1 次比较，第二轮有 N-2 次，如此类推，这种序列的求和公式为：</p>
<p>（N-1）+（N-2）+…+1 = N*（N-1）/2</p>
<p>当 N 的值很大时，算法比较次数约为 N2/2次比较，忽略减1。</p>
<p>假设数据是随机的，那么每次比较可能要交换位置，可能不会交换，假设概率为50%，那么交换次数为 N2/4。不过如果是最坏的情况，初始数据是逆序的，那么每次比较都要交换位置。</p>
<p>交换和比较次数都和N2 成正比。由于常数不算大 O 表示法中，忽略 2 和 4，那么冒泡排序运行都需要 O(N2) 时间级别。</p>
<p>其实无论何时，只要看见一个循环嵌套在另一个循环中，我们都可以怀疑这个算法的运行时间为 O(N2)级，外层循环执行 N 次，内层循环对每一次外层循环都执行N次（或者几分之N次）。这就意味着大约需要执行N2次某个基本操作。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<ul>
<li><p>从待排序序列中，找到关键字最小的元素</p>
</li>
<li><p>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换</p>
</li>
<li><p>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束</p>
</li>
</ul>
<p><img src="/images/datastructure/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;总共进行n-1轮比较</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F;每轮需要比较的次数</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; array.length; j++) &#123;</span><br><span class="line">                if (array[j] &lt; array[min]) &#123;</span><br><span class="line">                    &#x2F;&#x2F;记录目前能找到的最小值元素的下标</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i !&#x3D; min) &#123;</span><br><span class="line">                int temp &#x3D; array[i];</span><br><span class="line">                array[i] &#x3D; array[min];</span><br><span class="line">                array[min] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;第 i轮排序的结果为</span><br><span class="line">            System.out.print(&quot;第&quot; + (i + 1) + &quot;轮排序后的结果为:&quot;);</span><br><span class="line">            display(array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历显示数组</span><br><span class="line">    public static void display(int[] array) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int[] array &#x3D; &#123;4, 2, 8, 9, 5, 7, 6, 1, 3&#125;;</span><br><span class="line">        &#x2F;&#x2F;未排序数组顺序为</span><br><span class="line">        System.out.println(&quot;未排序数组顺序为：&quot;);</span><br><span class="line">        display(array);</span><br><span class="line">        System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">        array &#x3D; sort(array);</span><br><span class="line">        System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">        System.out.println(&quot;经过选择排序后的数组顺序为：&quot;);</span><br><span class="line">        display(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">## 选择排序性能分析</span><br><span class="line"></span><br><span class="line">选择排序和冒泡排序执行了相同次数的比较：N*（N-1）&#x2F;2，但是至多只进行了N次交换。</span><br><span class="line"></span><br><span class="line">当 N 值很大时，比较次数是主要的，所以和冒泡排序一样，用大O表示是O(N2) 时间级别。但是由于选择排序交换的次数少，所以选择排序无疑是比冒泡排序快的。当 N 值较小时，如果交换时间比选择时间大的多，那么选择排序是相当快的</span><br><span class="line"></span><br><span class="line"># 插入排序</span><br><span class="line"></span><br><span class="line">直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</span><br><span class="line"></span><br><span class="line">插入排序还分为直接插入排序、二分插入排序、链表插入排序、希尔排序等等，这里我们只是以直接插入排序讲解，后面讲高级排序的时候会将其他的。</span><br><span class="line"></span><br><span class="line">![插入排序](&#x2F;images&#x2F;datastructure&#x2F;插入排序.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.chen.algorithm.sort;</p>
<p>/**</p>
<ul>
<li>@author :  chen weijie</li>
<li>@Date: 2019-03-01 12:35 AM</li>
<li>/<br>public class InsertSort {</li>
</ul>
<pre><code>public static int[] sort(int[] array) &#123;

    int j;
    //从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
    for (int i = 1; i &lt; array.length; i++) &#123;
        //记录要插入的数据
        int temp = array[i];
        j = i;
        //从已经排序的序列最右边的开始比较，找到比其小的数
        while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) &#123;
            //向后挪动
            array[j] = array[j - 1];
            j--;
        &#125;
        //存在比其小的数，插入
        array[j] = temp;
    &#125;
    return array;
&#125;

//遍历显示数组
public static void display(int[] array) &#123;
    for (int i = 0; i &lt; array.length; i++) &#123;
        System.out.print(array[i] + &quot; &quot;);
    &#125;
    System.out.println();
&#125;

public static void main(String[] args) &#123;
    int[] array = &#123;4, 2, 8, 9, 5, 7, 6, 1, 3&#125;;
    //未排序数组顺序为
    System.out.println(&quot;未排序数组顺序为：&quot;);
    display(array);
    System.out.println(&quot;-----------------------&quot;);
    array = sort(array);
    System.out.println(&quot;-----------------------&quot;);
    System.out.println(&quot;经过插入排序后的数组顺序为：&quot;);
    display(array);
&#125;</code></pre>
<p>}</p>
<pre><code>
## 插入排序性能分析

在第一轮排序中，它最多比较一次，第二轮最多比较两次，一次类推，第N轮，最多比较N-1次。因此有 1+2+3+...+N-1 = N*（N-1）/2。

假设在每一轮排序发现插入点时，平均只有全体数据项的一半真的进行了比较，我们除以2得到：N*（N-1）/4。用大O表示法大致需要需要 O(N2) 时间级别。

复制的次数大致等于比较的次数，但是一次复制与一次交换的时间耗时不同，所以相对于随机数据，插入排序比冒泡快一倍，比选择排序略快。

这里需要注意的是，如果要进行逆序排列，那么每次比较和移动都会进行，这时候并不会比冒泡排序快。

# 总结

上面讲的三种排序，冒泡、选择、插入用大 O 表示法都需要 O(N2) 时间级别。一般不会选择冒泡排序，虽然冒泡排序书写是最简单的，但是平均性能是没有选择排序和插入排序好的。

选择排序把交换次数降低到最低，但是比较次数还是挺大的。当数据量小，并且交换数据相对于比较数据更加耗时的情况下，可以应用选择排序。

在大多数情况下，假设数据量比较小或基本有序时，插入排序是三种算法中最好的选择。








</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-02-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%952-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-02-26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%952-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">java数据结构和算法2-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 22:47:00" itemprop="dateCreated datePublished" datetime="2019-02-26T22:47:00+08:00">2019-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="java数组介绍"><a href="#java数组介绍" class="headerlink" title="java数组介绍"></a>java数组介绍</h1><p>在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object类型数组除外)</p>
<h2 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h2><p>数据类型[] 数组名称 = new 数据类型[数组长度];</p>
<p>数据类型[] 数组名称 = {数组元素1，数组元素2，数组元素3…..}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明数组1,声明一个长度为3，只能存放int类型的数据</span><br><span class="line">int [] myArray &#x3D; new int[3];</span><br><span class="line">&#x2F;&#x2F;声明数组2,声明一个数组元素为 1,2,3的int类型数组</span><br><span class="line">int [] myArray2 &#x3D; &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure>

<p>数组的下标从0开始，但是length属性记录的是数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明数组2,声明一个数组元素为 1,2,3的int类型数组，记着不是myArray2.length-1</span><br><span class="line">int [] myArray2 &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">for(int i &#x3D; 0 ; i &lt; myArray2.length ; i++)&#123;</span><br><span class="line">    System.out.println(myArray2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-02-26 10:57 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyArray &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;实现 增、删、查、迭代功能</span><br><span class="line"></span><br><span class="line">    private int [] intArray;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数组的元素的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int elems;</span><br><span class="line"></span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造一个长度为50的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MyArray() &#123;</span><br><span class="line">        elems &#x3D; 0;</span><br><span class="line">        length &#x3D; 50;</span><br><span class="line">        intArray &#x3D; new int[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取数组的有效长度</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return elems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; elems; i++) &#123;</span><br><span class="line">            System.out.println(intArray[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数组中添加元素</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean add(int value) &#123;</span><br><span class="line"></span><br><span class="line">        if (length &#x3D;&#x3D; elems) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intArray[elems] &#x3D; value;</span><br><span class="line">            elems++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据下标获取元素</span><br><span class="line">     * @param i</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getElems(int i) &#123;</span><br><span class="line"></span><br><span class="line">        if (i &lt; 0 || i &gt; elems) &#123;</span><br><span class="line">            System.out.println(&quot;数组下标越界&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return intArray[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找元素 查找的元素如果存在则返回下标值，如果不存在，返回 -1</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int find(int value) &#123;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; elems; i++) &#123;</span><br><span class="line">            if (value &#x3D;&#x3D; intArray[i]) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果要删除的值不存在，直接返回 false;否则返回true，删除成功</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean delete(int value) &#123;</span><br><span class="line"></span><br><span class="line">        int k &#x3D; find(value);</span><br><span class="line">        if (k &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (k &#x3D;&#x3D; elems - 1) &#123;</span><br><span class="line">                elems--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; elems - 1; i++) &#123;</span><br><span class="line">                    intArray[elems] &#x3D; intArray[elems + 1];</span><br><span class="line">                &#125;</span><br><span class="line">                elems--;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改成功返回true，修改失败返回false</span><br><span class="line">     *</span><br><span class="line">     * @param oldValue</span><br><span class="line">     * @param newValue</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean modify(int oldValue, int newValue) &#123;</span><br><span class="line">        int i &#x3D; find(oldValue);</span><br><span class="line">        if (i &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            System.out.println(&quot;需要修改的数据不存在&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intArray[i] &#x3D; newValue;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyArray myArray &#x3D; new MyArray();</span><br><span class="line">        myArray.add(1);</span><br><span class="line">        myArray.add(12);</span><br><span class="line">        myArray.add(13);</span><br><span class="line">        myArray.add(14);</span><br><span class="line">        myArray.add(15);</span><br><span class="line"></span><br><span class="line">        myArray.display();</span><br><span class="line">        System.out.println(&quot;find 12:&quot; + myArray.find(12));</span><br><span class="line">        System.out.println(&quot;find 10:&quot; + myArray.find(10));</span><br><span class="line">        myArray.delete(10);</span><br><span class="line">        System.out.println(&quot;get i&#x3D;2 :&quot; + myArray.getElems(2));</span><br><span class="line">        System.out.println(&quot;size:&quot; + myArray.getSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数组的局限性"><a href="#数组的局限性" class="headerlink" title="数组的局限性"></a>数组的局限性</h1><p>1.插入快，对于无序数组，上面我们实现的数组就是无序的，即元素没有按照从大到小或者某个特定的顺序排列，只是按照插入的顺序排列。无序数组增加一个元素很简单，只需要在数组末尾添加元素即可，但是有序数组却不一定了，它需要在指定的位置插入<br>2.查找慢，当然如果根据下标来查找是很快的。但是通常我们都是根据元素值来查找，给定一个元素值，对于无序数组，我们需要从数组第一个元素开始遍历，直到找到那个元素。有序数组通过特定的算法查找的速度会比无需数组快，后面我们会讲各种排序算法。<br>3.删除慢，根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。<br>4.数组一旦创建后，大小就固定了，不能动态扩展数组的元素个数。如果初始化你给一个很大的数组大小，那会白白浪费内存空间，如果给小了，后面数据个数增加了又添加不进去了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-02-23/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%951-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-02-23/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%951-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">java数据结构和算法1-简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-23 01:12:17" itemprop="dateCreated datePublished" datetime="2019-02-23T01:12:17+08:00">2019-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/" itemprop="url" rel="index"><span itemprop="name">数据结构简介</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>将一个班级的学生名字要临时存储在内存中，你会选择什么数据结构来存储，数组还是ArrayList，或者HashSet，或者别的数据结构。如果不懂数据结构的，可能随便选择一个容器来存储，也能完成所有的功能，但是后期如果随着学生数据量的增多，随便选择的数据结构肯定会存在性能问题，而一个懂数据结构和算法的人，在实际编程中会选择适当的数据结构来解决相应的问题，会极大的提高程序的性能。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关</p>
<h2 id="数据结构的基本功能"><a href="#数据结构的基本功能" class="headerlink" title="数据结构的基本功能"></a>数据结构的基本功能</h2><p>1.如何插入一条新的数据项<br>2.如何寻找某一特定的数据项<br>3.如何删除某一特定的数据项<br>4.如何迭代的访问各个数据项，以便进行显示或其他操作</p>
<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><ul>
<li>数组 array</li>
<li>链表 linkedList</li>
<li>堆 heap</li>
<li>栈 stack</li>
<li>队列 queue</li>
<li>树 tree </li>
<li>哈希表 hash</li>
<li>图 graph</li>
</ul>
<p><img src="/images/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="数据结构的优缺点"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法简单来说就是解决问题的步骤。</p>
<p>在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p>
<h2 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h2><ul>
<li><p>有穷性：对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</p>
</li>
<li><p>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</p>
</li>
<li><p>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</p>
</li>
<li><p>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</p>
</li>
<li><p>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</p>
</li>
</ul>
<h2 id="算法的设计原则"><a href="#算法的设计原则" class="headerlink" title="算法的设计原则"></a>算法的设计原则</h2><ul>
<li><p>正确性：程序无语法错误。程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</p>
</li>
<li><p>可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</p>
</li>
<li><p>健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</p>
</li>
<li><p>高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2019-02-22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%957-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-02-22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%957-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">java数据结构和算法7-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-22 00:07:05" itemprop="dateCreated datePublished" datetime="2019-02-22T00:07:05+08:00">2019-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们知道数组是一种通用的数据结构，能用来实现栈、队列等很多数据结构。而链表也是一种使用广泛的通用数据结构，它也可以用来作为实现栈、队列等数据结构的基础，基本上除非需要频繁的通过下标来随机访问各个数据，否则很多使用数组的地方都可以用链表来代替。</p>
<p>但是我们需要说明的是，链表是不能解决数据存储的所有问题的，它也有它的优点和缺点。本篇博客我们介绍几种常见的链表，分别是单向链表、双端链表、有序链表、双向链表以及有迭代器的链表。并且会讲解一下抽象数据类型（ADT）的思想，如何用 ADT 描述栈和队列，如何用链表代替数组来实现栈和队列。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）</p>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p>
<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><p>单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p>
<p>单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p>
<p><img src="/images/datastructure/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="单向链表结构"></p>
<p><img src="/images/datastructure/%E5%9C%A8%E8%A1%A8%E5%A4%B4%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9.png" alt="在表头增加节点"></p>
<p><img src="/images/datastructure/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png" alt="删除节点"></p>
<h2 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.linklistnode;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 单链表的具体实现</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-02-21 11:35 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;链表节点的个数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;头节点</span><br><span class="line">    private Node head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;每个节点的数据</span><br><span class="line">        private Object data;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;每个节点指向下一个节点的连接</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(Object data) &#123;</span><br><span class="line">            this.data &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 单链表的表头添加元素</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object addHead(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node newHead &#x3D; new Node(data);</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            head &#x3D; newHead;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newHead.next &#x3D; head;</span><br><span class="line">            head &#x3D; newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除链表头节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object deleteHead() &#123;</span><br><span class="line">        Object data &#x3D; head.data;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">        size--;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 找到指定元素返回节点Node，找不到返回null</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node find(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node current &#x3D; head;</span><br><span class="line"></span><br><span class="line">        int tempSize &#x3D; size;</span><br><span class="line">        while (tempSize &gt; 0) &#123;</span><br><span class="line">            if (data.equals(current.data)) &#123;</span><br><span class="line">                return current;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                current &#x3D; current.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除指定元素，删除成功返回true</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean delete(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Node current &#x3D; head;</span><br><span class="line">        Node previous &#x3D; head;</span><br><span class="line"></span><br><span class="line">        while (current.data !&#x3D; data) &#123;</span><br><span class="line">            if (current.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                previous &#x3D; current;</span><br><span class="line">                current &#x3D; current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果删除的节点是第一个节点</span><br><span class="line">        if (current &#x3D;&#x3D; head) &#123;</span><br><span class="line">            head &#x3D; current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;删除的节点不是第一个节点</span><br><span class="line">            previous.next &#x3D; current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断链表是不是空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示节点信息</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            Node node &#x3D; head;</span><br><span class="line">            int tempSize &#x3D; size;</span><br><span class="line">            &#x2F;&#x2F;当前链表只有一个节点</span><br><span class="line">            if (tempSize &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                System.out.println(&quot;[&quot; + node.data + &quot;]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            while (tempSize &gt; 0) &#123;</span><br><span class="line">                if (node.equals(head)) &#123;</span><br><span class="line">                    System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;);</span><br><span class="line">                &#125; else if (node.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    System.out.print(node.data + &quot;]&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.print(node.data + &quot;-&gt;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                node &#x3D; node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果链表一个节点都没有，直接打印[]</span><br><span class="line">            System.out.println(&quot;[]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">        singleLinkedList.addHead(&quot;A&quot;);</span><br><span class="line">        singleLinkedList.addHead(&quot;B&quot;);</span><br><span class="line">        singleLinkedList.addHead(&quot;C&quot;);</span><br><span class="line">        singleLinkedList.addHead(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.display();</span><br><span class="line">        singleLinkedList.delete(&quot;B&quot;);</span><br><span class="line">        singleLinkedList.display();</span><br><span class="line">        System.out.println(&quot;find:&quot; + singleLinkedList.find(&quot;D&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用单向链表实现栈"><a href="#用单向链表实现栈" class="headerlink" title="用单向链表实现栈"></a>用单向链表实现栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.linklistnode;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用单向链表实现栈</span><br><span class="line"> * 栈的pop()方法和push()方法，对应于链表的在头部删除元素deleteHead()以及在头部增加元素addHead()。</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-08 12:57 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StackSingleLink &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private SingleLinkedList linkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public StackSingleLink(SingleLinkedList linkedList) &#123;</span><br><span class="line">        this.linkedList &#x3D; linkedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object data) &#123;</span><br><span class="line">        linkedList.addHead(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        return linkedList.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return linkedList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h1><p>对于单项链表，我们如果想在尾部添加一个节点，那么必须从头部一直遍历到尾部，找到尾节点，然后在尾节点后面插入一个节点。这样操作很麻烦，如果我们在设计链表的时候多个对尾节点的引用，那么会简单很多。</p>
<p><img src="/images/datastructure/%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8.png" alt="双端链表"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.linknode;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 双端队列</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-13 11:12 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DoublePointLinkedList &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Node head;</span><br><span class="line"></span><br><span class="line">    private Node tail;</span><br><span class="line"></span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line"></span><br><span class="line">        private Object data;</span><br><span class="line"></span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(Object data) &#123;</span><br><span class="line">            this.data &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public DoublePointLinkedList() &#123;</span><br><span class="line">        this.head &#x3D; null;</span><br><span class="line">        this.tail &#x3D; null;</span><br><span class="line">        this.size &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 头部添加节点</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addHead(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node node &#x3D; new Node(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果链表为空，那么头节点和尾节点都是该新增节点</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            size &#x3D; 0;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void addTail(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node node &#x3D; new Node(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果链表为空，那么头节点和尾节点都是该新增节点</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            size &#x3D; 0;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.next &#x3D; tail;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除头节点</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean deleteHead() &#123;</span><br><span class="line"></span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            head &#x3D; null;</span><br><span class="line">            tail &#x3D; null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是否为空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return (size &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得链表的节点个数</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示节点信息</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            Node node &#x3D; head;</span><br><span class="line">            int tempSize &#x3D; size;</span><br><span class="line">            if (tempSize &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;当前链表只有一个节点</span><br><span class="line">                System.out.println(&quot;[&quot; + node.data + &quot;]&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            while (tempSize &gt; 0) &#123;</span><br><span class="line">                if (node.equals(head)) &#123;</span><br><span class="line">                    System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;);</span><br><span class="line">                &#125; else if (node.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    System.out.print(node.data + &quot;]&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.print(node.data + &quot;-&gt;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                node &#x3D; node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; else &#123;&#x2F;&#x2F;如果链表一个节点都没有，直接打印[]</span><br><span class="line">            System.out.println(&quot;[]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>我们知道单向链表只能从一个方向遍历，那么双向链表它可以从两个方向遍历。</p>
<p><img src="/images/datastructure/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.dataStructure.linknode;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 双向链表</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2019-03-13 11:49 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TwoWayLinkedList &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    private Node head;</span><br><span class="line"></span><br><span class="line">    private Node tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public class Node &#123;</span><br><span class="line"></span><br><span class="line">        private Object data;</span><br><span class="line"></span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        private Node prew;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Node(Object data) &#123;</span><br><span class="line">            this.data &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public TwoWayLinkedList() &#123;</span><br><span class="line">        this.size &#x3D; 0;</span><br><span class="line">        this.head &#x3D; null;</span><br><span class="line">        this.tail &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void addHead(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node node &#x3D; new Node(data);</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.prew &#x3D; node;</span><br><span class="line">            node.next &#x3D; head;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void addTail(Object data) &#123;</span><br><span class="line"></span><br><span class="line">        Node node &#x3D; new Node(data);</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prew &#x3D; tail;</span><br><span class="line">            tail.next &#x3D; node;</span><br><span class="line">            tail &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Node deleteHead() &#123;</span><br><span class="line"></span><br><span class="line">        Node temp &#x3D; head;</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">            head.prew &#x3D; null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node deleteTail() &#123;</span><br><span class="line"></span><br><span class="line">        Node temp &#x3D; tail;</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            tail &#x3D; head.prew;</span><br><span class="line">            tail.next &#x3D; null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈伟杰"
      src="/images/favicon.ico">
  <p class="site-author-name" itemprop="name">陈伟杰</p>
  <div class="site-description" itemprop="description">学习，坚持。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenwj1103" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenwj1103" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈伟杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">638k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
