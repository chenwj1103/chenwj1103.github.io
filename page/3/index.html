<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenwj1103.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习，坚持。">
<meta property="og:type" content="website">
<meta property="og:title" content="茄子的博客">
<meta property="og:url" content="http://chenwj1103.github.io/page/3/index.html">
<meta property="og:site_name" content="茄子的博客">
<meta property="og:description" content="学习，坚持。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈伟杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chenwj1103.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>茄子的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="茄子的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茄子的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">74</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-12-16/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-12-16/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">高性能mysql-优化服务器配置以及高可用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-16 22:53:36" itemprop="dateCreated datePublished" datetime="2018-12-16T22:53:36+08:00">2018-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql的配置文件"><a href="#mysql的配置文件" class="headerlink" title="mysql的配置文件"></a>mysql的配置文件</h1><p>查找mysql的配置文件的详细参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --help --verbose | less</span><br></pre></td></tr></table></figure>
<p>查找myqsql配置文件放置的默认位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --help|grep &#39;my.cnf&#39;</span><br></pre></td></tr></table></figure>


<p>大部分的配置的默认值是最佳配置了，所以最好不要改动太多配置。</p>
<p><img src="/images/mysql/mysql%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="基础配置文件"></p>
<p>需要设置数据的位置，pid的配置。使用mysql用户来运行mysqld进程，需要确保这个账户存在，并且拥有操作数据目录的权限，端口设置为默认的3306。innoDB作为默认的存储引擎。</p>
<p>为innoDB配置合适的缓冲池（buffer pool）和日志文件（log file）是必须的。其它的innoDB配置都是可选的。缓冲池大小设置为服务器内存的约75%-80%。</p>
<h2 id="检查服务器的状态"><a href="#检查服务器的状态" class="headerlink" title="检查服务器的状态"></a>检查服务器的状态</h2><p>查看服务器的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status </span><br></pre></td></tr></table></figure>

<h1 id="配置内存使用"><a href="#配置内存使用" class="headerlink" title="配置内存使用"></a>配置内存使用</h1><p>mysql的内存消耗分为可以控制和补课控制的内存。可以按照如下步骤来配置内存：</p>
<p>1.确定可以使用内存的上限；<br>2.确定每个连接mysql需要使用多少内存，例如排序缓冲和临时表；<br>3.确定操作系统需要使用多少内存（包括其他应用）；<br>4.把剩下的内存全部给mysql的缓存，例如innoDB缓冲池；</p>
<h2 id="mysql可以使用多少内存"><a href="#mysql可以使用多少内存" class="headerlink" title="mysql可以使用多少内存"></a>mysql可以使用多少内存</h2><p>mysql都有允许使用的内存上限。mysql是单进程多线程的运行模式。整体可以使用的内存量也许会受操作系统的额限制。</p>
<h2 id="每个连接需要的内存"><a href="#每个连接需要的内存" class="headerlink" title="每个连接需要的内存"></a>每个连接需要的内存</h2><p>myisam_sort_buffer_size设置为256M，连接最多为100个，最坏的情况是使用25G内存，但是这是几乎不可能发生的，使用临时表或复杂的存储过程的查询是导致高内存消耗最可能的原因。</p>
<h2 id="为操作系统保留内存"><a href="#为操作系统保留内存" class="headerlink" title="为操作系统保留内存"></a>为操作系统保留内存</h2><p>给操作系统留2GB或者总内存的5%作为基准，以较大者为准。</p>
<h2 id="为缓存分配内存"><a href="#为缓存分配内存" class="headerlink" title="为缓存分配内存"></a>为缓存分配内存</h2><p>innoDB缓冲池、innoDB日志文件和MyLSAM数据的操作系统缓存、MyLSAM键缓存、查询缓存等；</p>
<h2 id="innoDB缓冲池"><a href="#innoDB缓冲池" class="headerlink" title="innoDB缓冲池"></a>innoDB缓冲池</h2><p>innoDB缓冲池并不仅仅缓存索引，还会缓存行的数据、自适应hash索引、插入缓冲、锁以及其它内部数据结构；innoDB还是用缓冲池来帮助延迟写入，这样就能合并多个写入操作，然后一起顺序的</p>
<p>缓冲池太大，重启服务器也需要花很长时间来预热缓冲池。</p>
<h2 id="MylSAM键缓存"><a href="#MylSAM键缓存" class="headerlink" title="MylSAM键缓存"></a>MylSAM键缓存</h2><p>MylSAM键缓存也成为键缓冲，默认只有一个键缓存，它只是缓存索引，不缓存数据。</p>
<p>索引存储占用的空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(index_length) from informathon_schema.tables where engine &#x3D;&#39;mylsam&#39;</span><br></pre></td></tr></table></figure>
<p>key_buffer_size =1G，表示键缓冲的大小。默认的所有的MyLSAM的索引都存储在缓存中。</p>
<h2 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h2><p>线程缓存保存那些当前没有与连接关联但是准备为后面新的连接服务的线程。当一个新的连接创建时，如果缓存中有线程存在，mysql从缓存中删除一个线程，并且把它分配给这个新的连接。当连接关闭时，如果线程缓存还有空间，则把线程返回缓存。</p>
<p>thread_cache_size变量指定了mysql可以保持在缓存中的线程数。</p>
<h2 id="表缓存"><a href="#表缓存" class="headerlink" title="表缓存"></a>表缓存</h2><p>表缓存和线程缓存的概念是相似的，但存储的对象代表的是表。每个在缓存中的对象包含相关表.frm文件的解析结果，加上一些其他数据。</p>
<p>表缓存对于innoDB表没有太大意义。</p>
<h2 id="innoDB数据字典"><a href="#innoDB数据字典" class="headerlink" title="innoDB数据字典"></a>innoDB数据字典</h2><p>innoDB有自己的表缓存，可以成为表定义缓存或者数据字典。当innoDB打开一张表就增加一个对应的对象到数据字典，每张表可能占用4KB或者更多内存，关闭也不会清除，最新的版本添加来了一种缓存过期策略，清除长时间不适用的缓存。</p>
<p>另一个性能问题是打开表时会计算统计信息，这需要很多IO操作，所以代价很高。innoDB没有将统计信息持久化到硬盘，每次打开表都会重新计算（MyLSAM做了持久化）。</p>
<h1 id="配置mysql的IO行为"><a href="#配置mysql的IO行为" class="headerlink" title="配置mysql的IO行为"></a>配置mysql的IO行为</h1><p>有一些配置影响着mysql同步数据到磁盘以及如何做恢复操作，这些操作对性能的响应非常大，因为涉及昂贵的IO操作。</p>
<h2 id="innoDB的IO配置"><a href="#innoDB的IO配置" class="headerlink" title="innoDB的IO配置"></a>innoDB的IO配置</h2><p><img src="/images/mysql/innoDB%E7%9A%84%E7%BC%93%E5%AD%98%E5%92%8C%E6%96%87%E4%BB%B6.png" alt="innoDB的缓存和文件"></p>
<h3 id="innoDB的事务日志"><a href="#innoDB的事务日志" class="headerlink" title="innoDB的事务日志"></a>innoDB的事务日志</h3><p>innoDB使用日志来减少提交事务时的开销，因为日志中已经记录了事务，就无须在每个事务提交时 把缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置。而innoDB用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使变更没有写到数据文件。</p>
<p>innoDB最终还是把变更写到数据文件。innoDB使用一个后台线程智能地刷新这些变更到数据文件，这个线程可以批量组合写入。整体的日志文件受innodb_log_file_size和innoDB_log_fules_in_group两个参数影响。</p>
<p>innoDB变更任何数据时，会写一条记录变更记录到内存日志缓冲区，在缓冲区满的时候、事务提交的时候，或者一秒钟，innoDB都会刷写缓冲区的内容到磁盘日志文件。如果有大事务，增减日志缓冲区（innodb_log_buffer_size）来控制日志缓冲区的大小。</p>
<p>innodb_flush_log_at_trx_commit参数的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 把日志缓冲写到日志文件，每秒钟刷新一次，但是事务提交时不做任何事；</span><br><span class="line"></span><br><span class="line">1 日志缓冲写到日志文件，并且每次事务提交都刷新持久化存储。这个是默认的设置，该设置能保证不会丢失任何已经提交的事务，除非磁盘或者操作系统是伪刷新</span><br><span class="line"></span><br><span class="line">2 每次提交时把日志缓冲写到日志文件，但是并不刷新。但是并不刷新，innodb每秒钟做一次刷新，0与2最重要的不同是，如果mysql进程挂了，2的事务不会丢失。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>把日志缓冲写到日志文件和把日志刷新到持久化存储之间的不同是很重要的，在大部分操作系统中，把缓冲写到日志只是简单地把数据从innodb的内存缓冲转移到了操作系统的缓存，也是在内存里，并没有真的把数据写入到持久化存储。</li>
</ul>
<h3 id="innodb表空间"><a href="#innodb表空间" class="headerlink" title="innodb表空间"></a>innodb表空间</h3><p>innodb把数据保存表空间内，本质上是一个由多个磁盘文件组成的虚拟文件系统。innodb用表空间实现很多功能，并不只是存储表和索引。它还保存了回滚日志、插入缓冲、双写缓冲。</p>
<p>通过使用innodb_data_file_path配置项可以定制表空间文件，这些文件都放在innodb_data_home_dir指定的目录下。</p>
<p><img src="/images/mysql/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E9%85%8D%E7%BD%AE.png" alt="表空间的配置"></p>
<p>回收空间的唯一方式：导出一份数据，关闭mysql，删除所有文件，修改配置，重启，让innodb创建新的数据文件，然后倒入数据。</p>
<h1 id="配置mysql并发"><a href="#配置mysql并发" class="headerlink" title="配置mysql并发"></a>配置mysql并发</h1><p>使用innodb_thread_concurrency变量来控制并发量，它会限制一次性可以有多少线程进入内核，0表示不限制。一般设置 并发值 = cpu数量<em>磁盘数量</em>2</p>
<p>服务器不能在内存临时表中存储blob值，如果一个查询涉及blob值，又需要使用临时表，不管它多小，它都会在磁盘上创建临时表，这样效率很低。临时表可能是查询中最大的开销。可以使用substring（）函数将值转化为varchar</p>
<p>max_connections 默认是100，一般可以设置为300或者500也是可以的。</p>
<p>expire_logs_days 如果启用了二进制日志，应该打开这个选项，可以让服务器在指定的天数之后清理旧的二进制日志。建议设置为7-14天。</p>
<p>max_allowed_packet 控制多大的包可以被接收，默认值可能太大了，如果设置的太小复制可能出问题。通常设置为16MB或者更大。</p>
<p>read_only 这个选项禁止没有特权的用户在备库做变更，只接收从主库传输过来的变更。强烈建议把备库设置为只读模式。</p>
<p>skip_slave_start 阻止mysql视图自动启动复制，因为在不安全的崩溃或其他问题后，启动复制是不安全的，禁用自动启动。</p>
<h1 id="innodb的最重要的两个选项"><a href="#innodb的最重要的两个选项" class="headerlink" title="innodb的最重要的两个选项"></a>innodb的最重要的两个选项</h1><p>innodb_buffer_pool_size 和innodb_log_file_size</p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>高可用是相对的，100%的高可用是不可能的。高可用性越高，所付出的成本越高。</p>
<h2 id="导致宕机的主要原因"><a href="#导致宕机的主要原因" class="headerlink" title="导致宕机的主要原因"></a>导致宕机的主要原因</h2><p>1.运行环境，包括操作系统、硬盘以及网络。在运行环境的问题中，最普遍的是磁盘空间耗尽；<br>2.性能。最主要的是很糟糕的sql。糟糕的schema以及索引设计。<br>3.数据丢失及损坏；主备数据不一致导致。数据丢失主要是drop table的误操作导致；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-12-14/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-12-14/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">高性能mysql-mysql高级特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 01:28:35" itemprop="dateCreated datePublished" datetime="2018-12-14T01:28:35+08:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>分区表的主要目的是将数据按照一个较粗的粒度分在不同的表中。这样做可以将相关的数据放在一起，另外如果想一次批量删除整个分区的数据也变得很方便。</p>
<ul>
<li>分区的好处</li>
</ul>
<p>1.表非常大以至于无法全部都放在内存中，或者表的最后部分有热点数据，其他均是历史数据<br>2.分区表的数据更容易维护，例如想批量删除大量数据可以使用清除整个分区的方式；<br>3.分区表的数据可以分布在不同的物理设备上，高效地利用多个硬件设备；<br>4.可以使用分区表来避免某些特殊的瓶颈；<br>5.备份和恢复独立的分区，非常大的数据集的场景下效果非常好；</p>
<ul>
<li>分区的限制</li>
</ul>
<p>1.一个表最多有1024个分区；<br>2.如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；<br>3.分区表中无法使用外键约束；</p>
<h2 id="分区表的原理"><a href="#分区表的原理" class="headerlink" title="分区表的原理"></a>分区表的原理</h2><p>分区表由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也是可以直接访问各个分区，</p>
<p>存储引擎管理分区的各个底层表和管理普通表一样，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。</p>
<h3 id="分区表上的操作按照喜爱按的操作逻辑进行"><a href="#分区表上的操作按照喜爱按的操作逻辑进行" class="headerlink" title="分区表上的操作按照喜爱按的操作逻辑进行"></a>分区表上的操作按照喜爱按的操作逻辑进行</h3><ul>
<li>select update delete insert</li>
</ul>
<p>操作一个分区表的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区处理这条数据，再执行操作。</p>
<h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><ul>
<li>范围分区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;test1&#96; (</span><br><span class="line">  &#96;id&#96; char(32) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#39;自增主键(guid)&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;partition_key&#96; int(8) NOT NULL COMMENT &#39;分区键(格式:yyyyMMdd)&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;,&#96;partition_key&#96;),</span><br><span class="line">  UNIQUE KEY &#96;id_UNIQUE&#96; (&#96;id&#96;,&#96;partition_key&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_unicode_ci</span><br><span class="line">PARTITION BY RANGE (partition_key)</span><br><span class="line">(PARTITION p0 VALUES LESS THAN (20180619) ENGINE &#x3D; InnoDB,</span><br><span class="line"> PARTITION p20180619 VALUES LESS THAN (20180620) ENGINE &#x3D; InnoDB,</span><br><span class="line"> PARTITION p20180621 VALUES LESS THAN (20180622) ENGINE &#x3D; InnoDB,</span><br><span class="line"> PARTITION p20180622 VALUES LESS THAN (20180623) ENGINE &#x3D; InnoDB,</span><br><span class="line"> PARTITION p20180623 VALUES LESS THAN (20180624) ENGINE &#x3D; InnoDB);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>列表分区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">PARTITION BY LIST(store_id)</span><br><span class="line">    PARTITION pNorth VALUES IN (3,5,6,9,17),</span><br><span class="line">    PARTITION pEast VALUES IN (1,2,10,11,19,20),</span><br><span class="line">    PARTITION pWest VALUES IN (4,12,13,14,18),</span><br><span class="line">    PARTITION pCentral VALUES IN (7,8,15,16)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mysql还支持键值分区、hash分区。但是并不常用。partition分区子句中可以使用各种函数，但是返回的值必须是一个整数。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图本身是一个虚拟表，不存放任何数据，在使用sql语句访问视图的时候，它返回的数据是从其他表中生成的。视图和表是在同一个命名空间，mysql在很多地方把这两个是同样对待，但是视图不能创建触发器，不能使用drop table命令删除视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW t_user_view AS SELECT * FROM t_user WHERE delete_flag &#x3D; 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现视图的最简单方法是将select语句的结果存放到临时表中，当需要访问视图的时候，直接访问这个临时表就可以了。</p>
<h2 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h2><p>1.提高代码的重用性，直接将查询的数据放到视图中，查询数据的时候简单查询视图就可以；<br>2.提高了安全性能。可以对不同的用户创建不同的视图；</p>
<h1 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h1><p>innoDB是目前mysql中唯一支持外键的内置存储引擎。使用外键是有成本的，外键通常要求每次修改数据时都要在另外一张表中多执行一次查找操作。<br>外键约束的主要目的是控制存储在外键表中的数据，但它还可以控制对主键表中数据的修改。但是实际中通常在业务上保证数据的完整性，而不是使用外键。</p>
<h1 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h1><p>SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mark-chan/p/5384139.html">mysql的存储过程</a></p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>mysql查询缓存保存查询返回的完整结果。当查询命中该缓存，mysql会立刻返回结果，跳过了解析、优化和执行阶段。</p>
<p>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有缓存数据都会失效。这种机制效率低但是实现代价较低，这对于一个非常繁忙的系统来说非常重要。</p>
<h2 id="判断缓存命中"><a href="#判断缓存命中" class="headerlink" title="判断缓存命中"></a>判断缓存命中</h2><p>mysql判断缓存命中的方法很简单，缓存存放在一个引用表中，通过hash值引用。这个hash值包含如下因素：查询本身、当前要查询的数据库、客户端协议的版本等。</p>
<p>如果查询中包含一个不确定的函数，其实是不会存进缓存的，那么在查询缓存中是不可能找到缓存结果的。</p>
<ul>
<li>打开查询缓存会对读写性能带来额外的消耗</li>
</ul>
<p>1.读查询在开始之前必须检查是否命中缓存；<br>2.如果这个读查询可以被缓存，那么执行完之后，mysql如果返现查询缓存中没有这个查询，会将结果存入查询缓存，这会带来额外的系统消耗；<br>3.对写操作也会有影响，因为当对某个表写入数据的时候，mysql必须将对应表的所有缓存都置为失效，如果查询缓存非常大或者碎片非常多，这个操作就会带来很大的系统消耗。</p>
<p>综上，查询缓存会带来系统性能提升，但是如果这些额外消耗不断增加，再加上对查询缓存操作时一个加锁排他操作，消耗是不可忽视的。</p>
<h2 id="查询缓存如何使用内存"><a href="#查询缓存如何使用内存" class="headerlink" title="查询缓存如何使用内存"></a>查询缓存如何使用内存</h2><p>查询缓存是完全存储在内存中的，所以在配置和使用它之前，我们需要先了解它是如何使用内存的。除了查询结果之外，需要缓存的还有狠毒别的维护相关的数据。</p>
<p>基本的管理维护数据结构需要40KB的内存资源，除此之外，mysql用于查询的缓存的内存被分成一个个的数据块，数据块是变长。每一个数据块中，存储了自己的类型、大小和存储的数据本身，还外加一个指向前后数据块的指针。数据块的类型有：存储查询结果、存储查询和数据表的映射、存储查询文本等。</p>
<p>当服务器启动的时候，先初始化查询缓存需要的内存。这些内存池初始是一个完整的空闲块，这个空闲块的大小就是你配置的查询缓存大小再减去维护元数据的数据结构所消耗的空间。</p>
<h2 id="配置和维护查询缓存"><a href="#配置和维护查询缓存" class="headerlink" title="配置和维护查询缓存"></a>配置和维护查询缓存</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>query_cache_type 是否打开查询缓存。OFF、ON或demand。demand表示只有在查询语句中明确写明sql_cache的语句才可以放入查询缓存。</p>
</li>
<li><p>query_cache_size 查询缓存使用的总内存空间，单位是字节。这个值必须是1024的整数倍。</p>
</li>
<li><p>query_cache_min_res_unit 在查询缓存中分配内存时的最小单位。</p>
</li>
<li><p>query_cache_limit mysql可以缓存的最大查询结果。</p>
</li>
<li><p>query_cache_wlock_invalidate 如果某个数据表被其它的连接锁住，是否仍然从查询缓存中返回结果。默认是OFF</p>
</li>
</ul>
<h3 id="减少碎片"><a href="#减少碎片" class="headerlink" title="减少碎片"></a>减少碎片</h3><p>query_cache_min_res_unit合适的值可以帮助减少内存碎片导致的内存空间浪费。</p>
<p>可以使用flush query cache 完成碎片整理。这个命令会将所有的查询缓存重新排序，并将所有的空闲空间都聚集到查询缓存的一块区域上，这个命令并不会将查询缓存清空。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/mysql/%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E8%A7%86%E5%9B%BE.png" alt="分区表和视图"></p>
<p><img src="/images/mysql/%E5%A4%96%E9%94%AE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BA%8B%E5%8A%A1.png" alt="外键存储过程事务"></p>
<p><img src="/images/mysql/%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png" alt="查询缓存"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-12-06/%E9%AB%98%E6%80%A7%E8%83%BDmyqsl-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-12-06/%E9%AB%98%E6%80%A7%E8%83%BDmyqsl-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">高性能myqsl-查询性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 01:05:35" itemprop="dateCreated datePublished" datetime="2018-12-06T01:05:35+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果查询很糟糕，即使表结构和索引再合适也无法实现高性能。</p>
<p>查询的大致生命周期可以按照顺序来看：从客户端，到服务端，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中执行可以认为是整个生命周期中最重要的阶段</p>
<h1 id="慢查询的基础：优化数据访问"><a href="#慢查询的基础：优化数据访问" class="headerlink" title="慢查询的基础：优化数据访问"></a>慢查询的基础：优化数据访问</h1><p>查询性能低下的最基本的原因是访问的数据太多，以下两个步骤来分析总是很有效。</p>
<p>1.确认应用程序是否在检索大量超时需要的数据，这通常是访问了太多的行。<br>2.确认mysql服务器是否在分析大量超时需求的数据行；</p>
<h2 id="是否向DB请求了不需要的数据"><a href="#是否向DB请求了不需要的数据" class="headerlink" title="是否向DB请求了不需要的数据"></a>是否向DB请求了不需要的数据</h2><p>查询超过实际需要的数据，增加服务器的负担，增加网络、cpu、内存资源的开销；</p>
<ul>
<li><strong>查询不需要的记录</strong>，比如前段页面需要10条数据，查询的时候未使用limit；</li>
<li><strong>多表关联时返回全部列</strong>， 比如select a.*,b.*，返回多个表的所有数据。是不被推荐使用的，应该只返回需要的数据；</li>
<li><strong>总是去除全部列</strong>，比如select *，这种一般是不需要的；不过这种可以提高代码的复用性，但是这种做法是有代价的。</li>
<li><strong>多次查询相同的数据</strong>，这种一般可以进行缓存到redis中，防止多次请求DB而给DB带来的压力；</li>
</ul>
<h2 id="mysql是否在扫描额外的记录"><a href="#mysql是否在扫描额外的记录" class="headerlink" title="mysql是否在扫描额外的记录"></a>mysql是否在扫描额外的记录</h2><p>衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数，这些指标会被记录到慢sql中，检查慢sql是找出扫描过多行的办法。</p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间分为服务时间和队列时间。服务时间是数据库处理这个查询的真正时间，排队时间是服务器因为等在某些资源而等到的时间（可能是等待IO完成的时间。等待行锁的时间）。</p>
<h3 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h3><p>分析查询扫描的行数是非常有帮助的，一定程度上可以看看这个查询的效率是不是高。</p>
<h3 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h3><p>explain语句中的type列返回了访问类型，由慢到块依次是全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用。扫描的范围也是由小到大。</p>
<p>如果没有找到一个合适的访问类型，通常的办法是增加一个合适的索引。</p>
<p>一般mysql能够使用如下三种方式应用where条件，从好到坏依次是：</p>
<ul>
<li>在索引中使用where条件来过滤不匹配的记录，这是在存储引擎层来完成的；</li>
<li>使用覆盖索引扫描（在extra列中出现了using index）来返回记录，直接从索引中过滤不需要的记录返回命中的记录，则是在mysql服务层来完成的，无需回表查询；</li>
<li>从数据表中返回数据，然后过滤不需要的条件记录（在extra列中出现using where）。在mysql的服务层完成，从mysql数局表读出记录然后过滤。</li>
</ul>
<h4 id="如果查询需要扫描大量的数据只是返回少数的行，则可以使用一下方法优化"><a href="#如果查询需要扫描大量的数据只是返回少数的行，则可以使用一下方法优化" class="headerlink" title="如果查询需要扫描大量的数据只是返回少数的行，则可以使用一下方法优化"></a>如果查询需要扫描大量的数据只是返回少数的行，则可以使用一下方法优化</h4><ul>
<li>使用覆盖索引，把所有需要的列放到索引中，这样索引无须回表就能返回结果了；</li>
<li>改变表结构，例如使用单独的汇总表；</li>
<li>重写复杂的查询，让mysql优化器能够以更优化的方式执行这个查询；</li>
</ul>
<h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><p>可以优化一个sql得到和原来一样的结果去完成需求，也是可以重写sql得到一个不一样的结果去完成需求；</p>
<h2 id="一个复杂的查询还是多个简单查询"><a href="#一个复杂的查询还是多个简单查询" class="headerlink" title="一个复杂的查询还是多个简单查询"></a>一个复杂的查询还是多个简单查询</h2><p>如果一个查询可以完成就不要写成多个简单的查询；</p>
<h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对于一个大查询需要分而治之。将大查询分成小查询，每个查询功能完全一样，只完成一小部分的查询。</p>
<p>比如删除1000万条数据，可以每次删除1万条来处理。</p>
<h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>弄清楚mysql是如何优化和执行查询是更高的性能查询的基础。</p>
<p><img src="/images/mysql/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84.png" alt="mysql的执行路径"></p>
<ul>
<li>客户端发送一条查询给服务器；</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果，否则进入下一个阶段；</li>
<li>服务器进行sql解析、预处理、再由优化器生成对应的执行计划；</li>
<li>优化器生成的额执行计划，调用存储引擎的api来执行查询；</li>
<li>结果返回给客户端；</li>
</ul>
<h2 id="mysql客户端-服务端的通信协议"><a href="#mysql客户端-服务端的通信协议" class="headerlink" title="mysql客户端/服务端的通信协议"></a>mysql客户端/服务端的通信协议</h2><p>mysql客户端和服务端之前的通信协议是“半双工”的，这也意味着任何一个时刻，要么有服务器向客户端发送数据，要么由客户端向服务器发送数据，不能同时发生。</p>
<p>一旦客户端发送了请求，他只能等待结果了。当服务器开始响应客户端请求时，客户端必须完整的接收整个返回结果，而不是简单地只取前面几条结果而让服务器停止发送数据。客户端从服务端获取数据时，实际上是服务端向客户端推送数据的过程。</p>
<p>连接mysql的库函数通常可以获得全部结果缓存到内存中，他还可以逐行获取数据，一般都是前者。因为这样可以减小服务器的压力，让查询早点结果，早点释放资源。</p>
<p>多数情况下，从mysql的库函数中获取mysql的数据。如果结果太大不好，因为需要太大的内存消耗。</p>
<h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>对于一个mysql连接，或者说一个线程，任何时候都有一个状态，show full processlist (该命令返回结果的command列就是当前的准头盖)</p>
<ul>
<li>sleep 线程正在等待客户端发送新的请求；</li>
<li>query 线程正在执行查询或者正在将结果发送给客户端；</li>
<li>locked 在mysql服务器层，该线程正在等待表锁。在存储引擎级别的实现的锁，例如innoDB的行锁，并不会出现在线程状态中。</li>
<li>analyzing and statistics ，线程正在收集存储引擎的统计信息，并生成查询的执行计划；</li>
<li>copying to tmp table [on disk]:线程正在执行查询，并将结果复制到一个临时表中，这种状态要么是group by操作，要么是union操作。如果状态后面有on disk操作，则代表正在将一个内存临时表放到磁盘上。</li>
<li>sorting result 线程正在对结果集进行排序；</li>
<li>sending data 表示多种情况，线程可能在多个撞他间传送数据，或者生成结果集，或者正在给客户端返回数据；</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>解析一个查询语句之前先看查询缓存是否打开，打开的话优先查询是否明总缓存（通过一个大小写敏感的hash查找的）；</p>
<p>如果查询恰好命中了查询缓存，那么返回结果之前要检查一次用户权限。如果权限没有问题，则跳过其它阶段，返回数据。</p>
<h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>解析sql、预处理、优化sql执行计划是将一个sql转换成一个执行计划的三个步骤；</p>
<h3 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h3><p>解析器将sql生成“解析树”。检查mysql语法规则和解析查询。比如：是否使用错误的关键字、关键字的顺序是否争取，验证引号是否前后匹配，别名是否存在，数据列是否存在等；下一步是鉴权</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>优化器将语法树转化成执行计划。mysql使用基于成本的优化器，它尝试预测一个查询使用某种执行计划的成本，选择成本最小的一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_user ;</span><br><span class="line">SHOW STATUS LIKE &#39;last_query_cost&#39;;</span><br><span class="line"></span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 1672.799000 |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表示优化器认为大概需要做1673个数据页的随机访问才可以完成上面的查询，这是根据一系列统计信息计算得来的：每个表或者索引页面的个数、索引的基数、索引和数据行的长度、索引分布情况。这个时间的估算不考虑缓存</p>
<p><strong>mysql优化器选择错误的执行计划</strong></p>
<p>1.统计信息不准确；<br>2.执行计划中的成本估算不等同于实际执行的成本；<br>3.mysql的最优可能和你想象的不一样，我们只是认为是执行时间最短的，mysql不这么认为；<br>4.mysql不考虑其它并发执行的查询；<br>5.mysql并意识任何时候都是基于成本的优化；<br>6.mysql不会考虑不受其控制的成本；</p>
<h3 id="mysql能够处理的优化类型"><a href="#mysql能够处理的优化类型" class="headerlink" title="mysql能够处理的优化类型"></a>mysql能够处理的优化类型</h3><ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化为内连接，比如where条件、库表结构让外连接等价于一个内连接；</li>
<li>使用等价变换规则，将复杂的表达式转化为简单的，移除一些恒等式；</li>
<li>优化count()、min()、max(),例如min是b-tree索引的最左端记录，max是索引的最后一条记录。count（*）可以使用存储引擎提供的一些优化。</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描，当索引中的列包含所有查询中需要使用的列的时候，mysql就回使用索引返回需要的数据，而无需查询对应的数据列；</li>
<li>子查询优化，将子查询转化为一种效率更高的形式，减少多个查询多次对数据的访问；</li>
<li>提前终止查询。limit子句，发现已经满足需求的时候，立刻终止查询；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain SELECT * FROM t_user WHERE id &#x3D;-1 ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | no matching row in const table |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Extra字段中的值表示查询在优化阶段就提前终止查询；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>等值传播，如果两个列的值通过等式关联，那么mysql能够把其中一列的where条件传递到另一列上。</li>
<li>列表in的比较。mysql中的in和or列表的子句是同步的，前者会先排序然后二分查找（o（logn)）），后者是O(n)</li>
</ul>
<h3 id="mysql如何执行关联查询"><a href="#mysql如何执行关联查询" class="headerlink" title="mysql如何执行关联查询"></a>mysql如何执行关联查询</h3><p>在mysql中每一次查询都是关联，在union语句中，现将一些列的单个查询放到一个临时表中，然后重新读出临时表数据来完成union查询，每一次查询都是一次关联，所以读取临时表的结果也是一次关联。</p>
<p>mysql执行关联的策略是mysql对任何关联都执行嵌套关联操作。mysql先在表中循环读取单条数据，然后嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到表中匹配的行为止。</p>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>mysql不会生成查询字节码来执行查询，而是生成查询的一颗指令树，然后通过存储引擎执行完成这颗指令树并返回结果。</p>
<h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p>多表关联的时候，筒仓有多重关联顺序来完成相同的执行结果，关联查询评估不同的顺序成本来选择一个代价小的关联查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN</span><br><span class="line">SELECT</span><br><span class="line">    b.group_id </span><br><span class="line">FROM</span><br><span class="line">    t_user a</span><br><span class="line">    LEFT JOIN t_group_user_rel b ON a.id &#x3D; b.user_id</span><br><span class="line">    LEFT JOIN t_group c ON b.group_id &#x3D; c.id </span><br><span class="line">WHERE</span><br><span class="line">    a.id &#x3D; 1;</span><br><span class="line">+----+-------------+-------+------------+--------+------------------------------+------------------------------+---------+---------------------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys                | key                          | key_len | ref                 | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+--------+------------------------------+------------------------------+---------+---------------------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | a     | NULL       | const  | PRIMARY                      | PRIMARY                      | 4       | const               |    1 |   100.00 | Using index              |</span><br><span class="line">|  1 | SIMPLE      | b     | NULL       | ref    | index_group_user_rel_user_id | index_group_user_rel_user_id | 4       | const               |   17 |   100.00 | NULL                     |</span><br><span class="line">|  1 | SIMPLE      | c     | NULL       | eq_ref | PRIMARY                      | PRIMARY                      | 4       | sso_test.b.group_id |    1 |   100.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+------------------------------+------------------------------+---------+---------------------+------+----------+--------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关联查询，由于是嵌套查询的，所以优化器会将小表放到前面；</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>如果数据量小，则会在内存中排序，如果数据量大则需要使用磁盘。进行文件排序会使用临时存储空间，可能比想象的要大。</p>
<p><img src="/images/mysql/%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%8E%92%E5%BA%8F.png" alt="关联查询的排序"></p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在解析优化节阶段，mysql将生成查询对应的执行计划，mysql查询执行引擎则根据这个执行计划来完成整个查询。</p>
<p>在根据执行计划逐步执行的过程中，大量的操作需要调用存储引擎实现的接口来完成。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>即使查询不需要返回结果给客户端，mysql仍然会返回这个查询的一些信息比如影响查询的行数。如果查询结果可以被缓存，则mysql在这个阶段的结果也会放到查询缓存中。</p>
<p>mysql将结果集返回客户端是一个增量，逐步返回的过程。当查询结果生成第一条结果时，mysql就可以开始想客户端逐步返回了。这样做服务端无需缓存太多的结果，客户端可以第一时间获取返回的结果。结果中的每一行都会以一个满足 客户端和服务器通信协议的封包发送。</p>
<h1 id="mysql查询优化器的局限性"><a href="#mysql查询优化器的局限性" class="headerlink" title="mysql查询优化器的局限性"></a>mysql查询优化器的局限性</h1><p>mysql的万能嵌套循环是对大部分的查询都适用的。</p>
<h2 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h2><p>最糟糕的子查询是where条件中包含In（）的子查询语句。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from film where film_id in (select film_id from film_actor where actor_id &#x3D; 1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mysql对in列表中的选项有专门的额优化策略，我们以为in的子查询会被执行为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(film_id) from film_actor where actor_id &#x3D;1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实不是这样的，它会被优化为(mysql 5.6的版本，5.7的版本可以不是如此)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from film where exists (select * from film_actor where actor_id &#x3D;1 and film_actor.film_id &#x3D;film.film_id)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候需要根据film_id来关联外部表的film，因为需要film_id字段，所以mysql认为无法先查询这个子查询，通过explain我们可以看到子查询是 一个相关子查询（dependent subquery）。（可以使用explain extend查看整个查询被改写成什么样子）</p>
<p>可以优化为 group_concat()逗号分隔查询，也可以改成关联查询。</p>
<h2 id="union的限制"><a href="#union的限制" class="headerlink" title="union的限制"></a>union的限制</h2><p>从两个子句中order by之后limit出来200条，然后对总的order by 和limit。但是这个并不一定准确。</p>
<h1 id="查询优化器提示（hint）"><a href="#查询优化器提示（hint）" class="headerlink" title="查询优化器提示（hint）"></a>查询优化器提示（hint）</h1><p>如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划。</p>
<p>但是这个是对优化器不友好的，收效甚微，不建议使用。</p>
<h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><h2 id="优化count（）查询"><a href="#优化count（）查询" class="headerlink" title="优化count（）查询"></a>优化count（）查询</h2><ul>
<li><p>count()的作用，可以统计某个列值的数量，也可以统计行数，在统计列值时要求列值是非空的。如果括号中执行了列或者列的表达式，则统计的就是这个表达式有值的结果数。count（*）是在统计行数。</p>
</li>
<li><p>MylSAM的count（）函数在没有where条件的时候直接利用存储引擎的特性获得这个值。当有where条件的时候，就和别的引擎没有区别了</p>
</li>
<li><p>简单优化，反向取值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    ( SELECT count( * ) FROM world.city ) - count( * ) </span><br><span class="line">FROM</span><br><span class="line">    world.city </span><br><span class="line">WHERE</span><br><span class="line">    id &lt;&#x3D; 5;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用近似值</li>
</ul>
<p>计算精确值的成本非常高，计算近似值则非常简单。有的情况可以使用explain出来的优化器估算值的行数就是一个不错的近似值。</p>
<h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>尽可能的使用关联查询代替子查询，但不是绝对的。</p>
<h2 id="优化limit分页"><a href="#优化limit分页" class="headerlink" title="优化limit分页"></a>优化limit分页</h2><ul>
<li>limit 10000，20这种的查询的代价非常高，尽量的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联擦再做返回需要的列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select film_id,description from film order by title limit 10000,20;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select film.film_id,film.description from film a inner join (select film_id from film b order by title limit 10000,20) on a.film_id &#x3D;b.film_id; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种延迟关联，大大提升效率。他让mysql尽可能扫描少的页面。</p>
<ul>
<li>找到上一页的临界值，做筛选。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from film where film_id &lt;16030 order by film_id limit 20;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优化union查询"><a href="#优化union查询" class="headerlink" title="优化union查询"></a>优化union查询</h2><ul>
<li><p>mysql总是使用创建填充临时表的方式执行union查询。因此很多优化策略在union查询中没法很好的使用。因此将limit、where等子句放到各个子查询中。</p>
</li>
<li><p>除非确实需要服务器消除重复的行，否则一定要使用union all。如果没有all关键字，mysql会在临时表上添加distinct关键字，这会使表做唯一性检查，待见非常高。</p>
</li>
</ul>
<h2 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @one: &#x3D; (select min(actor_id) from actor);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用自定义变量无法使用查询缓存；</li>
<li>自定义变量在一个连接中有效；</li>
<li>赋值符号‘:=’的优先级非常低，所以需要注意，赋值表达式应该使用明确的括号；</li>
</ul>
<h3 id="优化排名语句"><a href="#优化排名语句" class="headerlink" title="优化排名语句"></a>优化排名语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @rownum &#x3D; 0;</span><br><span class="line">select actor_id,@rownum:&#x3D;@rownum+1 as rownum from actor limit 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查询刚刚插入的数据"><a href="#查询刚刚插入的数据" class="headerlink" title="查询刚刚插入的数据"></a>查询刚刚插入的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update t1 set lastUpdated &#x3D;NOW() where id &#x3D;1;</span><br><span class="line">select lastUpdated from t1 where id &#x3D;1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用变量可以如下实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update t1 set lastUpdated &#x3D; NOW() where id &#x3D;1 and @now:&#x3D;NOW();</span><br><span class="line">select @now;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个语句和服务端只有一次交互，所以快很多；</p>
<h3 id="统计更新和插入的数量"><a href="#统计更新和插入的数量" class="headerlink" title="统计更新和插入的数量"></a>统计更新和插入的数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t1(c1,c2) values (4,4),(2,1),(3,1) on duplicate key update c1 &#x3D; values(c1) +(0*( @x:&#x3D;@x+1));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>冲突时对c1 加一；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-11-28/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-11-28/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">高性能mysql-创建高性能的索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 09:38:14" itemprop="dateCreated datePublished" datetime="2018-11-28T09:38:14+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>索引是存储引擎用于快速找到记录的一种数据结构。</p>
<p>数据量越大，索引对性能的影响越重要；不恰当的索引对性能的影响不明显，数据量增大时性能急剧下降；</p>
<h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>存储引擎首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。</p>
<p>创建一个包含两个列的索引和创建两个只包含一列的索引是大不相同的。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>mysql中，索引是在存储引擎层，而不是在服务器层的。索引没有统一的标准。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>大部分mysql引擎都支持这种索引，它使用的是B-Tree数据结构来存储数据。但是NDB集群存储引擎实际采用T-Tree结构存储这种索引，InnoDB则使用B+Tree。</p>
<p>存储引擎以不同的方式使用B-Tree索引，性能也是各不相同的，例如MylSAM使用前缀压缩技术使得索引更小，但是innoDB则按照原数据格式进行存储，MylSAM索引通过数据的物理位置引用被索引的行，而innoDB则根据主键来引用被索引的行。</p>
<p><img src="/images/mysql/B-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.png" alt="B-Tree索引的抽象表示"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xu_flash/article/details/62216969">bTree索引</a></p>
<ul>
<li>简单表述实现</li>
</ul>
<p>B-Tree索引可以加快访问速度。因为不需要全表扫描，而是从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下查找，通过比较节点页的值和要查找的值可以找到合适指针进入下层子节点，这些指针实际上定义了子节点页中值的上线和下限。</p>
<p>最终存储引擎要么找到对应的额值，要么记录不存在。</p>
<h4 id="索引对如下类型查询有效"><a href="#索引对如下类型查询有效" class="headerlink" title="索引对如下类型查询有效"></a>索引对如下类型查询有效</h4><ul>
<li><p>全值匹配</p>
</li>
<li><p>匹配最左前缀</p>
</li>
<li><p>匹配列前缀 </p>
</li>
<li><p>匹配范围值</p>
</li>
<li><p>精确匹配某一列并匹配范围外的另外一列</p>
</li>
<li><p>只访问索引的查询</p>
</li>
</ul>
<h4 id="B-tree索引的限制"><a href="#B-tree索引的限制" class="headerlink" title="B-tree索引的限制"></a>B-tree索引的限制</h4><ul>
<li><p>如果不是按照索引的最左列开始查找，则无法使用索引；</p>
</li>
<li><p>不能跳过索引中的列，如果不指定索引名字，在mysq只能使用索引的第一列；</p>
</li>
<li><p>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查询，如：where last_name=’AD’ and first_name like ‘J%’ and dob = ‘1976-12-23’,只能使用索引的前两列；</p>
</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash码。hash索引将所有的hash码存储在索引中，hash表中存储指向每个数据行的指针。</p>
<p>在mysql中，只有memory引擎显示支持hash索引，也是memory引擎的默认引擎。</p>
<p>memory引擎过是支持非唯一hash索引的，这在数据库中与众不同。如果多列的hash值相同，索引会以链表的方式存放多个记录指针在同一个hash条目中。</p>
<h4 id="hash索引的限制"><a href="#hash索引的限制" class="headerlink" title="hash索引的限制"></a>hash索引的限制</h4><ul>
<li><p>hash索引只包含hash值和行指针，而不存储字段，所以不能使用索引中的值来避免读取行；</p>
</li>
<li><p>hash索引数据并不是按照索引值顺序存储，所以也就无法用于排序；</p>
</li>
<li><p>hash索引也不支持部分索引列匹配查找，所以hash索引始终是使用索引列的全部内容来计算hash值的。</p>
</li>
<li><p>hash索引只是支持等值比较查询，不支持范围查询；</p>
</li>
<li><p>访问hash索引的顺序非常快，除非有很多hash冲突。当出现hash冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的才可以。</p>
</li>
<li><p>如果hash冲突很多的话，一些索引维护的代价也会很高；</p>
</li>
</ul>
<p>由于以上的限制，hash索引只是适合特定的场合，一旦适合hash索引，它带来的性能提升非常明显。</p>
<p>innodb引擎有一个特殊的功能叫做‘自适应hash索引’，当innoDB注意到某些索引使用的非常频繁时，它会在B-Tree索引的基础上再创建一个hash索引，这样就让B-Tree索引页具有hash索引的一些优点，比如快速的hash查找。</p>
<p><strong>自定义hash索引</strong>：如果存储一个url，可以存储一个url和hash码，查询时执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from url_table where url &#x3D; &quot;http:&#x2F;&#x2F;www.mysql.com&quot; and url_crc &#x3D; CRC32(&quot;http:&#x2F;&#x2F;www.mysql.com&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样性能会非常高，mysql优化性很高而体积很小的基于url_crc列的索引来查找。</p>
<p>缺陷是需要手动维护hash值，不过可以使用触发器实现；</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MylSAM 表支持空间索引，可以用作地理数据存储。mysql的gis支持不完善，所以大部分不适用这个特性。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是一种特殊类型的索引，它查找的是文中的关键词，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样。</p>
<h3 id="其它索引类别"><a href="#其它索引类别" class="headerlink" title="其它索引类别"></a>其它索引类别</h3><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><p>索引可以让服务器快速定位到表的指定位置，而且由于索引的数据结构不同，索引也有一些其它的附加作用。</p>
<h2 id="优点如下："><a href="#优点如下：" class="headerlink" title="优点如下："></a>优点如下：</h2><ul>
<li>索引大大减小了服务器需要扫描的数据量；</li>
<li>索引可以帮助服务器避免排序和临时表；</li>
<li>索引可以将随机IO变为顺序IO；</li>
</ul>
<h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>独立的列是指不能是表达式的一部分。</p>
<ul>
<li>下列的表达式不能使用actor_id列的索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select actor_id from actor_table where actor_id +1 &#x3D; 5;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>以下是另一个常见的错误,使用不到DATE_COL列的索引；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from TO_DAYS(CURRENT_DATE) - TO_DAYS(DATE_COL) &lt;&#x3D;10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h2><ul>
<li><p>索引比较长的字符串，模拟hash索引是一个策略。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。索引的选择性越高则查询效率越高。</p>
</li>
<li><p>索引的选择性是指不重复的索引值和数据表的记录总数的比值。</p>
</li>
<li><p>前缀索引的缺点：无法使用前缀索引做order by和 group by，也无法使用前缀索引做覆盖扫描。</p>
</li>
<li><p>对于blob和text的字符串类型的列，必须使用前缀索引，因为mysql不允许索引这些列的完整长度。</p>
</li>
</ul>
<p>1.前缀选择时需要做测试,可以一直增加前缀长度，至到前缀的选择性接近完整列的选择性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as cnt, LEFT(city,3) as pref from sakil.city_demo group by pref order by cnt desc limit 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.计算合适的前缀长度的另外一个办法是计算完整列的选择性，并使得前缀的选择性接近于完整列的选择性。通常接近于0.031就可以用了.最坏的情况，平均选择性如果是4或5的索引已经足够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct LEFT(city,3))&#x2F;count(*) from sakila.city_demo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>比较错误的多列索引使用方法：为每个列创建独立的索引，或者按照错误的顺序创建多列索引；</p>
<p>MySQL会对索引做优化，将多个单列的索引做优化合并，但更多时候说明了表上的索引建的很糟糕。</p>
<ul>
<li><p>当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含多个相关列的多列索引，而不是多个独立的单列索引；</p>
</li>
<li><p>当服务器需要多个索引做联合操作时（通常有多个OR条件），通常消耗大量的CPU和内存资源在算法的缓存、排序和合并操作上，</p>
</li>
</ul>
<h2 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h2><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑满足排序和分组的需要。</p>
<p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序。其次是第二列。</p>
<p>在不考虑排序和分组时，将选择性最高的列放到索引的最前列是很好的。这时候索引的作用只是优化where条件的查询。</p>
<h3 id="查询例子："><a href="#查询例子：" class="headerlink" title="查询例子："></a>查询例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select sum(staff_id &#x3D;2),sum(customer_id &#x3D; 584) from payment ;</span><br><span class="line"></span><br><span class="line">sum(staff_id):7922</span><br><span class="line"></span><br><span class="line">sum(customer_id):30</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据前面的经验，customer_id应该放到前面，因为对应条件值的customer_id数量更小。</p>
<p>或者判断选择性更高的 customer_id，所以选择customer_id在最前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct staff_id)&#x2F;count(*) as staff_id_selectvity,count(distinct customer_id)&#x2F;count(*) as customer_id_selectvity, count(*) from payment</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但innoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据实际上存放在索引的叶子页中。术语‘聚簇’表示数据行和相邻的键值紧凑的存储在一起。因为无法同事把数据航存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>因为存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。innoDB是支持聚簇索引的。</p>
<h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul>
<li><p>可以把相关数据保存在一起，例如实现电子邮箱时，可以根据用户id来聚集数据，这样可以从磁盘读取很少的数据也就能获取某个用户的全部邮件，如果没有使用聚簇索引，每封邮件都可能导致一次磁盘IO。</p>
</li>
<li><p>数据访问更快，聚簇索引将索引和数据保存在一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快；</p>
</li>
<li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值；</p>
</li>
</ul>
<h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul>
<li><p>极大提高了IO密集型的应用的性能，<strong>但是如果数据全部放在内存中</strong>，则访问顺序就没那么重要了，聚簇索引也就没有优势了；</p>
</li>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入到innoDB表中速度最快，如果不是按照主键顺序加载数据，则加载完后最好使用optimize table命令重新组织一下表；</p>
</li>
<li><p>更新聚簇索引的代价很高，因为会强制innoDB将每个更新的行移动到新的位置；</p>
</li>
<li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于分裂导致数据存储不连续的时候；</p>
</li>
<li><p>非聚簇索引可能比想象的要更大，因为在非聚簇索引的叶子节点包含了引用行的主键列；</p>
</li>
<li><p>二级索引访问需要两次索引查找，而不是一次，因为二级索引的叶子节点存储的的不是行指针，而是主键值；</p>
</li>
</ul>
<p><img src="/images/mysql/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="聚簇索引和非聚簇索引的对比图"></p>
<h2 id="在innoDB表中按主键顺序插入行或UUID最为主键"><a href="#在innoDB表中按主键顺序插入行或UUID最为主键" class="headerlink" title="在innoDB表中按主键顺序插入行或UUID最为主键"></a>在innoDB表中按主键顺序插入行或UUID最为主键</h2><p>使用自增主键（顺序的），避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于IO密集型的应用。从性能角度考虑，使用UUID作为聚簇索引则会很糟糕。它使得聚簇索引的插入变得随机。</p>
<p>使用自增主键，因为主键的值是顺序的，所以innoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录会被写入新的页中。</p>
<p>使用UUID作为聚簇索引插入新的行时，因为新行的主键值不一定比之前插入的大，所以innoDB无法简单地总是把新行插入到碎银的后面，而是需要为新的俄航寻找合适的位置，通常是使用已有数据的中间位置，并分配空间，这回增减很多额外的工作，导致数据部分不够优化；</p>
<ul>
<li>使用UUID作为聚簇索引的缺点</li>
</ul>
<p>1.写入的目标页可能已经刷到磁盘上并从缓存中溢出，或者是没有被加载到缓存中，innoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这<strong>导致大量的随机IO</strong>；<br>2.因为写入是乱序的，<strong>innoDB不得不频繁的做页分裂操作</strong>，以便为新的行分配空间。页分裂导致移动大量的数据，一次插入最少需要更改三个页而不是一个页；<br>3.由于频繁的页分裂，页会变得洗漱并被不规则的填充，最终<strong>数据会有碎片</strong>；</p>
<h2 id="顺序的主键什么时候回造成更坏的结果"><a href="#顺序的主键什么时候回造成更坏的结果" class="headerlink" title="顺序的主键什么时候回造成更坏的结果"></a>顺序的主键什么时候回造成更坏的结果</h2><p>对于高并发的的工作负载，在innoDB中按照主键插入会造成明显的争用。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果索引的叶子节点中已经包含要查询的数据，就不需要再回表查询。如果一个索引包含所有需要查询的字段的值，我们就称之为覆盖索引。</p>
<h3 id="覆盖索引的好处（不需要回表查询）"><a href="#覆盖索引的好处（不需要回表查询）" class="headerlink" title="覆盖索引的好处（不需要回表查询）"></a>覆盖索引的好处（不需要回表查询）</h3><ul>
<li><p>索引条目通常远小于数据行大小，所以如果只需要读取索引，那么mysql会极大的减少数据访问量。</p>
</li>
<li><p>因为索引是按照列值顺序存储的（至少单个页内是如此），所以IO密集型的查询范围查询会比随机从磁盘读取每一行数据的IO少得多。</p>
</li>
<li><p>一些存储引擎入MySAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，这回导致严重的性能问题。</p>
</li>
<li><p>由于innoDB的聚簇索引，覆盖索引对innoDB表特别有用，innoDB的二级索引在叶子节点保存了行的主键索引，如果二级主键能够覆盖查询，可以避免对主键索引的二次查询。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>不是所有的类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而hash索引、空间索引、全文索引都不存储索引列的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select store_id,film_id from sakila.inventory;</span><br></pre></td></tr></table></figure>
<p>如表inventory中有一个多列索引（store_id,film_id）。mysql 如果只是需要访问这两列，就可以使用这个索引做覆盖索引；</p>
<p><img src="/images/mysql/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="覆盖索引的使用"></p>
<p>在extra列显示 using index,而不是type列的index。</p>
<h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><p>mysql有两种方式可以生成有序的结果，通过排序操作；或者通过索引顺序扫描。如果mysql使用explain处理啊的type值为index，则说明mysql使用了索引扫描来做排序。</p>
<p>扫描本身很快，只需要从一条索引到下一条记录，但是如果索引不能覆盖查询的所有列，那就不得不每扫描一条索引记录就都回表查询一次。</p>
<ul>
<li><p>如果查询需要关联多张表，则只有order by 子句引用的字段全部为第一张表时，才可以使用索引做排序。</p>
</li>
<li><p>即使order by子句不满足索引的最左前缀的要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p>
</li>
</ul>
<p><img src="/images/mysql/orderBy%E7%9A%84%E8%A1%A8.png" alt="orderBy的表"></p>
<p><img src="/images/mysql/%E9%9D%9E%E6%9C%80%E5%B7%A6%E7%B4%A2%E5%BC%95-%E7%9A%84orderBy%E5%AD%90%E5%8F%A5.png" alt="非最左索引-的orderBy子句"></p>
<p><img src="/images/mysql/%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%81%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="不能使用索引做排序的例子"></p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>mysql是允许在相同的列上创建多个索引，无论是有意义的还是无意义的，mysql需要单独维护重复的索引。</p>
<p>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引，应该避免创建重复索引。</p>
<p>冗余索引和重复索引有一些不同，如果创建了索引（A，B）,在创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。如果创建索引（B,A）就不是冗余索引，索引（B）也不是。</p>
<h3 id="冗余索引的情况"><a href="#冗余索引的情况" class="headerlink" title="冗余索引的情况"></a>冗余索引的情况</h3><p>有人可能会增加一个新的索引（A,B）,而不是扩展已有的索引（A）。还有一种情况是扩展为（A,ID）,其中ID是主键，对于innoDB来说，主键列已经包含在二级索引中了，这也是冗余索引。</p>
<p><img src="/images/mysql/%E9%9C%80%E8%A6%81%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="需要冗余索引的情况"></p>
<p>有两个索引的缺点就是维护成本更高。插入数据需要的时间大大增加。</p>
<h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果你的查询从来不访问那些不需要的行，那么就可以锁定更少的行。锁定行仍然会带来额外的开销，而且锁定超过需要的行会增加锁争用并减少并发性；</p>
<p>innoDB只有在访问行的时候才会对其加锁，而索引能够见啥innoDB访问的行数，从而减少锁的数量，但这只有当innoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在innoDB检索到数据返回给服务器层时，mysql服务器才会应用where子句，这时候已经无法避免应用where子句。</p>
<h1 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h1><p><img src="/images/mysql/%E7%B4%A2%E5%BC%95%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0%E9%9C%80%E6%B1%82.png" alt="索引案例学习需求"></p>
<h2 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h2><p>哪些列在where子句中出现的最频繁，在有更多的不同值的列上创建索引的选择性会更好。</p>
<p>country列的选择性通常不高，但是很多查询用到，sex的选择性更低，但是很多查询中也会用到。建议将（sex，country）列作为前缀。</p>
<ul>
<li>正常情况下是把选择性更高的字段放前面。因为几乎所有的查询都会用到sex字段。也可以使用in（‘male’，‘female’）让mysql来进行选择。所以可以使用（sex，country）作为索引。</li>
</ul>
<p><strong>索引设计的基本原则</strong></p>
<p>当设计索引时，不要只为现有的查询考虑需要哪些索引，还要考虑对查询进行优化。如果发现某些查询需要创建新的索引时，但是这个索引优惠降低另外一些的查询效率，那么应该考虑优化原来的查询。</p>
<ul>
<li><p>考虑where条件组合，并了解哪些索引在没有合适的索引的情况下会很慢。</p>
</li>
<li><p>age一般是范围查询的，所以age可以放到最后。可以使用IN来代替范围查询。尽可能的将范围查询的列放到索引的后面，以便优化器可以使用更多的列。</p>
</li>
</ul>
<h2 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h2><p>范围条件 actor_id&gt;45, explain 的type是range类型；in（2，3，4）是列表条件，explain 的type也是range类型。</p>
<p>第一个是范围条件，第二个是多个等值条件查询。<strong>对于范围条件，mysql无法再使用范围列后面的其他索引列了，但是对于多个等值条件查询则没有这个限制。</strong></p>
<p><img src="/images/mysql/%E5%A4%9A%E4%B8%AA%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="多个范围条件的例子"></p>
<p>上述查询有2个范围条件，last_online列和age列。可以使用一个它们中的一个索引，但是无法同事使用。</p>
<h2 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h2><p>优化大量翻页的排序的一种方法是限制用户能够翻页的数量；另一种是使用延迟关联，可以使用覆盖索引去查询返回需要的主键，再根据主键关联原表获得需要的行。</p>
<h1 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h1><p>即使使用争取的类型创建了表并加上合适的索引，工作也没有结束，还需要维护表和索引来确保他们都正常工作。维护表主要有三个目的：找到并修复损坏的表，维护准确的索引统信息，减少碎片。</p>
<h2 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h2><p>索引损坏会发生一些奇怪的问题，可以使用check table命令来检查是否发生了表损坏，可以使用repair table命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令。可以使用数据备份然后重新导入，如果不是索引损坏了那么就没有用了。</p>
<p>如果数据损坏，最重要的是找出是什么导致了损坏，而不是简单的修复。</p>
<h2 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h2><p>mysql的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。</p>
<p>1.第一个是records_in_range(),通过向存储引擎传入两个边界值来获取这个范围大概有多少记录。这对于InnoDB来说会返回估算值，而MylSAM会返回精确值；<br>2.第二个是info（），该接口返回各种类型的数据，包括索引的基数（每个键值有多少记录）。</p>
<p>如果统计信息有误或者不准确，优化器可能会做出错误的决定，可以通过使用analyze table来重新生成统计信息来解决问题。</p>
<p>不同的存储引擎对统计信息的存储时不同的，memory引擎根本不存储索引统计信息；mylSAM将索引统计信息存储在磁盘，analyze table需要全索引扫面，且整个过程锁表；innoDB不在磁盘存储索引统计信息，而是通过随机访问进行评估并存储在内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM t_sys;</span><br><span class="line">+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| t_sys |          0 | PRIMARY        |            1 | id          | A         |          33 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| t_sys |          0 | unique_app_id  |            1 | app_id      | A         |          31 | NULL     | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| t_sys |          1 | index_sys_name |            1 | sys_name    | A         |          32 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Cardinality是索引列的基数，显示了存储引擎估算索引列有多少个不同的值。</p>
<h2 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h2><p>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。</p>
<p>表数据的碎片化分为三种：行碎片、行间碎片、剩余空间碎片；</p>
<ul>
<li><p>行碎片：这种碎片指的是数据行被存储在多个地方的多个片段中，及时查询只从索引中范文一行记录，行碎片也会导致性能下降；</p>
</li>
<li><p>行间碎片：行间碎片是指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。</p>
</li>
<li><p>剩余空间碎片：剩余空间碎片是指数据页中有大量的空余空间，这会导致服务器读取大量不需要的数据，从而造成浪费。</p>
</li>
</ul>
<p>对于MylSAM表，这三类碎片都会发生。但是innoDB不会出现短小的行碎片，innoDB会移动短小的行并重新写到一个片段中。</p>
<p><strong>处理办法</strong></p>
<p>可以通过执行 optimize table或者导出在导入的方式来整理数据，这对大多数存储引擎是有效的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.大部分情况下都会使用B-tree索引，其它的索引只适合特殊的目的。</p>
<p>2.在选择和编写利用这些索引的查询时，有如下三个原则需要记住：</p>
<p><img src="/images/mysql/%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99.png" alt="创建索引的三个原则"></p>
<p>编写查询语句时尽可能的选择合适的索引以避免单行查找、尽可能的使用数据原生顺序从而避免额外的排序操作、尽可能使用索引覆盖查询；</p>
<p>3.没有完美的索引时，需要创建大量的索引，（两个列，一个是正序，一个是倒叙，不能达到三星索引）。必须有所取舍选择合适的索引。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-11-19/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-11-19/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">高性能mysql-schema与数据类型优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-19 09:48:53" itemprop="dateCreated datePublished" datetime="2018-11-19T09:48:53+08:00">2018-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/" itemprop="url" rel="index"><span itemprop="name">高性能mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><ul>
<li>更小的通常更好</li>
</ul>
<p>一般情况下，使用可以正确存储数据的最小数据类型，更小的类型通常更快，需要更小的磁盘、内存以及cpu缓存。但是需要确保没有低估需要存储的值的范围。</p>
<ul>
<li>简单就好</li>
</ul>
<p>简单的数据类型操作通常需要更少的cpu周期。整型比字符串操作代价更低，字符集和校对规则使字符比较耿复杂；应该使用mysql内建类型而不是使用字符串来存储日期和时间。</p>
<ul>
<li>尽量避免null</li>
</ul>
<p>null值是列的默认属性，最好指定not null,除非真的需要null值。</p>
<p>可为null的列，对mysql来说更难优化，null使得索引、索引统计和值比较都更为复杂，可为null的列会使用更多的存储空间。</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>有两种存储类型，整数和实数。整数类型 tinyint（8）、smallint（16）、mediumint（24）、int（32）、bigint（64）。位存储空间，范围从-2的（n-1）次幂到2的（n-1）次幂。其中n是存储空间的位数。</p>
<p>整数类型有可选的unsigned属性，表示允许负值，大致可以使得存储范围上限提高一倍。例如tinyint unsigned可以是0-255，而tinyint的存储范围是-128至127</p>
<p>有符号和无符号类型使用相同的存储空间，并具有相同的性能，根据实际情况选择。</p>
<p>mysql可以为整数类型指定宽度，例如int(11)对大多数应用是没有意义的：它不会限制值的合法范围，只是规定mysql的一些交互工具（如mysql命令行客户端）来显示字符的格式，对于存储来说，int(1)和int(20)是一样的。</p>
<h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><ul>
<li><p>实数是带有小数部分的数字。DECIMAL可以存储比bigInt还大的整数。DECIMAL类型用于存储精确的小数，DECIMAL支持精确的计算。cpu不支持对DECIMAL的直接结算，mysql服务器自身实现了DECIMAL的高精度计算。</p>
</li>
<li><p>浮点和DECIMAL类型都可以指定精度。DECIMAL在5.0以上版本允许存储65个数字，DECIMAL实际上不能再计算中使用这么大的数字，因为DECIMAL只是一种存储格式：因为在计算中DECIMAL会转换为DOUBLE类型。</p>
</li>
<li><p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL-例如财务数据，尽量在数据量比较大的情况下使用bigInt代替DECIMAL，将需要存储的货币单位乘以相应的倍数即可。</p>
</li>
</ul>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>每个字符串可以定义自己的字符集和排序规则或者说校对规则。</p>
<h3 id="VARCHAR和CHAR类型"><a href="#VARCHAR和CHAR类型" class="headerlink" title="VARCHAR和CHAR类型"></a>VARCHAR和CHAR类型</h3><p>存储VARCHAR和CHAR值的方式在内存中和磁盘上可能不一样，所以mysql服务器从存储引擎读出的值可能需要转换为另一种存储格式。</p>
<h4 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h4><ul>
<li><p>VARCHAR存储可变长字符串,最常见。比定长的类型节省空间，只使用必要的空间，row_format=fixed的时候，每一行使用必要的空间。</p>
</li>
<li><p>varchar使用1-2字节记录字符串长度,长度&gt;255用2，&lt;255用1.可以提升性能。但是由于变长，如果update操作使得某个字段空间增长，innodb使用分裂页来使得行放进页内。</p>
</li>
</ul>
<p><strong>适合使用varchar</strong></p>
<p>字符串的最大长度比平均长度的大很多的、列的更新少的（碎片不是问题）、使用UTF-8这样的复杂的字符集，每个字符使用不同的字节数压缩；</p>
<h4 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h4><p>定长，总是根据定义的字符串长度分配足够的空间。存储char值时，删除末尾的空格，会根据长度进行填充以方便比较。</p>
<p>适合存储很短的字符串或者值长度接近的。经常变更的数据，char也比varchar更好，定长的char不容易产生过碎片。</p>
<p><code>注意</code>：</p>
<p>某个字符串尾部的空格，varchar类型的会显示，char类型的会被去掉（在末尾填充空格只是存储，显示的时候不会显示）。</p>
<h4 id="binary和varbinary"><a href="#binary和varbinary" class="headerlink" title="binary和varbinary"></a>binary和varbinary</h4><p>存储二进制字符串。存储的是字节码不是字符串；填充binary采用的是\0（零字节）而不是空格，检索时不会去掉填充值；</p>
<p><strong>优势</strong></p>
<p>存储二进制数据，希望mysql使用字节码而不是字符串比较。二进制不仅仅体现在大小写敏感上，比较binary字符串时，每次按照一个字节，根据字节的数值比较，比字符快很多。</p>
<p><code>注意</code>：</p>
<p>使用varchar（5）和varchar（200）存储‘hello’的存储开销是一样的，但是更短的列有很大的优势。更长的列会消耗更多的内存，尤其在使用内存临时表进行排序等操作时更糟糕。</p>
<h3 id="blob和text类型"><a href="#blob和text类型" class="headerlink" title="blob和text类型"></a>blob和text类型</h3><p>都是为大数据存储设计的字符串类型，分别采用二进制和字符方式存储。text是smalltext的同义词，blob是smallblob的同义词</p>
<ul>
<li><p>字符类型：tinytext、smalltext、text、mediumtext、longtext.</p>
</li>
<li><p>二进制类型：tinyblob、smallblob、blob、mediumblob、longblob。</p>
</li>
</ul>
<p>会把每个blob和text当做独立对象处理。存储引擎存储时会做特殊处理，当text、blob太大时，会在行内存储1-4个字节的指针，在专门的外部存储区域存储实际的值。</p>
<p><code>区别</code>：</p>
<p>blob和text区别是使用二进制存储，没有排序规则或字符集，而text类型有字符集和排序规则；</p>
<p>mysql对blob和text的排序与其他类型不同，它支队没格列的最前的max_sort_length字节而不是整个字符串做排序，而不是整个字符串。如果字需要一部分字符，则可以减少max_sort_length的配置。</p>
<p>mysql不能使用它们的全部长度进行索引。</p>
<p><code>注意</code></p>
<p>尽量不要使用blob和text类型存储，无法避免的话在所有用到blob字段的地方使用subString(column,length)将列值转换为字符串。</p>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>mysql最小的时间粒度为秒。但是可以使用微秒级的粒度进行计算。mysql提供datetime和timestamp两种日期类型格式。除了特殊情况，通常尽量使用TIMESTAMP，因为它比DATETIME空间效率高。有人会使用整数存储时间截的格式不方便处理。</p>
<p>但是如果需要存储微秒级别的数据则尅使用bigint类型存储微秒级别的时间戳。</p>
<h3 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h3><p>存储范围 1001-9999，精度秒，它吧日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节的存储空间，默认以一种尅排序的无歧义的格式显示，如`2008-01-16 22:37:08``</p>
<h4 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h4><p>可以存储从1970年以来的秒数，使用4个字节存储空间，范围比DATETIME小得多，只能表示1970至2038年，mysql提供了from_unixtime()函数把时间戳转换为日，并提供unix_timestamp（）把日期转换为unix时间戳。</p>
<p>TIMESTAMP依赖时区，服务器、操作系统、客户端连接都有时区设置。它在不同的时区显示的时间是不同的。</p>
<p>TIMESTAMP类型默认为not null，默认为当前的时间。</p>
<h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>mysql有几种存储类型使用紧凑的位存储类型数据，所有这些位类型，不管底层存储的格式和处理方式如何，从技术上来说都还是字符串类型。</p>
<h3 id="BIT"><a href="#BIT" class="headerlink" title="BIT"></a>BIT</h3><p>在mysql5.0之前bit是tinyint的同义词，之后的版本bit是完全不同的数据类型。</p>
<p>bit列在一列中存储一个或多个true/false值， bit(1)定义一个包含单个位的字段，bit位最大的长度为64个位。</p>
<p>bit的行为因存储引擎而异，mylSam会打包所有的bit位，所以17个单独的bit列只需要17个存储位，这样mylSam只能使用三个字节就能存储17个bit列。其它存储引擎如Memory何innoDB，为每个bit位使用一个足够存储的最小整数来存储，所以不能节省存储空间。</p>
<p>mysql把bit位要当做字符串存储，而不是数字类型，咋整数数字上下文的场景检索时，结果是将位字符转化为数字。这个不太好理解，所以大部分应用，最好避免使用这种类型。</p>
<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>打包set数据集和类型，他在mysql内部是使用一系列的打包的位的集合来表示的。</p>
<h2 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h2><p>标识符类型就是关联表所使用的类型，要考虑这种类型如何计算和比较。例如存储整数使用enum和set类型，在比较时转化为字符串。</p>
<p>enum和set使用存储固定信息。</p>
<p>尽可能避免使用字符串类型作为表示列，因为他们很消耗空间，通常比数字类型慢。尤其在使用MylSAM表里使用字符串作为标识列时要特别小心，MylSAM默认对字符串使用压缩索引，这样会导致查询慢很多。</p>
<h2 id="特殊类型的数据"><a href="#特殊类型的数据" class="headerlink" title="特殊类型的数据"></a>特殊类型的数据</h2><p>某些类型的数据并不能直接与内置类型一直。低于秒级别的时间戳就是一个列子。</p>
<h1 id="Mysql-schema设计中的缺陷"><a href="#Mysql-schema设计中的缺陷" class="headerlink" title="Mysql schema设计中的缺陷"></a>Mysql schema设计中的缺陷</h1><p>虽然有一些普遍的好或坏的设计原，但有一些问题还是由MySQL的实现机制导致的。</p>
<ul>
<li>太多的列</li>
</ul>
<p>mysql的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成个格列。从缓冲中将编码过的列转换成数据结构的操作代价是非常高的。</p>
<ul>
<li>太多的关联</li>
</ul>
<p>表过多的关联回合降低性能，单个查询最好在12个表以内做关联。</p>
<ul>
<li>枚举</li>
</ul>
<p>如果有枚举的情况存在，尽量使用一张字典表或者查找表来找具体的值。</p>
<ul>
<li>NUll</li>
</ul>
<p>尽可能的避免使用null，如果一定要使用空值，可以使用0或者某个特殊的值代替。</p>
<p>但是不要走极端，因为-1带表未知的整数，可能导致代码复杂很多。比如date类型的 not null default ‘0000-00-00 00:00:00’</p>
<p> -*/</p>
<h1 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">数据库的三大范式</a></p>
<h2 id="范式的优点和缺点"><a href="#范式的优点和缺点" class="headerlink" title="范式的优点和缺点"></a>范式的优点和缺点</h2><ul>
<li>范式的更新操作通常比反范式的块；</li>
<li>更好的范式化，更少或者没有重复数据，所以修改更少的数据；</li>
<li>范式化的表通常更小，更好的存储在内存中；</li>
<li>很少有多余的数据以为这检索表数据时更少需要distinct或者group by语句。</li>
</ul>
<p>范式化设计的schema缺点是需要关联，稍微负载一些的查询语句符合范式化的schema可能需要一次关联。</p>
<h2 id="反范式的有点和缺点"><a href="#反范式的有点和缺点" class="headerlink" title="反范式的有点和缺点"></a>反范式的有点和缺点</h2><p>反范式的schema因为所有数据都在一张表中，可以很好的避免关联。</p>
<p>关联是的需要在一个索引中又排序又过滤。如果采用反范式化组织数据，将两张表的字段合并一下，只需要增加一个索引，这样不通过关联写出这个查询，这将会非常高效。</p>
<h2 id="混合范式化和反范式化"><a href="#混合范式化和反范式化" class="headerlink" title="混合范式化和反范式化"></a>混合范式化和反范式化</h2><p>在实际的使用中不用完全范式话，这避免了完全反范式化的插入和删除的问题。</p>
<h1 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h1><p>有时提升性能最好的方法是在同一张表保存衍生的冗余数据，然后有时也需要创建一张完全独立的汇总表或缓存表。</p>
<p><strong>缓存表</strong>表示存储那些可以简单的从schema其他表获取（但是每次获取的速度比较慢）数据的表。</p>
<p><strong>汇总表</strong>保存的是使用group by语句聚合数据的表，或者被称为累计表。</p>
<h1 id="加快alter-table的操作速度"><a href="#加快alter-table的操作速度" class="headerlink" title="加快alter table的操作速度"></a>加快alter table的操作速度</h1><p>mysql的alter table操作的性能对大表来说是个大问题。mysql执行大部分修改表结构的操作的方法是用新的结构创建一个空表，然后从旧表中查询出所有数据插入新表，然后删除旧表。</p>
<p>这样操作会话费很长时间，如果内存不足而且表又很大，还有很多索引的情况下尤其如此。</p>
<h2 id="大部分alter-table操作导致mysql服务中断。"><a href="#大部分alter-table操作导致mysql服务中断。" class="headerlink" title="大部分alter table操作导致mysql服务中断。"></a>大部分alter table操作导致mysql服务中断。</h2><p>提供2中使用的技巧：</p>
<ul>
<li>现在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换；</li>
<li>‘影子拷贝’，用要求的表结构创建一张和原表无关的新表，然后通过重命名和删除表交换两张表；</li>
</ul>
<p>假如需要修改某列的默认值，可以直接修改.frm文件中。但是mysql不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table sakila.film alter column rental_duration set DEFAULT 5;</span><br></pre></td></tr></table></figure>

<p>这个语句会直接修改.frm文件不涉及表结构，所以操作是非常快的。</p>
<h2 id="快速创建MylSAM索引"><a href="#快速创建MylSAM索引" class="headerlink" title="快速创建MylSAM索引"></a>快速创建MylSAM索引</h2><p>一个技巧是先禁用索引、载入数据然后重启索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alter table test.load_data disable keys;</span><br><span class="line"></span><br><span class="line">-- load the data</span><br><span class="line"></span><br><span class="line">alter table test.load_data enable keys;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个对唯一索引无效， disable keys 只对非唯一索引有效。MylSAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性，一旦索引的大小超过了有效内存的大小，载入操作就非常慢。</p>
<h1 id="schema设计原则总结"><a href="#schema设计原则总结" class="headerlink" title="schema设计原则总结"></a>schema设计原则总结</h1><ul>
<li>尽快避免过度设计，例如会导致极其复杂查询的schema设计，或者很多列的表设计；</li>
<li>使用小而简单的合适数据类型，除非真是数据模型中确切需要，否则尽量避免使用NUll值；</li>
<li>尽量使用相同的数据类型存储相似或者相关的值，尤其是要在关联查询中使用到的列；</li>
<li>注意使用可变长字符串，其在临时表和排序时会导致悲观的按照最大长度分配内存；</li>
<li>尽量使用整型定义标识列；</li>
<li>尽量避免使用mysql遗弃的特性（指定浮点数的精度，或者整数显示宽度）小新使用enum和set，最好避免使用bit；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-11-14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-11-14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">git常用命令总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-14 16:47:04" itemprop="dateCreated datePublished" datetime="2018-11-14T16:47:04+08:00">2018-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h1><p>将远端的git项目拉取到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone resource_url</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="正常的开发流程"><a href="#正常的开发流程" class="headerlink" title="正常的开发流程"></a>正常的开发流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.在master分支拉取远端分支的代码到本地，以保证新创建的分支的时候是最新的代码；</span><br><span class="line">git pull origin master </span><br><span class="line"> </span><br><span class="line">2.查看最新的tag，因为开发分支名字的后缀tag是基于最新的tag开出来的，加入最新的tag是1.1.1</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">3.创建新的分支 </span><br><span class="line"></span><br><span class="line">git checkout -b br_test_develop_1.1.1</span><br><span class="line"></span><br><span class="line">4.进行开发</span><br><span class="line">。。。。</span><br><span class="line"></span><br><span class="line">5.查看代码的状态</span><br><span class="line"> git status</span><br><span class="line"> </span><br><span class="line">6.&#39;.&#39;代表当前目录下的所有文件， 也是可以只是添加某一个文件到stage缓存区</span><br><span class="line">git add . 或者 git add files </span><br><span class="line"></span><br><span class="line">7.把 stage 缓存生成一次 commit，并加入 commit 历史, - m是添加注释</span><br><span class="line">git commit -m &quot;commit message&quot;</span><br><span class="line"></span><br><span class="line">8.将新的分支push到远端，将新的commit代码push到远端。</span><br><span class="line">git push origin br_test_develop_1.1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="修改提交日志"><a href="#修改提交日志" class="headerlink" title="修改提交日志"></a>修改提交日志</h2><p>假如你执行 commit -m 时记录的日志描述和本次执行commit的功能不符合，又不想创建新的commit，此时可以使用一下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend  </span><br><span class="line"></span><br><span class="line">然后使用 vim编辑操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="上线项目需要做的操作"><a href="#上线项目需要做的操作" class="headerlink" title="上线项目需要做的操作"></a>上线项目需要做的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这里假设开发分支为 br_test_develop_1.1.1 。</span><br><span class="line"></span><br><span class="line">1. 先拉取br_test_develop_1.1.1的远端代码，</span><br><span class="line">git pull origin br_test_develop_1.1.1</span><br><span class="line"></span><br><span class="line">2. 然后切换到master分支,拉取master分支的远端代码</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">3. 切换到br_test_develop_1.1.1分支，merge master的代码到br_test_develop_1.1.1,有冲突解决冲突，提交到远端。（防止开发的代码污染master分支，这一步不可以省略。）</span><br><span class="line">git checkout br_test_develop_1.1.1</span><br><span class="line">git merge master</span><br><span class="line">git push origin br_test_develop_1.1.1</span><br><span class="line"></span><br><span class="line">4. 切换到master分支，merge br_test_develop_1.1.1的代码到master分支。</span><br><span class="line">git checkout master</span><br><span class="line">git merge br_test_develop_1.1.1</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">5. 确认当前分支是master，且是最新的代码。查看tag，上线的tag在最新的基础上命名一个，或者按照版本需要创建一个tag。</span><br><span class="line">git fetch -all &#x2F;&#x2F; 这将更新git remote 中所有的远程repo 所包含分支的最新commit-id，包括tag</span><br><span class="line">git tag  &#x2F;&#x2F; 查看tag 列表</span><br><span class="line">git tag 1.1.2  &#x2F;&#x2F;创建本地tag为1.1.2</span><br><span class="line">git push --tag &#x2F;&#x2F; push tag 到远端</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="情景1：本地开发着，需要合并远端的开发分支的代码"><a href="#情景1：本地开发着，需要合并远端的开发分支的代码" class="headerlink" title="情景1：本地开发着，需要合并远端的开发分支的代码"></a>情景1：本地开发着，需要合并远端的开发分支的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. stash存储本地的开发中的代码</span><br><span class="line">git add .</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">2. 执行rebase命令，拉取远端代码重建base</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line">3. 取出stash的代码，pop命令会取出并删除stash的代码（最近的一次）</span><br><span class="line">git stash pop </span><br><span class="line"></span><br><span class="line">4. 手动解决冲突 并add .</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">5. 结束reabse模式，如果此时提示No rebase in progress?则表示已经没有冲突了；否则上面两步要重复多次或者执行 git rebase --abort</span><br><span class="line">git rebase --continue 或者 git rebase --abort</span><br><span class="line"></span><br><span class="line">6. 提交代码到远端</span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m “commit message”</span><br><span class="line">git push origin &#39;branchName&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="情景2：git-reset-回退到某次提交的代码"><a href="#情景2：git-reset-回退到某次提交的代码" class="headerlink" title="情景2：git reset 回退到某次提交的代码"></a>情景2：git reset 回退到某次提交的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 查看log日志，取出要取消的某次操作的commitId</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">2. 执行reset操作 </span><br><span class="line">git reset --hard &lt;commitId&gt; </span><br><span class="line">或者 </span><br><span class="line">git reset --hard HEAD~2 &#x2F;&#x2F;回退两个commitId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 强制提交到远端 (-f 慎重使用)</span><br><span class="line">git push origin &lt;branchName&gt; -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意</code>：reset参数。<b>add 是将代码添加工作区，commit是将代码添加到缓存区</b></p>
<ul>
<li>-soft – 缓存区和工作目录都不会被改变(执行了add和commit)</li>
<li>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响（只是add 未commit） </li>
<li>–hard – 缓存区和工作目录都同步到你指定的提交(代码都没有了)（代码都没有了）</li>
</ul>
<h2 id="情景3：-git-revert-取消某次的提交-merge版本的commit无法处理"><a href="#情景3：-git-revert-取消某次的提交-merge版本的commit无法处理" class="headerlink" title="情景3： git revert 取消某次的提交(merge版本的commit无法处理)"></a>情景3： git revert 取消某次的提交(merge版本的commit无法处理)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 查看log日志，取出要取消的某次操作的commitId</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">2. 执行reset操作</span><br><span class="line">git revert -n &lt;commitId&gt;</span><br><span class="line"></span><br><span class="line">3. commit push</span><br><span class="line">git commit -m “commit message”</span><br><span class="line">git push origin &lt;branchName&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="情景4：本地正开发着，需要切换到别的分支，此时可以将代码stash到缓存区"><a href="#情景4：本地正开发着，需要切换到别的分支，此时可以将代码stash到缓存区" class="headerlink" title="情景4：本地正开发着，需要切换到别的分支，此时可以将代码stash到缓存区"></a>情景4：本地正开发着，需要切换到别的分支，此时可以将代码stash到缓存区</h2><p>git-stash - Stash the changes in a dirty working directory away</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git stash &#x2F;&#x2F;Stash the changes in a dirty working directory away</span><br><span class="line"></span><br><span class="line">git stash list &#x2F;&#x2F;查看缓存记录</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要恢复缓存的代码到工作区. 其中stashId可以在git stash list 命令展示的列表中查看</span><br><span class="line">git stash pop 或者 git stash apply stashId</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清除缓存 </span><br><span class="line">git stash clear  或者 git stash drop  stashId</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>建议</code>： stash缓存使用完请及时clear，时间久了可能容易忘记stash的内容，恢复的时候造成冲突。</p>
<h2 id="关于分支的常用操作"><a href="#关于分支的常用操作" class="headerlink" title="关于分支的常用操作"></a>关于分支的常用操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 拉取远端的分支代码，因为默认down代码的时候，不是获取所有远端的最新的代码</span><br><span class="line"> git fetch --all</span><br><span class="line"></span><br><span class="line">2. 查看远端、本地的分支，以及所有分支</span><br><span class="line">git branch &#x2F;&#x2F;查看本地分支</span><br><span class="line">git branch -r &#x2F;&#x2F; -r代码remote，所有的远端分支。</span><br><span class="line">git branch -a &#x2F;&#x2F;查看所有的分支</span><br><span class="line"></span><br><span class="line">3. 一般情况下，远端分支和本地分支是同名的，如果不是同名的需要查看本地分支追踪的远端分支如何查看。</span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line">4. 如何设置本地追踪的远端分支</span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; master</span><br><span class="line"></span><br><span class="line">5. 删除在本地有但在远程库中已经不存在的分支</span><br><span class="line">git remtte prune origin </span><br><span class="line"></span><br><span class="line">6. 删除本地分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br><span class="line"></span><br><span class="line">7. 删除远端分支 (必须有权限)</span><br><span class="line">git push origin --delete &lt;branchName&gt;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于标签的操作"><a href="#关于标签的操作" class="headerlink" title="关于标签的操作"></a>关于标签的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 查看标签列表 之前要执行git fetch --all 拉取远端的分支以及tag到本地</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">2. 查看tag的详细信息,打标签的人以及时间</span><br><span class="line">git show &lt;tagName&gt;</span><br><span class="line"></span><br><span class="line">3. 打标签</span><br><span class="line">git tag &lt;tagName&gt; &#x2F;&#x2F; 在本地的当前commitId节点处创建一个tag标签</span><br><span class="line">或者</span><br><span class="line">git tag -a &lt;tagName&gt; -m &quot;commit message&quot;</span><br><span class="line"></span><br><span class="line">4. 删除本地标签</span><br><span class="line">git tag -d &lt;tagName&gt;</span><br><span class="line"></span><br><span class="line">5. 删除远端分支</span><br><span class="line">git push origin --delete &lt;tagName&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="创建新的项目提交到gitlab上"><a href="#创建新的项目提交到gitlab上" class="headerlink" title="创建新的项目提交到gitlab上"></a>创建新的项目提交到gitlab上</h2><ol>
<li>需要在gitlab上操作创建一个项目</li>
<li>配置用户名和邮箱</li>
</ol>
<h3 id="已有项目添加到远端"><a href="#已有项目添加到远端" class="headerlink" title="已有项目添加到远端"></a>已有项目添加到远端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 计入文件夹，初始化为git项目</span><br><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">2. 本地和远端进行关联</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;172.16.117.224&#x2F;ent_teach&#x2F;ent-test.git</span><br><span class="line"></span><br><span class="line">3. 执行 add commit push 操作</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 克隆远端项目</span><br><span class="line">git clone http:&#x2F;&#x2F;172.16.117.224&#x2F;ent_teach&#x2F;ent-test.git</span><br><span class="line"></span><br><span class="line">2. 进入相应的目录，添加README.md文件。执行 add commit push 操作</span><br><span class="line">cd ent-test</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解决冲突的技巧"><a href="#解决冲突的技巧" class="headerlink" title="解决冲突的技巧"></a>解决冲突的技巧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这一篇解释了手动解决冲突时&lt;&lt;&lt;&lt;和&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;的含义 </span><br><span class="line">一般情况下rebase都是会有冲突的，详细查看冲突可以用命令git status然后就会显示哪个文件有冲突，然后打开有冲突的哪个文件，会发现有一些“&lt;&lt;&lt;&lt;&lt;&lt;&lt;”， “&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”， “&gt;&gt;&gt;&gt;&gt;&gt;&gt;” 这样的符号。</span><br><span class="line"></span><br><span class="line">“&lt;&lt;&lt;&lt;&lt;&lt;&lt;” 表示冲突代码开始</span><br><span class="line"></span><br><span class="line">“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;” 表示test与master冲突代码分隔符</span><br><span class="line"></span><br><span class="line">“&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; 表示冲突代码的结束</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;  </span><br><span class="line">所以这一块区域test的代码</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">这一块区域master的代码</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 查看日志</span><br><span class="line">git log  &#x2F;&#x2F;显示的是commitId以及commit Message</span><br><span class="line"></span><br><span class="line">2.查看状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">3. 快速查看旧版本</span><br><span class="line">git checkout commitId</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="gitlab配置ssh-key"><a href="#gitlab配置ssh-key" class="headerlink" title="gitlab配置ssh key"></a>gitlab配置ssh key</h2><p>1.打开本地git bash,使用如下命令生成ssh公钥和私钥对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;xxx@xxx.com&#39; 然后一路回车(-C 参数是你的邮箱地址)</span><br></pre></td></tr></table></figure>
<p><img src="/images/git/ssh-key.png" alt="ssh-key"></p>
<p>2.然后打开<del>/.ssh/id_rsa.pub文件(</del>表示用户目录，比如我的windows就是C:\Users\Administrator)，复制其中的内容</p>
<p>3.打开gitlab,找到Profile Settings–&gt;SSH Keys—&gt;Add SSH Key,并把上一步中复制的内容粘贴到Key所对应的文本框，在Title对应的文本框中给这个sshkey设置一个名字，点击Add key按钮</p>
<p><img src="/images/git/gitlab-setting.png" alt="gitlab-setting"></p>
<ol start="4">
<li>到此就完成了gitlab配置ssh key的所有步骤，我们就可以愉快的使用ssh协议进行代码的拉取以及提交等操作了</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ToDoToTry/p/4095626.html">git fetch 与git pull的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TTKatrina/article/details/79288238">git rebase的用法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yxlshk/article/details/79944535">git revert与git reset操作详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ouber23/articles/5466040.html">暂存区与工作区</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-11-12/%E9%AB%98%E6%80%A7%E8%83%BDmysql-Mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%86%E5%8F%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-11-12/%E9%AB%98%E6%80%A7%E8%83%BDmysql-Mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%86%E5%8F%B2/" class="post-title-link" itemprop="url">高性能mysql-Mysql的架构和历史</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-12 10:13:47" itemprop="dateCreated datePublished" datetime="2018-11-12T10:13:47+08:00">2018-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>MySQL最重要，最与众不同的特性是它的可插拔式存储引擎架构（将查询处理，系统任务，数据的存储，提取相分离）。</li>
</ul>
<h1 id="MySQL逻辑结构"><a href="#MySQL逻辑结构" class="headerlink" title="MySQL逻辑结构"></a>MySQL逻辑结构</h1><p><img src="/images/mysql/mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="mysql服务器逻辑架构图"></p>
<p>第一层服务：大多数的客户端/服务端的工具或者服务都有类似的架构，比如连接处理、授权处理、安全等。</p>
<p>第二层服务：核心服务都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现。</p>
<p>第三层服务：包含了存储引擎，存储引擎负责mysql的数据存储和提取。</p>
<h2 id="连接管理和安全性"><a href="#连接管理和安全性" class="headerlink" title="连接管理和安全性"></a>连接管理和安全性</h2><p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在单独的线程中执行，该线程都只能轮流在某个cpu中运行，服务器会缓存线程，不需要为每一个新建的连接创建和销毁线程。</p>
<p>当客户端进行连接后，服务器需要对其进行认证。</p>
<h2 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h2><p>mysql会解析查询，并创建内部数据结构（解析树），然后进行各种优化，包括重写查询、决定表的读取顺序、以及选择合适的索引等。用户可以使用关键字提示优化器（hint）影响他的决策进程，<br>也可以使用请求优化解释器优化过程的各个因素。mysql在解析查询之前，服务器会先检查查询缓存，如果有就不必执行查询解析。</p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>同一时刻修改数据都会产生并发控制的问题，本章主要考虑服务层与存储引擎层。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>共享锁与排它锁也叫读写锁。读锁是共享的，或者是互不阻塞的，多个客户在读取同一个资源互不干扰，写锁是排他的，一个写锁会阻塞其它的写锁和读锁。这样同一时间才会只有一个用户执行写入操作。</p>
<p>实际数据库中，当某个用户在修改某一部分数据时，mysql会通过锁定防止其它用户读取同一数据。</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>提高共享资源的并发性就是让锁定对象更具有选择性，尽量指锁定需要修改的部分数据。锁定的数据越少，则系统的并发度越高。当然，加锁也需要消耗资源，比如获得锁，检查锁是否解除，释放锁等都会有开销。</p>
<p>锁策略是指在锁的开销和数据的安全性之间寻找平衡。一般数据库只是在表上加行锁，而mysql提供了更多选择。</p>
<p>将锁的粒度固定在某个级别可以为某种特定的场景提供更好的性能。</p>
<ul>
<li>表锁（table lock）</li>
</ul>
<p>它是最基本的锁策略，开销最小的锁策略，锁定整张表。一个用户在对表执行写操作需要获得的锁，他会阻塞其它用户对表的读写操作。</p>
<ul>
<li>行级锁 (row lock)</li>
</ul>
<p>行级锁可以最大程度支持并发处理，也是开销最大的锁。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务内的语句要么执行，要么全部不执行。事务是一个原子性的工作单元，</p>
<h2 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h2><ul>
<li>原子性（atomicity）</li>
</ul>
<p>一个事务是不可分割的最小单元，整个事务要么执行，要么全部失败回滚。</p>
<ul>
<li>一致性（consistency）</li>
</ul>
<p>事务总是从一个一致性的状态到另一个一致性的状态，如 A:500-&gt;200  B:100-&gt; 400</p>
<ul>
<li>隔离性（isolation）</li>
</ul>
<p>一个事务所做的修改操作在最终提交以前，对其它事务是不可见的。</p>
<ul>
<li>持久性（durability）</li>
</ul>
<p>一旦事务提交，则所做的修改就会永久的保存到数据库中，即使数据库奔溃，修改的数据也不会丢失。数据库实现ACID需要做更多的额外工作，会增加系统开销。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>sql标准中有4种隔离级别，较低级别的隔离通常可以执行更高的并发，系统的开销也更小。</p>
<ul>
<li><p>未提交读（read uncommitted）：事务中的修改，即使没有提交，对其它事务也是可见的。事务可以读取未提交的数据，这也被称为脏读，这个级别也会导致很多问题，性能也不会好太多，不常用。</p>
</li>
<li><p>提交读(read committed): 大多数的数据库系统的隔离级别都是read committed（mysql不是），一个事务开始时，只能看见已经提交的修改。也叫不可重复读，执行两次的查询可能得到不一样的结果。</p>
</li>
<li><p>可重复读（repeatable read）:解决了脏读的问题，该级别的保证了同一个事务中多次读取同样的结果是一致的，可重复读还是无法解决幻读的问题。所谓幻读是指当某个事务在读取某个范围内的记录时，<br>另一个事务又在该范围内又插入了新的记录，当前事务再次读取该范围的记录时会产生换读。（可重复读是mysql默认事务隔离级别）。</p>
</li>
<li><p>可串行化(serializable)：最高的隔离级别，强制事务串行执行。通过强制事务串行执行避免了幻读。可串行化会在读取的每一行数据上都加锁，所以导致大量的超时和锁争用的问题，很少用。悲观锁。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。多个事务同时锁定同一个资源时，也会产生死锁。</p>
<p>处理办法：完备的RDMS包含了死锁检测与死锁超时机制。innoDB存储引擎，越能检测到死锁的循环依赖，立即返回一个错误。innoDB目前采用持有最少行级排他锁的事务进行回滚。</p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务日志可以帮助提高事务的效率。可以将修改行为的记录持久化到硬盘的事务日志中，不需要每次都将修改的数据本身持久化到硬盘。事务日志采用追加的方式。</p>
<h3 id="mysql中的事务"><a href="#mysql中的事务" class="headerlink" title="mysql中的事务"></a>mysql中的事务</h3><p>mysql提供了两种事务型的存储引擎，innoDB 和NDB cluster。另外还有一些第三方的存储引擎。</p>
<ul>
<li>自动提交</li>
</ul>
<p>mysql默认的采用自动提交的模式，如果不显式的开始一个事务，每个查询都会被当做一个事务提交操作。autocommit = 0表示禁用，需要手动提交。对于使用mylsam的，不影响使用。</p>
<p>可以通过命令行设置事务的隔离级别：set session transaction isolation level read committed;</p>
<h4 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h4><p>mysql服务期层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</p>
<p>如果在事务中混了使用了innoDB以及mylsam表，正常提交的情况下不会有问题，但是事务回滚，则非事务型的表的变更就无法撤销，这样导致数据库处于不一致的状态。所以选择合适的存储引擎非常重要。</p>
<p>非事务型的表上的变更不会被报错，只会有提示“某些非事务型的表上的变更不会被回滚”。</p>
<h4 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h4><p>innoDB是两阶段锁定协议，在事务执行的过程中，随时都可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁是在同一时刻被释放。这是隐式锁定。innoDB会在需要的时候自动加锁。</p>
<p>建议： 除了使用中禁用了autocommit，可以使用lock tables之外，其它人事时候都不需要显示的执行lock tables和unlock tables语句。</p>
<h2 id="多版本的并发控制-（MVCC）"><a href="#多版本的并发控制-（MVCC）" class="headerlink" title="多版本的并发控制 （MVCC）"></a>多版本的并发控制 （MVCC）</h2><p>mysql的大多数事务型存储引擎实现的都不是简单的行级锁，基于并发性能的考虑都实现了多版本的并发控制（MVCC）</p>
<p>MVCC是行级锁的一个变种，大多数情况下避免了加锁，大部分实现了非阻塞的读操作，写操作也只能锁定必要的行。</p>
<p>MVCC是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始时间的不同，每个事务对同一张表，同一个时刻看到的数据可能是不一样的。</p>
<h3 id="MVCC的实现"><a href="#MVCC的实现" class="headerlink" title="MVCC的实现"></a>MVCC的实现</h3><p>典型的有悲观锁和乐观锁的并发控制。</p>
<p>innoDB的MVCC的实现是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，时间值其实是系统版本号。每开始一个新的事务，系统版本号会自动递增。事务开始时刻的系统版本号作为事务的版本号，要用来和查询的每行记录表的版本号进行比较。</p>
<h4 id="在-REPEATABLE-READ-隔离级别下的INNODB的MVCC操作"><a href="#在-REPEATABLE-READ-隔离级别下的INNODB的MVCC操作" class="headerlink" title="在 REPEATABLE READ 隔离级别下的INNODB的MVCC操作"></a>在 REPEATABLE READ 隔离级别下的INNODB的MVCC操作</h4><ul>
<li>SELECT</li>
</ul>
<p>innoDB会根据以下两个条件检查每行记录：</p>
<ol>
<li>innoDB只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于等于事务的系统版本号），这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保读取到的行，在事务开始之前未被删除。</li>
</ol>
<ul>
<li>INSERT</li>
</ul>
<p>INNODB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<ul>
<li>DELETE</li>
</ul>
<p>INNODB为删除的每一行保存当前系统版本号作为删除标识。</p>
<ul>
<li>UPDATE</li>
</ul>
<p>INNODB 为新插入的一行新纪录，保存当前版本号为行版本号，同时保存当前系统版本号为原来的行作为行删除标识。</p>
<ol>
<li>保存这两个额外的系统版本号，使得大多数操作都可以不用加锁。可以挺高性能，但是需要每行都增加额外的操作空间，需要额外的检查工作。</li>
<li>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。</li>
</ol>
<h2 id="MySql的存储引擎"><a href="#MySql的存储引擎" class="headerlink" title="MySql的存储引擎"></a>MySql的存储引擎</h2><p>mysql将为每个数据库（schema）保存为数据目录下的一个子目录，创建表时，mysql会在数据库子目录下创建一个和表同名的.frm文件保存表的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show table status like &#39;tableName&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>展示表的本身的信息</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><ul>
<li><p>innoDB的数据存储在表空间（tablespace）中，表空间是有innoDB管理的一个黑盒子，由一系列的数据文件组成。</p>
</li>
<li><p>innoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认是可重复读，并且通过间隙锁(next-key locking)策略防止幻读，间隙锁使得innoD不仅锁定查询涉及的行，还会针对索引中的间隙进行锁定，防止幻影行的出现。</p>
</li>
<li><p>innoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过他的二级索引（非主键索引）必须包含主键列，所以主键列如果很大的话，其它所有索引都会很大。如果表上的索引较多的话，主键应尽量的小。</p>
</li>
<li><p>innoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应hash索引。</p>
</li>
</ul>
<h3 id="MylSAM存储引擎"><a href="#MylSAM存储引擎" class="headerlink" title="MylSAM存储引擎"></a>MylSAM存储引擎</h3><p>在5.1版本之前，MylSAM是默认的存储引擎，MylSAM提供了大量的特性包括，全文索引，压缩，空间函数等。不支持事务以及行级锁，且在奔溃后无法安全恢复。对于小表，只读的数据可以忍受修复操作，则依然可以继续使用MylSAM。</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>MylSAM会将表存储在两个文件：数据文件和索引文件 分别以.MYD和.MYI为扩展名。MylSAM可以包含静态或者动态的行。它可以根据表的定义来确定使用何种格式行。 MAX_ROWS *AVG_ROW_LENGTH决定存储的数据量的大小。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>加锁和并发：只支持对整张表加锁，而不是针对行。读取操作时对表加共享锁，写入时加排他锁，但是在表有读取查询的同时，可以往表中插入数据（并发插入）。</p>
</li>
<li><p>索引特性：即使是blob、text等长字段，也可以基于前500个字符创建索引。</p>
</li>
<li><p>延迟更新索引：更新的索引不会直接flush，更新的缓存会放到缓冲区中，只有在需要flush或者关闭表时候才会放到硬盘。</p>
</li>
</ul>
<h4 id="MylSAM-压缩表"><a href="#MylSAM-压缩表" class="headerlink" title="MylSAM 压缩表"></a>MylSAM 压缩表</h4><p>如果表在创建并导入数据后，不会再进行修改操作，这样的表适合使用MylSAM存储引擎。MylSAM可以打包pack，压缩表不能直接进行修改，需要解压后修改。压缩表可以减少磁盘占用空间。</p>
<p>MylSAM引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。</p>
<h3 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h3><ul>
<li><p>MySql5.5将innoDB作为默认的存储引擎了；</p>
</li>
<li><p>除非需要用到某些innoDB不具备的特性，并且其它办法无法替代，否则都应该优先选择innoDB引擎；</p>
</li>
<li><p>除非万不得已，不建议混合使用多种存储引擎；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-11-02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-11-02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">深入理解java虚拟机-虚拟机类加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-02 10:22:04" itemprop="dateCreated datePublished" datetime="2018-11-02T10:22:04+08:00">2018-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</p>
<p><img src="/images/jvm/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>以下情况才会触发初始化：</p>
<ol>
<li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段；</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类</li>
<li>动态语言支持的，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ol>
<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>通过子类引用父类的静态字段，不会导致子类初始化；</p>
<p>通过数组定义来引用类，不会触发此类的初始化；</p>
<p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<h2 id="接口的加载过程的不同"><a href="#接口的加载过程的不同" class="headerlink" title="接口的加载过程的不同"></a>接口的加载过程的不同</h2><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</p>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载阶段需要完成三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流;</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，</p>
<p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终需要类加载器组创建。</p>
<p>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。</p>
<p>这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p><img src="/images/jvm/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。</p>
<p>＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。</p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，<br>每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，<br>否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package cn.chen.exercise.chapter7;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不同的类加载器对instanceof关键字运算的结果的影响</span><br><span class="line"> *</span><br><span class="line"> * @author Chen WeiJie</span><br><span class="line"> * @date 2018-11-05 22:49:24</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)throws Exception&#123;</span><br><span class="line">        ClassLoader myLoader&#x3D;new ClassLoader()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Class&lt;?&gt;loadClass(String name)throws ClassNotFoundException&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    String fileName&#x3D;name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;;</span><br><span class="line">                    InputStream is&#x3D;getClass().getResourceAsStream(fileName);</span><br><span class="line">                    if(is&#x3D;&#x3D;null)&#123;</span><br><span class="line">                        return super.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[]b&#x3D;new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    return defineClass(name,b,0,b.length);</span><br><span class="line">                &#125;catch(IOException e)&#123;</span><br><span class="line">                    throw new ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj&#x3D;myLoader.loadClass(&quot;cn.chen.exercise.chapter7.ClassLoaderTest&quot;).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj instanceof cn.chen.exercise.chapter7.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以加载与自己在同一路径下的Class文件。我们使用这个类加载器去加载了一个名为“org.fenixsoft.classloading.ClassLoaderTest”的类，并实例化了这个类的对象。两行输出结<br>果中，从第一句可以看出，这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的对象，但从第二句可以发现，这个对象与类org.fenixsoft.classloading.ClassLoaderTest做<br>所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来<br>自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h2 id="从Java虚拟机的角度来讲，只存在两种不同的类加载器："><a href="#从Java虚拟机的角度来讲，只存在两种不同的类加载器：" class="headerlink" title="从Java虚拟机的角度来讲，只存在两种不同的类加载器："></a>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</h2><p>一种是启动类加载器（Bootstrap  ClassLoader），这个类加载器使用C++语言实现  ，是虚拟机自身的一部分；另</p>
<p>一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p>
<h2 id="从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。"><a href="#从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。" class="headerlink" title="从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。"></a>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</h2><ul>
<li>启动类加载器（Bootstrap ClassLoader）：</li>
</ul>
<p>这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机<br>识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加<br>载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">Returns the class loader for the class.Some implementations may use null to represent the bootstrap class loader.This method will return null in such</span><br><span class="line">implementations if this class was loaded by the bootstrap class loader.</span><br><span class="line">*&#x2F;</span><br><span class="line">public ClassLoader getClassLoader（）&#123;</span><br><span class="line">ClassLoader cl&#x3D;getClassLoader0（）；</span><br><span class="line">if（cl&#x3D;&#x3D;null）</span><br><span class="line">return null；</span><br><span class="line">SecurityManager sm&#x3D;System.getSecurityManager（）；</span><br><span class="line">if（sm！&#x3D;null）&#123;</span><br><span class="line">ClassLoader ccl&#x3D;ClassLoader.getCallerClassLoader（）；</span><br><span class="line">if（ccl！&#x3D;null＆＆ccl！&#x3D;cl＆＆！cl.isAncestor（ccl））&#123;</span><br><span class="line">sm.checkPermission（SecurityConstants.GET_CLASSLOADER_PERMISSION）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return cl；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension  ClassLoader）"></a>扩展类加载器（Extension  ClassLoader）</h2><p>这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系<br>统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><p>这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回<br>值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p><img src="/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类加载器的双亲委派模型"></p>
<p>上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当<br>有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型不是一个强制性的约束模型，而是java开发者推荐的一种类加载器实现方式。</p>
<h3 id="双亲委派模型的工作过程是"><a href="#双亲委派模型的工作过程是" class="headerlink" title="双亲委派模型的工作过程是"></a>双亲委派模型的工作过程是</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是<br>如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在<br>rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。<br>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，</p>
<p>如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object<br>类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<p>如果读者有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行</p>
<h3 id="双亲委派模型的实现逻辑"><a href="#双亲委派模型的实现逻辑" class="headerlink" title="双亲委派模型的实现逻辑"></a>双亲委派模型的实现逻辑</h3><p>先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出</p>
<p>ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。</p>
<ul>
<li>双亲委派模型的实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class＜?＞loadClass（String name,boolean resolve）throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;首先，检查请求的类是否已经被加载过了</span><br><span class="line">Class c&#x3D;findLoadedClass（name）；</span><br><span class="line">if（c&#x3D;&#x3D;null）&#123;</span><br><span class="line">try&#123;</span><br><span class="line">if（parent！&#x3D;null）&#123;</span><br><span class="line">c&#x3D;parent.loadClass（name,false）；</span><br><span class="line">&#125;else&#123;</span><br><span class="line">c&#x3D;findBootstrapClassOrNull（name）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch（ClassNotFoundException e）&#123;</span><br><span class="line">&#x2F;&#x2F;如果父类加载器抛出ClassNotFoundException</span><br><span class="line">&#x2F;&#x2F;说明父类加载器无法完成加载请求</span><br><span class="line">&#125;</span><br><span class="line">if（c&#x3D;&#x3D;null）&#123;</span><br><span class="line">&#x2F;&#x2F;在父类加载器无法加载的时候</span><br><span class="line">&#x2F;&#x2F;再调用本身的findClass方法来进行类加载</span><br><span class="line">c&#x3D;findClass（name）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if（resolve）&#123;</span><br><span class="line">resolveClass（c）；</span><br><span class="line">&#125;</span><br><span class="line">return c；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-10-30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-10-30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">深入理解java虚拟机-java内存模型与线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-30 09:14:42" itemprop="dateCreated datePublished" datetime="2018-10-30T09:14:42+08:00">2018-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、</p>
<p>网络通信或者数据库访问上。衡量一个服务性能的高低好坏，每秒事务处理数（TransactionsPer Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系</p>
<h1 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h1><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运<br>算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己<br>的高速缓存，而它们又共享同一主内存（Main Memory），当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为<br>准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p><img src="/images/jvm/%E5%A4%84%E7%90%86%E5%99%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BB%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="处理器高速缓存主内存的交互关系"></p>
<p>与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化</p>
<h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p>此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的 ，不会被共享，自然就不会存在竞争问题。为了获得较<br>好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p><img src="/images/jvm/%E7%BA%BF%E7%A8%8B-%E4%B8%BB%E5%86%85%E5%AD%98-%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="线程-主内存-工作内存的交互关系"></p>
<h2 id="内存交互工作"><a href="#内存交互工作" class="headerlink" title="内存交互工作"></a>内存交互工作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节</p>
<ul>
<li><p>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p>
</li>
<li><p>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p>
</li>
<li><p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</p>
</li>
<li><p>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p>
</li>
</ul>
<h3 id="操作规则"><a href="#操作规则" class="headerlink" title="操作规则"></a>操作规则</h3><ol>
<li>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ol>
<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * volatile变量自增运算测试</span><br><span class="line">     *</span><br><span class="line">     * @author zzm</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static volatile int race &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void increase()&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int THREADS_COUNT &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread[] threads &#x3D; new Thread[THREADS_COUNT];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;等待所有累加线程都结束</span><br><span class="line">        while (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>问题就出现在自增运算“race++”之中，我们用Javap反编译这后发现只有一行代码的increase（）方法在Class文件中是由4条字节码指令构成的（return<br>指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此<br>时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值<br>同步回主内存之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean shutdownRequested；</span><br><span class="line">public void shutdown（）&#123;</span><br><span class="line">shutdownRequested&#x3D;true；</span><br><span class="line">&#125;</span><br><span class="line">public void doWork（）&#123;</span><br><span class="line">while（！shutdownRequested）&#123;</span><br><span class="line">&#x2F;&#x2F;do stuff</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
<h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><ul>
<li>原子性</li>
</ul>
<p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求</p>
<ul>
<li>可见性</li>
</ul>
<p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，<br>在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，</p>
<p>volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，<br>而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），<br>那在其他线程中就能看见final字段的值。</p>
<p>final与可见性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final int i；</span><br><span class="line">public final int j；</span><br><span class="line">static&#123;</span><br><span class="line">i&#x3D;0；</span><br><span class="line">&#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;也可以选择在构造函数中初始化</span><br><span class="line">j&#x3D;0；</span><br><span class="line">&#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有序性</li>
</ul>
<p>Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。<br>前半句是指“线程内表现为串行的语义”（Within-Thread  As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等</p>
<ul>
<li>先行发生原则示例1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下操作在线程A中执行</span><br><span class="line">i&#x3D;1；</span><br><span class="line">&#x2F;&#x2F;以下操作在线程B中执行</span><br><span class="line">j&#x3D;i；</span><br><span class="line">&#x2F;&#x2F;以下操作在线程C中执行</span><br><span class="line">i&#x3D;2；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个：一是根据先行发生原则，“i=1”的结果可以被观察到；二是线程C还没“登场”，线程A操作结束之后没有其他线程<br>会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B<br>观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。</p>
<h3 id="先行发生原则（happen-before）"><a href="#先行发生原则（happen-before）" class="headerlink" title="先行发生原则（happen-before）"></a>先行发生原则（happen-before）</h3><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。</p>
<ol>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（V olatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ol>
<ul>
<li>先行发生原则示例2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int value&#x3D;0；</span><br><span class="line">pubilc void setValue（int value）&#123;</span><br><span class="line">this.value&#x3D;value；</span><br><span class="line">&#125;</span><br><span class="line">public int getValue（）&#123;</span><br><span class="line">return value；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了“setValue（1）”，然后线程B调用了同一个对象的“getValue（）”，那么线程B收到的返回值是什么？</p>
<p>我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所<br>以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中“getValue（）”方法的<br>返回结果，换句话说，这里面的操作不是线程安全的。</p>
<p>一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢？很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的“指令重排序”</p>
<ul>
<li>先行发生原则示例3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下操作在同一个线程中执行</span><br><span class="line">int i&#x3D;1；</span><br><span class="line">int j&#x3D;2；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两条赋值语句在同一个线程之中，根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是“int j=2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。</p>
<h3 id="先行原则与先行发生规则的关系"><a href="#先行原则与先行发生规则的关系" class="headerlink" title="先行原则与先行发生规则的关系"></a>先行原则与先行发生规则的关系</h3><p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）</p>
<ul>
<li>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</li>
</ul>
<h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p>
<h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><p>用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，<br>也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。</p>
<p>使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何<br>将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因而使用用户线程实现的程序一般都比较复杂 ，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。</p>
<h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，<br>并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。</p>
<h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative  Threads-Scheduling）和抢占式线程调度（Preemptive  Threads-Scheduling）。</p>
<ul>
<li>协同式线程调度</li>
</ul>
<p>使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可<br>知的，所以没有什么线程同步的问题。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
<ul>
<li>抢占式线程调度</li>
</ul>
<p>使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield（）可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是<br>系统可控的，也不会有一个线程导致整个进程阻塞的问题，10个级别的线程优先级可以使得系统给线程尽可能的多分配时间。</p>
<p>线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态。</li>
<li>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒</li>
<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><img src="/images/jvm/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p>
<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种处理问题的角度称为面向过程的编程思想；</p>
<p>面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果一段代码在多线程的环境中运行和单线程运行的结果是一致的，那么这段代码是线程安全的。</p>
<p>或者说代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。</p>
<h2 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h2><p>Java语言中各种操作共享的数据分为以下5类:不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<ul>
<li>不可变</li>
</ul>
<p>不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施</p>
<p>Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，如果读者还没想明白这句话，不妨想一想java.lang.String类的对<br>象，它是一个典型的不可变对象，我们调用它的substring（）、replace（）和concat（）这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的<br>变量都声明为final，这样在构造函数结束之后，它就是不可变的</p>
<ul>
<li>绝对线程安全</li>
</ul>
<p>在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过Java API中一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。</p>
<p>如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add（）、get（）和size（）这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了</p>
<ul>
<li>相对线程安全</li>
</ul>
<p>相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection（）方法包装的集合等。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><ul>
<li>互斥同步</li>
</ul>
<p>互斥同步（Mutual Exclusion＆Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，<br>使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（CriticalSection）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
<p>synchronized实现互斥同步，该关键字在经过同步狗会形成形成monitorenter和monitorexit这两个字节码指令，这两个执行需要reference参数指明锁的对象。如果指明了reference，就是对象的reference，没有的话就是对象实例或者class对象</p>
<p>synchronized支持可重入锁，防止自己锁住自己。虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程</p>
<p>或者使用重入锁（ReentrantLock）来实现同步有三个更高级的特性：</p>
<ul>
<li>ReentrantLock锁的特点</li>
</ul>
<p>等待可中断：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</p>
<p>公平锁：指在多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的</p>
<p>锁可以绑定多个条件：</p>
<p>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可</p>
<ul>
<li>非阻塞式同步</li>
</ul>
<p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步</p>
<p>基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步</p>
<p>CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static AtomicInteger atomicInteger &#x3D;new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    while (Thread.activeCount()&gt;1)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(atomicInteger);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>incrementAndGet 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*Atomically increment by one the current value.</span><br><span class="line">*@return the updated value</span><br><span class="line">*&#x2F;</span><br><span class="line">public final int incrementAndGet（）&#123;</span><br><span class="line">for（；）&#123;</span><br><span class="line">int current&#x3D;get（）；</span><br><span class="line">int next&#x3D;current+1；</span><br><span class="line">if（compareAndSet（current,next））</span><br><span class="line">return next；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">incrementAndGet（）方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给</span><br><span class="line">自己。如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环</span><br><span class="line">进行下一次操作，直到设置成功为止</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ABA問題.加版本號。</p>
<p>ThreadLocal對象實現縣城同步。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>锁优化技术，如适应性自旋（Adaptive  Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成(因为用户态与内核态都有各自专用的内存空间，专用的寄存器等)，这些操作给系统的并发性能带来了很大的压力。而共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。<br>可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>jdk1.6版本后，自旋锁是默认开启的，自旋的次数是10次。自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。StringBuffer对象的append方法是一个锁消除的例子。</p>
<p>锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况是正确的，但是如果一系列的连续操作都对同一个对象反复枷锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>这样的情况下需要加大同步代码块的范围，只需要在最外面加一次锁就可以了，这就属于锁粗化。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量</p>
<p>轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的<br>是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和<br>64bit，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。</p>
<p><img src="/images/jvm/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4Mark-Word.png" alt="HotSpot虚拟机对象头Mark-Word"></p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，<br>除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
<p>偏向锁意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁<br>的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作</p>
<p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。</p>
<p><img src="/images/jvm/%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%B4%A2%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1Mark-Word%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="偏向锁-轻量级索的状态转化以及对象Mark-Word的关系"></p>
<p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（TradeOff）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总<br>是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenwj1103.github.io/2018-10-28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-10-28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">深入理解java虚拟机-性能监控与故障处理工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-28 15:10:03" itemprop="dateCreated datePublished" datetime="2018-10-28T15:10:03+08:00">2018-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jdk的性能监控和故障处理工具如下图：</p>
<p><img src="/images/jvm/JDK%E7%9A%84%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.png" alt="JDK的故障处理工具"></p>
<p><a target="_blank" rel="noopener" href="http://www.51testing.com/html/92/77492-203728.html">jstat工具</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baihuitestsoftware/articles/6405580.html">jconsole工具使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kongzhongqijing/articles/3625340.html">jvisualvm 工具使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kongzhongqijing/articles/3630264.html">jstack工具使用</a></p>
<h1 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h1><h2 id="JPS-名称"><a href="#JPS-名称" class="headerlink" title="JPS 名称:"></a>JPS 名称:</h2><p>jps - Java Virtual Machine Process Status Tool</p>
<h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: jps [options] [hostid]</span><br><span class="line">              options:命令选项，用来对输出格式进行控制</span><br><span class="line">              hostid:指定特定主机，可以是ip地址和域名, 也可以指定具体协议，端口。</span><br></pre></td></tr></table></figure>
<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>jps是用于查看有权访问的hotspot虚拟机的进程. 当未指定hostid时，默认查看本机jvm进程，否者查看指定的hostid机器上的jvm进程，此时hostid所指机器必须开启jstatd服务。 jps可以列出jvm进程lvmid，主类类名，main函数参数, jvm参数，jar名称等信息。</p>
<p><img src="/images/jvm/JPS%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E9%80%89%E9%A1%B9.png" alt="JPS工具的主要选项"></p>
<p>例子：</p>
<ul>
<li>没添加option的时候，默认列出VM标示符号和简单的class或jar名称.如下:</li>
</ul>
<p><img src="/images/jvm/jps%E6%97%A0%E5%8F%82%E6%95%B0.png" alt="jps无参数"></p>
<ul>
<li>-q 仅仅显示VM 标示，不显示jar,class, main参数等信息.</li>
</ul>
<p><img src="/images/jvm/jps-q%E5%91%BD%E4%BB%A4.png" alt="jps-q命令"></p>
<ul>
<li>-m 输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数</li>
</ul>
<p><img src="/images/jvm/jps-m%E7%9A%84%E5%91%BD%E4%BB%A4.png" alt="jps-m的命令"></p>
<ul>
<li>-l: 输出应用程序主类完整package名称或jar完整名称.</li>
</ul>
<p><img src="/images/jvm/jps-m%E5%91%BD%E4%BB%A4.png" alt="jps-m命令"></p>
<ul>
<li>-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数</li>
</ul>
<p><img src="/images/jvm/jps-v%E5%91%BD%E4%BB%A4.png" alt="jps-v命令"></p>
<h1 id="jstat-监视JVM内存工具"><a href="#jstat-监视JVM内存工具" class="headerlink" title="jstat 监视JVM内存工具"></a>jstat 监视JVM内存工具</h1><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程 [1] 虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
<p><img src="/images/jvm/jstat%E5%B7%A5%E5%85%B7%E7%9A%84%E7%9F%A5%E8%B6%B3%E8%A6%81%E9%80%89%E9%A1%B9.png" alt="jstat工具的知足要选项"></p>
<h2 id="语法结构："><a href="#语法结构：" class="headerlink" title="语法结构："></a>语法结构：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line">       </span><br><span class="line">参数解释</span><br><span class="line"></span><br><span class="line">Options — 选项，我们一般使用 -gcutil 查看gc情况</span><br><span class="line">vmid    — VM的进程号，即当前运行的java进程号</span><br><span class="line">interval– 间隔时间，单位为秒或者毫秒</span><br><span class="line">count   — 打印次数，如果缺省则打印无数次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果项解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S0  — Heap上的 Survivor space 0 区已使用空间的百分比</span><br><span class="line">S1  — Heap上的 Survivor space 1 区已使用空间的百分比</span><br><span class="line">E   — Heap上的 Eden space 区已使用空间的百分比</span><br><span class="line">O   — Heap上的 Old space 区已使用空间的百分比</span><br><span class="line">P   — Perm space 区已使用空间的百分比</span><br><span class="line">YGC — 从应用程序启动到采样时发生 Young GC 的次数</span><br><span class="line">YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)</span><br><span class="line">FGC — 从应用程序启动到采样时发生 Full GC 的次数</span><br><span class="line">FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)</span><br><span class="line">GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用实例1：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcutil 25444</span><br><span class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 11.63   0.00   56.46  66.92  98.49 162    0.248    6      0.331    0.579</span><br></pre></td></tr></table></figure>
<ul>
<li>使用实例2  jstat -gcutil</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(25444是java的进程号，ps -ef | grep java)</span><br><span class="line"></span><br><span class="line">[root@localhost bin]# jstat -gcutil 25444 1000 5</span><br><span class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</span><br><span class="line"> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</span><br><span class="line"> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</span><br><span class="line"> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</span><br><span class="line"> 73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</span><br><span class="line"></span><br><span class="line">我们可以看到，5次young gc之后，垃圾内存被从Eden space区(E)放入了Old space区(O)，并引起了百分比的变化，</span><br><span class="line">导致Survivor space使用的百分比从73.54%(S0)降到0%(S1)。有效释放了内存空间。绿框中，我们可以看到，一次full </span><br><span class="line">gc之后，Old space区(O)的内存被回收，从99.05%降到67.52%。图中同时打印了young gc和full gc的总次数、总耗时。</span><br><span class="line">而，每次young gc消耗的时间，可以用相间隔的两行YGCT相减得到。每次full gc消耗的时间，可以用相隔的两行FGCT相减得到。</span><br><span class="line">例如红框中表示的第一行、第二行之间发生了1次young gc，消耗的时间为0.252-0.252＝0.0秒。常驻内存区(P)的使用率，</span><br><span class="line">始终停留在98.49%左右，说明常驻内存没有突变，比较正常。如果young gc和full gc能够正常发生，而且都能有效回收内存，</span><br><span class="line">常驻内存区变化不明显，则说明java内存释放情况正常，垃圾回收及时，java内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</span><br><span class="line"></span><br><span class="line">GCT 是YGCT 和FGCT的时间总和。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例3 jstat -class pid</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstat -class pid:显示加载class的数量，及所占空间等信息。</span><br><span class="line"></span><br><span class="line">[root@localhost bin]# ps -ef | grep java</span><br><span class="line">root     25917     1  2 23:23 pts&#x2F;2    00:00:05 &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;bin&#x2F;java -Djava.endorsed.dirs&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;common&#x2F;endorsed -classpath &#x2F;usr&#x2F;local&#x2F;jdk1.5&#x2F;lib&#x2F;tools.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;bootstrap.jar:&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;bin&#x2F;commons-logging-api.jar -Dcatalina.base&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Dcatalina.home&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30 -Djava.io.tmpdir&#x3D;&#x2F;usr&#x2F;local&#x2F;jakarta-tomcat-5.0.30&#x2F;temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例4   jstat -compiler pid:显示VM实时编译的数量等信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line"></span><br><span class="line">     768      0       0   0.70            0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例5  jstat –gccapacity :可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，</li>
</ul>
<p>如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。</p>
<p>[root@localhost bin]# jstat -gccapacity 25917</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NGCMN       640.0</span><br><span class="line">NGCMX       4992.0</span><br><span class="line">NGC         832.0</span><br><span class="line">S0C         64.0</span><br><span class="line">S1C         64.0</span><br><span class="line">EC          704.0</span><br><span class="line">OGCMN       1408.0</span><br><span class="line">OGCMX       60544.0</span><br><span class="line">OGC         9504.0</span><br><span class="line">OC          9504.0                  OC是old内纯的占用量</span><br><span class="line">PGCMN       8192.0                  PGCMN显示的是最小perm的内存使用量</span><br><span class="line">PGCMX       65536.0                 PGCMX显示的是perm的内存最大使用量</span><br><span class="line">PGC         12800.0                 PGC是当前新生成的perm内存占用量</span><br><span class="line">PC          12800.0                 PC是但前perm内存占用量</span><br><span class="line">YGC         164</span><br><span class="line">FGC         6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用实例6 jstat -gcnew pid: new对象的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcnew 25917</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line"> 64.0   64.0   47.4   0.0   2  15   32.0    704.0    145.7    168    0.254</span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例7 jstat -gcnewcapacity pid: new对象的信息及其占用量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcnewcapacity 25917</span><br><span class="line"> NGCMN  NGCMX   NGC   S0CMX  S0C   S1CMX  S1C   ECMX    EC      YGC   FGC</span><br><span class="line">640.0  4992.0  832.0 64.0   448.0 448.0  64.0   4096.0  704.0  168     6</span><br></pre></td></tr></table></figure>


<ul>
<li>使用实例8 jstat -gcold pid: old对象的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcold 25917</span><br><span class="line">   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用实例9 jstat -gcoldcapacity pid:old对象的信息及其占用量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcoldcapacity 25917</span><br><span class="line">OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591</span><br></pre></td></tr></table></figure>


<ul>
<li>使用实例10 jstat -gcpermcapacity pid: perm对象的信息及其占用量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -gcpermcapacity 25917</span><br><span class="line">PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</span><br><span class="line">8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591</span><br></pre></td></tr></table></figure>


<ul>
<li>使用实例11 jstat -printcompilation pid:当前VM执行的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# jstat -printcompilation -h3  25917 1000 5</span><br><span class="line"></span><br><span class="line">每1000毫秒打印一次，一共打印5次，还可以加上-h3每三行显示一下标题。</span><br><span class="line"></span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</span><br><span class="line">     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</span><br><span class="line">     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</span><br><span class="line">     788     73    1 java&#x2F;io&#x2F;File &lt;init&gt;</span><br></pre></td></tr></table></figure>


<h1 id="jinfo。查看和修改JVM运行参数"><a href="#jinfo。查看和修改JVM运行参数" class="headerlink" title="jinfo。查看和修改JVM运行参数"></a>jinfo。查看和修改JVM运行参数</h1><p>jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参<br>数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK  1.6或以上版本的话，使用java-XX：+PrintFlagsFinal查看参数默认值也是一个很好的选<br>择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties（）的内容打印出来。JDK  1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用-flag[+|-]name或者-flag  name=value修改一部分运行期可写的虚拟机参数值。<br>JDK 1.6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选项</p>
<p>执行样例：查询CMSInitiatingOccupancyFraction参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag CMSInitiatingOccupancyFration 1444</span><br><span class="line">-XX: CMSInitiatingOccupancyFration&#x3D;95</span><br></pre></td></tr></table></figure>
<h1 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h1><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/myna/p/7573843.html">引用</a></p>
<p><img src="/images/jvm/jmap%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E9%80%89%E9%A1%B9.png" alt="jmap工具的主要选项"></p>
<p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如<br>在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件</p>
<h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] pid</span><br><span class="line">jmap [ option ] executable core</span><br><span class="line">jmap [ option ] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">option：选项参数，不可同时使用多个选项参数</span><br><span class="line">pid：java进程id，命令ps -ef | grep java获取</span><br><span class="line">executable：产生核心dump的java可执行文件</span><br><span class="line">core：需要打印配置信息的核心文件</span><br><span class="line">remote-hostname-or-ip：远程调试的主机名或ip</span><br><span class="line">server-id：可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器</span><br></pre></td></tr></table></figure>

<h2 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat :Java堆内存的永久保存区域的类加载器的统计信息</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">dump : 生成堆转储快照</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>dump</li>
</ul>
<p>dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jdk1.7.0_79]# jmap -dump:live,format&#x3D;b,file&#x3D;dump.hprof 24971</span><br><span class="line">Dumping heap to &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.7.0_79&#x2F;dump.hprof ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>heap</li>
</ul>
<p>打印heap的概要信息，GC使用的算法，heap的配置及使用情况，可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jdk1.7.0_79]# jmap -heap 24971</span><br><span class="line">Attaching to process ID 24971, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line"> </span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"> </span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio &#x3D; 0</span><br><span class="line">   MaxHeapFreeRatio &#x3D; 100</span><br><span class="line">   MaxHeapSize      &#x3D; 4146069504 (3954.0MB)</span><br><span class="line">   NewSize          &#x3D; 1310720 (1.25MB)</span><br><span class="line">   MaxNewSize       &#x3D; 17592186044415 MB</span><br><span class="line">   OldSize          &#x3D; 5439488 (5.1875MB)</span><br><span class="line">   NewRatio         &#x3D; 2</span><br><span class="line">   SurvivorRatio    &#x3D; 8</span><br><span class="line">   PermSize         &#x3D; 21757952 (20.75MB)</span><br><span class="line">   MaxPermSize      &#x3D; 85983232 (82.0MB)</span><br><span class="line">   G1HeapRegionSize &#x3D; 0 (0.0MB)</span><br><span class="line"> </span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity &#x3D; 517996544 (494.0MB)</span><br><span class="line">   used     &#x3D; 151567520 (144.54605102539062MB)</span><br><span class="line">   free     &#x3D; 366429024 (349.4539489746094MB)</span><br><span class="line">   29.26033421566612% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity &#x3D; 41943040 (40.0MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 41943040 (40.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity &#x3D; 40370176 (38.5MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 40370176 (38.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity &#x3D; 115343360 (110.0MB)</span><br><span class="line">   used     &#x3D; 32927184 (31.401809692382812MB)</span><br><span class="line">   free     &#x3D; 82416176 (78.59819030761719MB)</span><br><span class="line">   28.54709972034801% used</span><br><span class="line">PS Perm Generation</span><br><span class="line">   capacity &#x3D; 85983232 (82.0MB)</span><br><span class="line">   used     &#x3D; 54701200 (52.16712951660156MB)</span><br><span class="line">   free     &#x3D; 31282032 (29.832870483398438MB)</span><br><span class="line">   63.6184506300019% used</span><br><span class="line"> </span><br><span class="line">20822 interned Strings occupying 2441752 bytes.</span><br></pre></td></tr></table></figure>
<ul>
<li>finalizerinfo</li>
</ul>
<p>打印等待回收的对象信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jdk1.7.0_79]# jmap -finalizerinfo 24971</span><br><span class="line">Attaching to process ID 24971, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line">Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure>
<p>Number of objects pending for finalization: 0 说明当前F-QUEUE队列中并没有等待Fializer线程执行finalizer方法的对象</p>
<ul>
<li>histo</li>
</ul>
<p>打印堆的对象统计，包括对象数、内存大小等等。jmap -histo:live 这个命令执行，JVM会先触发gc，然后再统计信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jdk1.7.0_79]# jmap -histo:live 24971 | more</span><br><span class="line"> </span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        100134       14622728  &lt;constMethodKlass&gt;</span><br><span class="line">   2:        100134       12830128  &lt;methodKlass&gt;</span><br><span class="line">   3:         88438       12708392  [C</span><br><span class="line">   4:          8271       10163584  &lt;constantPoolKlass&gt;</span><br><span class="line">   5:         27806        9115784  [B</span><br><span class="line">   6:          8271        6225312  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          6830        5632192  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         86717        2081208  java.lang.String</span><br><span class="line">   9:          2264        1311720  &lt;methodDataKlass&gt;</span><br><span class="line">  10:         10880         870400  java.lang.reflect.Method</span><br><span class="line">  11:          8987         869888  java.lang.Class</span><br><span class="line">  12:         13330         747264  [[I</span><br><span class="line">  13:         11808         733872  [S</span><br><span class="line">  14:         20110         643520  java.util.concurrent.ConcurrentHashMap$HashEntry</span><br><span class="line">  15:         18574         594368  java.util.HashMap$Entry</span><br><span class="line">  16:          3668         504592  [Ljava.util.HashMap$Entry;</span><br><span class="line">  17:         30698         491168  java.lang.Integer</span><br><span class="line">  18:          2247         486864  [I</span><br><span class="line">  19:          7486         479104  java.net.URL</span><br><span class="line">  20:          8032         453616  [Ljava.lang.Object;</span><br><span class="line">  21:         10259         410360  java.util.LinkedHashMap$Entry</span><br><span class="line">  22:           699         380256  &lt;objArrayKlassKlass&gt;</span><br><span class="line">  23:          5782         277536  org.apache.catalina.loader.ResourceEntry</span><br><span class="line">  24:          8327         266464  java.lang.ref.WeakReference</span><br><span class="line">  25:          2374         207928  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</span><br><span class="line">  26:          3440         192640  java.util.LinkedHashMap</span><br><span class="line">  27:          4779         191160  java.lang.ref.SoftReference</span><br><span class="line">  28:          3576         171648  java.util.HashMap</span><br><span class="line">  29:         10080         161280  java.lang.Object</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jmap -histo:live 24971 | grep com.yuhuo 查询类名包含com.yuhuo的信息</p>
<p>jmap -histo:live 24971 | grep com.yuhuo &gt; histo.txt 保存信息到histo.txt文件</p>
<p><img src="/images/jvm/jmap%E8%BE%93%E5%87%BA%E4%B8%ADclass-name%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="jmap输出中class-name非自定义类的说明"></p>
<ul>
<li>permstat</li>
</ul>
<p>打印Java堆内存的永久区的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jdk1.7.0_79]# jmap -permstat 24971</span><br><span class="line">Attaching to process ID 24971, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness....................................................liveness analysis may be inaccurate ...</span><br><span class="line">class_loader    classes bytes   parent_loader   alive?  type</span><br><span class="line"> </span><br><span class="line">&lt;bootstrap&gt;   3034    18149440      null      live    &lt;internal&gt;</span><br><span class="line">0x000000070a88fbb8  1   3048      null      dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070a914860  1   3064    0x0000000709035198  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070a9fc320  1   3056    0x0000000709035198  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070adcb4c8  1   3064    0x0000000709035198  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070a913760  1   1888    0x0000000709035198  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x0000000709f3fd40  1   3032      null      dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070923ba78  1   3088    0x0000000709035260  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070a88fff8  1   3048      null      dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line">0x000000070adcbc58  1   1888    0x0000000709035198  dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000703c50b58</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h1><p>jstack（Stack  Trace  for  Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈<br>的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿<br>的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mr__fang/article/details/68496248">使用jstack精确找到异常代码</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kongzhongqijing/articles/3630264.html">jstack 工具使用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yaowj2/article/category/855894">性能调优</a></p>
<h1 id="JConsole：Java监视与管理控制台-虚拟机监控工具"><a href="#JConsole：Java监视与管理控制台-虚拟机监控工具" class="headerlink" title="JConsole：Java监视与管理控制台 虚拟机监控工具"></a>JConsole：Java监视与管理控制台 虚拟机监控工具</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>通过JDK/bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，不需要用户自己再使用jps来查询了</p>
<h1 id="VisualVM-多合一故障处理工具"><a href="#VisualVM-多合一故障处理工具" class="headerlink" title="VisualVM 多合一故障处理工具"></a>VisualVM 多合一故障处理工具</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈伟杰"
      src="/images/favicon.ico">
  <p class="site-author-name" itemprop="name">陈伟杰</p>
  <div class="site-description" itemprop="description">学习，坚持。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenwj1103" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenwj1103" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈伟杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">638k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
