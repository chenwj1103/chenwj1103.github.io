<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.chenwj.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习，坚持。">
<meta property="og:type" content="website">
<meta property="og:title" content="茄子的博客">
<meta property="og:url" content="http://www.chenwj.cn/page/5/index.html">
<meta property="og:site_name" content="茄子的博客">
<meta property="og:description" content="学习，坚持。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈伟杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.chenwj.cn/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>茄子的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="茄子的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茄子的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">74</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-05-21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E6%A0%B8%E5%BF%83-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-05-21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E6%A0%B8%E5%BF%83-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程编程技术核心-单例模式与多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-21 23:27:40" itemprop="dateCreated datePublished" datetime="2018-05-21T23:27:40+08:00">2018-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>饿汉模式就是使用类的时候已经将对象创建完毕，常见的实现办法就是直接new实例化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 饿汉模式</span><br><span class="line"> *</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-21 23:31</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; new MyObject();</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;此代码版本为立即加载，此代码的缺点是不能有其他实例变量</span><br><span class="line">        &#x2F;&#x2F;因为getInstance()没有同步，所以有可能出现线程安全的问题</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>先声明不实例化，只有在调用的时候才实例化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-21 23:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;懒汉模式，在多线程的情况下会出现同步问题。</span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (myObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                myObject &#x3D; new MyObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉模式2"><a href="#懒汉模式2" class="headerlink" title="懒汉模式2"></a>懒汉模式2</h2><p>在整个方法上加synchronized关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-21 23:48</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;整个方法上锁，同步方法的效率太低了</span><br><span class="line">    synchronized public static MyObject getInstance() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (myObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                myObject &#x3D; new MyObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉模式3"><a href="#懒汉模式3" class="headerlink" title="懒汉模式3"></a>懒汉模式3</h2><p>方法中所有代码都上锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-21 23:54</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块 getInstance方法中的所有代码都上锁，这样做也会降低运行效率</span><br><span class="line">        synchronized (MyObject.class) &#123;</span><br><span class="line">            if (myObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                myObject &#x3D; new MyObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉模式4"><a href="#懒汉模式4" class="headerlink" title="懒汉模式4"></a>懒汉模式4</h2><p>方法中部分代码上锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-22 00:01</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;虽然对实例化对象的关键代码进行了同步，从代码结构上看效率得到了提升，但是无法解决多线程安全的问题。</span><br><span class="line">    &#x2F;&#x2F;同时又多个线程访问if (myObject &#x3D;&#x3D; null) ，得到的结果可能不一样。</span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        if (myObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (MyObject.class) &#123;</span><br><span class="line">                myObject &#x3D; new MyObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉模式5-双检查锁机制，既保证了同步代码的异步执行，有保证了单例的效果。"><a href="#懒汉模式5-双检查锁机制，既保证了同步代码的异步执行，有保证了单例的效果。" class="headerlink" title="懒汉模式5 双检查锁机制，既保证了同步代码的异步执行，有保证了单例的效果。"></a>懒汉模式5 双检查锁机制，既保证了同步代码的异步执行，有保证了单例的效果。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-22 00:14</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用DCL双检查锁机制，既保证了同步代码的异步执行，又保证了单例的效果。</span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        if (myObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (MyObject.class) &#123;</span><br><span class="line">                myObject &#x3D; new MyObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-22 00:21</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;静态内部类</span><br><span class="line">    private static class MyObjectHandler &#123;</span><br><span class="line">        private static MyObject myObject &#x3D; new MyObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        return MyObjectHandler.myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="静态代码块实现单例"><a href="#静态代码块实现单例" class="headerlink" title="静态代码块实现单例"></a>静态代码块实现单例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.api.util.thread.study.chapter6.singleton8;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-22 00:27</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private static MyObject myObject &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;静态代码块实现单例</span><br><span class="line">    static &#123;</span><br><span class="line">        myObject &#x3D; new MyObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyObject getInstance() &#123;</span><br><span class="line">        return myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-05-16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-LOCK%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-05-16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-LOCK%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">多线程编程核心技术-LOCK的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-16 23:42:02" itemprop="dateCreated datePublished" datetime="2018-05-16T23:42:02+08:00">2018-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ReentrantLock的使用"><a href="#ReentrantLock的使用" class="headerlink" title="ReentrantLock的使用"></a>ReentrantLock的使用</h1><p>synchronized关键字来实现线程间同步互斥，在jdk1.5之后增加的ReentrantLock锁也能达到同样的效果。而且增加了嗅探锁定，多路分支通知功能，而且比synchronized更加灵活。</p>
<h2 id="conditions实现等待通知"><a href="#conditions实现等待通知" class="headerlink" title="conditions实现等待通知"></a>conditions实现等待通知</h2><p> synchronized与wait()和notify()、notifyAll() 方法相结合实现等待通知模式，ReentrantLock锁借助于Condition对象也是可以实现多路通知的功能。</p>
<p> 实现多路通知的功能，也就是一个Lock对象中可以创建多个Condition实例，线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。</p>
<p> 而notify()方法进行通知时，被通知的线程却是由JVM随机选择的。而synchronized就相当于整个LOCK对象中只有一个单一的Condition对象，所有的线程都注册在一个对象身上，线程开始notifyAll()时，需要通知所有waiting线程，没有选择权，会出现相当大的效率问题。</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出的顺序。而非公平锁就是一种获取锁的抢占式机制，是随机获得锁的。某些线程是一直拿不到锁的，所以是不公平的锁了。</p>
<h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><ul>
<li>ReentrantLock(boolean) 创建是否公平的锁：ReentrantLock(boolean) 是创建是否公平的锁；</li>
<li>lock.getHoldCount()  获取当前线程调用lock的次数； </li>
<li>lock.getQueenLength() 获取正等待获取此锁定的线程估计数 lock.getQueenLength()</li>
<li>getWaitQueueLength(Condition condition) 获取等待与此锁定相关的给定条件Condition的线程估计数，比如有5个线程，每个线程都执行了同一个Condition对象的await()方法，调用getWaitQueueLength(Condition condition) 返回的int值是5 </li>
<li>lock.hasQueuedThread(Thread thread)  查询指定的线程是否正在等待获取此锁定。</li>
<li>lock.hasQueuedThreads() 的作用是查询是否有线程正在等待获取此锁定。</li>
<li>boolean hasWaiters(Condition condition) 查询是否有线程正在等待与此锁定有关的condition条件。</li>
<li>boolean isFair() 判断是不是公平锁</li>
<li>boolean isHeldByCurrentThread()查询当前线程是否保持此锁</li>
<li>boolean isLocked()的作用是查询此锁定是否由任意线程保持</li>
<li>void lockInterruptibly 如果当前线程未被中断则获取锁定，如果已经被中断则出现异常。</li>
<li>boolean tryLock()的作用，仅当在被调用时锁定未被另一个线程保持的情况下，才获取该锁定。</li>
<li>boolean tryLock(long timeout，TimeUnit unit)的作用是，如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。</li>
<li>awaitUninterruptibly() 调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。调用该方法后，结束等待的唯一方法是其它线程调用该条件对象的signal()或signalALL()方法。等待过程中如果当前线程被中断，该方法仍然会继续等待，同时保留该线程的中断状态。</li>
</ul>
<h1 id="ReentrantReadWriteLock的使用"><a href="#ReentrantReadWriteLock的使用" class="headerlink" title="ReentrantReadWriteLock的使用"></a>ReentrantReadWriteLock的使用</h1><p>类ReentrantLock 具有完全互斥排他的效果。同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务。保证了线程的安全性，但是效率非常低下。ReentrantReadWriteLock是一种读写锁。读写锁表示也有两个锁，一个是读操作相关的锁，称为共享锁；一个是和写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读写与写锁互斥，写锁与写锁互斥。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-04-22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-04-22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">多线程变成核心技术-线程间通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-22 23:58:43" itemprop="dateCreated datePublished" datetime="2018-04-22T23:58:43+08:00">2018-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="等待和通知机制"><a href="#等待和通知机制" class="headerlink" title="等待和通知机制"></a>等待和通知机制</h1><h2 id="不使用等待通知机制实现线程间通信"><a href="#不使用等待通知机制实现线程间通信" class="headerlink" title="不使用等待通知机制实现线程间通信"></a>不使用等待通知机制实现线程间通信</h2><p>使用sleep()和while死循环实现多个线程间通信</p>
<h2 id="等待和通知机制-1"><a href="#等待和通知机制-1" class="headerlink" title="等待和通知机制"></a>等待和通知机制</h2><p>多个线程之间实现通信，可以采用多个线程共享变量，但那种通信机制不是那种等待通知，两个线程完全是主动式的读取一个共享变量。在花费读取时间的基础上，得到值不是自己想要的，所以需要等待通知机制来满足上面的需求。</p>
<h3 id="等待通知机制的实现"><a href="#等待通知机制的实现" class="headerlink" title="等待通知机制的实现"></a>等待通知机制的实现</h3><p>1.wait方法</p>
<p>方法wait()的作用是使当前的执行代码的线程进行等待，wait()方法是object类的方法，该方法用来将当前线程置入“预执行队列”中。并且在wait()方法所在的代码出停止执行，直到接到通知或者被中断为止。在调用wait方法之前，线程必须获得该对象的对象级别的锁，即只能在同步方法或者同步块中调用wait方法，</p>
<p>在执行wait方法后，当前线程释放锁，在wait方法返回前，线程与其他线程竞争重新获得锁。如果调用wait方法时没有获得对象锁，则抛出一个异常。</p>
<p>2.notify方法</p>
<p>如果调用notify方法时，也必须在同步方法或者同步代码块中执行。即线程必须获得对象的对象级别锁。该方法来通知那些等待获得该对象的对象锁的其他线程。如果有多个线程，则线程规划器会挑选一个wait状态的线程，对其发出notify通知。</p>
<p>需要说明的是，notify方法执行后，当前线程不会立马释放对象的锁，呈wait状态的线程也并不会立马获取该对象锁，要等待notify方法线程将程序执行完，也就是退出synchronized代码块，当前线程才会释放锁。</p>
<p>当一个获得对象锁的wait线程运行完毕以后，它会释放掉对象锁。此时如果该对象没有再次使用notify语句，即便该对象已经空闲，其他wait状态的等待线程由于没有获得该对象的通知，还会继续处于阻塞在wait状态，直到这个对象发出notify或者notifyAll</p>
<p>3.两个方法的使用</p>
<p>notify和wait方法必须在被synchronized同步的object的临界区内.通过使用wait方法可以使得处于临界区内的线程进入等待状态,同时释放被同步对象的锁.而notify操作可以唤醒一个因调用wait方法而处于阻塞状态的线程,使其进入就绪状态.使其进入就绪状态.被重新唤醒的线程尝试获得临界区的控制权.</p>
<p>wait方法可以使得调用该方法的线程释放共享资源的锁.然后从运行状态退出.进入等待队列处于阻塞状态,直到被再次唤醒;</p>
<p>notify方法可以随机唤醒等待队列中等待同一资源的一个线程,是该线程退出等待队列,进入可运行状态;</p>
<p>notifyAll方法可以使得所有正在等待队列中的等待同一共享资源的全部线程从等待状态退出,进入可运行状态,优先级高的哪个先运行.</p>
<p>4.线程状态</p>
<p><img src="/images/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="线程的运行状态图"></p>
<p>每个锁对象都有两个队列,一个是就绪队列,一个是阻塞队列.就绪队列存储了将来要获得锁的线程.一个线程被欢喜过后,参会进入就绪队列,等待cpu的调度,反之,一个线程被wait后就会进入阻塞队列,等待下一次被唤醒.</p>
<p>5.wait()方法和sleep()方法</p>
<p>wait方法和sleep方法.wait方法释放锁,sleep方法不释放锁.notify方法也不释放锁.</p>
<p>6.interrupt方法遇到wait方法</p>
<p>当线程呈wait状态时,调用线程对象的interrupt方法,会出现interruptedException异常.</p>
<p>7.notify方法只通知一个线程</p>
<p>8.方法wait(long) 方法的功能是在等待某一时间内是否有线程对锁进行唤醒,如果超过这个时间则自动唤醒.</p>
<p>9.管道流用于在不同线程间传输数据,一个线程发送数据到输出管道,另一个线程从输入管道中读取数据.</p>
<p>pipedInputStream pipedOutPutStream pipedReader pipedWriter</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.执行完同步代码块就会释放对象的锁;<br>2.执行同步代码块的过程中,遇到异常而导致线程中止,锁也会释放;<br>3.执行同步代码块的过程中没执行额锁所属对象的wait方法,这个线程就会释放对象所,而此线程对象会进入线程等待池中,等待被唤醒.</p>
<h1 id="join方法的使用"><a href="#join方法的使用" class="headerlink" title="join方法的使用"></a>join方法的使用</h1><p>一个线程等待另一个想成运行完毕，然后才执行一些操作。此时需要使用join()方法，join方法的作用是等待想成对象销毁；</p>
<p><strong>当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.chen.api.util.thread.study.chapter3.join_test;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 方法join的作用是使所属的线程对象X正常执行run方法中的任务，而使当前线程Z进行无限制的阻塞，等待线程X销毁后在急需执行线程Z后的代码。</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @author :  chen weijie</span><br><span class="line"> * @Date: 2018-05-15 01:04</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Run2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int secondValue &#x3D; (int) (Math.random() * 10000);</span><br><span class="line">                    System.out.println(secondValue);</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(secondValue);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">            thread.join();</span><br><span class="line">            System.out.println(&quot;我想等待thread执行完毕才执行&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="join-long-和sleep-long-的区别"><a href="#join-long-和sleep-long-的区别" class="headerlink" title="join(long) 和sleep(long)的区别"></a>join(long) 和sleep(long)的区别</h2><p>join的功能内部是使用wait方法来实现的，所以join具有释放锁的特点，sleep方法不释放锁。</p>
<h1 id="ThreadLocal类的使用"><a href="#ThreadLocal类的使用" class="headerlink" title="ThreadLocal类的使用"></a>ThreadLocal类的使用</h1><p>所有线程可以通过使用同一个public static变量来共享一个变量，如果想实现每一个线程都有自己的共享变量就可以使用ThreadLocal来解决。</p>
<p>类ThreadLocal主要就是为每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>线程间的变量具有隔离性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-04-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-04-12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/" class="post-title-link" itemprop="url">多线程编程核心技术-对象及变量的并发访问</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-12 00:44:38" itemprop="dateCreated datePublished" datetime="2018-04-12T00:44:38+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="synchronize同步方法"><a href="#synchronize同步方法" class="headerlink" title="synchronize同步方法"></a>synchronize同步方法</h1><p>非线程安全其实是在多个线程对同一个对象中的实例变量进行并发访问的时候发生,产生的后果就是脏读,也就是被读到的数据是被更改过的.</p>
<p>线程安全就是获得实例变量的值时经过同步处理的,不会出现脏读的现象.</p>
<h2 id="方法内的变量为线程安全的"><a href="#方法内的变量为线程安全的" class="headerlink" title="方法内的变量为线程安全的"></a>方法内的变量为线程安全的</h2><p>非线程安全问题存在于实例变量,如果是方法内部的私有变量则不存在非线程安全问题.</p>
<h2 id="实例变量非线程安全"><a href="#实例变量非线程安全" class="headerlink" title="实例变量非线程安全"></a>实例变量非线程安全</h2><p>多个线程共同访问一个对象中的实例变量,则可能出现非线程安全问题.如果对象仅有一个实例变量,则可能出现覆盖的情况</p>
<p>在两个线程访问同一个对象中的同步方法时,一定是线程安全的.</p>
<h2 id="多个对象多个锁"><a href="#多个对象多个锁" class="headerlink" title="多个对象多个锁"></a>多个对象多个锁</h2><p>关键字synchronize取得的锁都是对象锁,而不是把一段代码或者方法当做锁,哪个线程先执行synchronize关键字的方法,哪个线程就持有该方法所持有该方法所属对象的锁LOCK,其它线程只能等待,前提是,多个线程访问的是同一个对象.</p>
<p>如果多个线程访问的时多个对象,JVM会创建多个锁.</p>
<h2 id="synchronize方法与锁对象"><a href="#synchronize方法与锁对象" class="headerlink" title="synchronize方法与锁对象"></a>synchronize方法与锁对象</h2><p>调用关键字synchronize声明的方法一定时排队运行的,只有共享的资源的读写才需要同步化.</p>
<p>结论:</p>
<p>A线程先持有object对象的lock锁,B线程可以异步的调用object对象中的非synchronize类型的方法;</p>
<p>A线程先持有object对象的lock锁,B线程如果在这是调用object对象中synchronize类型的方法 需要等待,也就是同步</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>虽然在赋值时进行了同步,但在取值时有可能出现一些意想不到的意外,这就是脏读.发生脏读的情况就是在读取实例变量时,此值已经被其它线程进行了修改.</p>
<p>结论:</p>
<p>当A线程调用anyObject对象加synchronized关键字的X方法时,A线程就获得了X的方法锁.更准确的说,是获得了对象的锁,所以其它线程必须等待A线程执行完毕才可以调用X方法,但B线程可以调用其它的非synchronized同步方法;</p>
<p>当A线程调用anyObject对象加入synchronized关键字的方法X时,A线程就获得了X方法所在对象的锁,而B线程如果调用synchronized关键字修饰的非X方法时,必须等待A线程将X方法执行完.也就是释放对象锁后才可以调用.</p>
<p>脏读一定出现在操作实例变量的情况下,也就是不同线程争抢实例变量的结果.</p>
<h2 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h2><p>关键字synchronized拥有锁重入的功能,当一个线程得到一个对象锁之后,再次请求此对象锁时,是可以再次获得该对象的锁的.</p>
<p>可重入锁的概念是:自己可以再次获取自己的内部锁,比如一条线程获得了某个对象的锁,此时这个对象所还没有释放,当其再次获取这个对象锁的时候,还是可以获得的,如果不可锁重入的话,就会造成死锁.</p>
<p>可重入锁时支持在父子类继承的环境中的.</p>
<h2 id="出现异常-锁自动释放"><a href="#出现异常-锁自动释放" class="headerlink" title="出现异常,锁自动释放"></a>出现异常,锁自动释放</h2><p>当一个线程执行的代码出现异常时,其所持有的锁会自动释放.</p>
<h2 id="同步不具有继承性"><a href="#同步不具有继承性" class="headerlink" title="同步不具有继承性"></a>同步不具有继承性</h2><p>同步不可以继承</p>
<h1 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h1><p>用关键字synchronized声明方法在某些情况下时有弊端的,比如A线程调用B方法去执行一个长时间的任务,那么B线程必须等待比较长时间.这种情况下可以使用synchronized同步语句块来解决.</p>
<h2 id="用同步代码块解决同步方法的弊端"><a href="#用同步代码块解决同步方法的弊端" class="headerlink" title="用同步代码块解决同步方法的弊端"></a>用同步代码块解决同步方法的弊端</h2><p>可以使用synchronized代码块解决synchronized方法的弊端.</p>
<h2 id="一半异步-一半同步"><a href="#一半异步-一半同步" class="headerlink" title="一半异步,一半同步"></a>一半异步,一半同步</h2><p>不在synchronized块中就是异步执行,在synchronized块中就是同步执行.</p>
<h2 id="synchronized代码块间的同步性"><a href="#synchronized代码块间的同步性" class="headerlink" title="synchronized代码块间的同步性"></a>synchronized代码块间的同步性</h2><p>在使用同步synchronized(this)代码块时需要注意,当一个线程访问object的一个synchronized(this)同步代码块时.其它线程对同一个object中所有其它synchronized(this) 代码块的访问将被阻塞,这就说明synchronized使用的对象监视器时一个.</p>
<h2 id="验证synchronized-this-代码块时锁定当前对象的"><a href="#验证synchronized-this-代码块时锁定当前对象的" class="headerlink" title="验证synchronized(this) 代码块时锁定当前对象的"></a>验证synchronized(this) 代码块时锁定当前对象的</h2><p>和synchronized方法一样,synchronized(this)也是锁定当前对象的</p>
<h2 id="将任意对象作为对象监视器"><a href="#将任意对象作为对象监视器" class="headerlink" title="将任意对象作为对象监视器"></a>将任意对象作为对象监视器</h2><h3 id="synchronized代码块或者方法"><a href="#synchronized代码块或者方法" class="headerlink" title="synchronized代码块或者方法"></a>synchronized代码块或者方法</h3><p>多个线程调用同一个对象中的不同名称的synchronized同步方法或者synchronized(this)同步代码块时,调用的效果就是按顺序执行,也就是同步的,阻塞的.</p>
<p>这就是说synchronized同步方法或者同步代码块有两种作用:</p>
<ol>
<li><p>对其它的同步方法或者同步代码块调用呈阻塞状态;</p>
</li>
<li><p>同一时间只有一个线程可以执行synchronized同步方法或者同步代码块中的代码</p>
</li>
</ol>
<h3 id="synchronized-非this-同步代码块"><a href="#synchronized-非this-同步代码块" class="headerlink" title="synchronized(非this)同步代码块"></a>synchronized(非this)同步代码块</h3><p>除了以上说过的synchronized(this) 同步代码块,还可以使用任意对象作为对象监视器来实现同步的功能,这个任意对象大多数是实例变量或者方法的参数,使用格式为synchronized(非this对象)</p>
<ol>
<li><p>在多个线程持有对象监视器为同一个对象的前提下,同一时间只有一个线程可以执行synchronized(非this对象X)同步代码.</p>
</li>
<li><p>当持有对象监视器为同一个对象的前提下,同一时间只有一个线程可以执行synchronized(非this对象X)同步代码.</p>
</li>
</ol>
<h3 id="synchronized-非this-同步代码块的优点和注意事项"><a href="#synchronized-非this-同步代码块的优点和注意事项" class="headerlink" title="synchronized(非this)同步代码块的优点和注意事项"></a>synchronized(非this)同步代码块的优点和注意事项</h3><p>锁非this对象有一定的优点:如果一个类中有多个synchronized方法.这时虽然能实现同步,但会受到阻塞,所以影响运行效率两单如果使用同步代码块锁非this对象,则synchronized(非this)代码块中的程序与同步方法是异步的,不与其它锁this同步方法争抢this锁,则可以大大提高运行效率.</p>
<p>使用synchronized(非this对象X)同步代码块格式进行同步时,对象监视器必须是同一个对象.即synchronized(非this对象X)同步代码块,持有不同对象的监视器时异步的效果.</p>
<h3 id="使用synchronized-非this对象X-脏读问题"><a href="#使用synchronized-非this对象X-脏读问题" class="headerlink" title="使用synchronized(非this对象X)脏读问题"></a>使用synchronized(非this对象X)脏读问题</h3><p>使用synchronized(非this对象X) 同步代码块,格式也是可以解决脏读问题的.</p>
<p>多个线程调用同一个方法是随机的.</p>
<h3 id="synchronized-非this对象x"><a href="#synchronized-非this对象x" class="headerlink" title="synchronized(非this对象x)"></a>synchronized(非this对象x)</h3><p>synchronized(非this对象x)格式的写法是将X本身作为对象监视器,可以得出以下三种结论:</p>
<ol>
<li>当多个线程执行synchronized(x){}同步代码块时,呈现同步效果.</li>
<li>当其它线程执行x对象中的synchronized方法时呈现同步效果;</li>
<li>当其它线程执行x对象方法中synchronized(this)代码块时也呈现同步效果</li>
</ol>
<h3 id="静态同步synchronized方法与synchronized-class-代码块"><a href="#静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="静态同步synchronized方法与synchronized(class)代码块"></a>静态同步synchronized方法与synchronized(class)代码块</h3><p>synchronized关键字还可以应用在static静态方法上,如果这样写,就是对你当前的文件对应的class类进行持锁.</p>
<p>synchronized(class)代码块和synchronized static方法的作用一样.</p>
<h3 id="数据类型String的常量池特性"><a href="#数据类型String的常量池特性" class="headerlink" title="数据类型String的常量池特性"></a>数据类型String的常量池特性</h3><p>在JVM中具有String常量池缓存的功能  String a = “a” ; String b =”b”; a == b为true</p>
<p>将synchronized(string) 同步代码块与String联合使用的时候,要注意常量池以带来的一些例外;</p>
<h3 id="同步synchronized方法无线等待与解决"><a href="#同步synchronized方法无线等待与解决" class="headerlink" title="同步synchronized方法无线等待与解决"></a>同步synchronized方法无线等待与解决</h3><p>同步方法容易造成死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chen weijie</span><br><span class="line"> * @date 2018-04-17 11:56 PM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Service &#123;</span><br><span class="line"></span><br><span class="line">    synchronized public void methodA() &#123;</span><br><span class="line">        System.out.println(&quot;methodA begin..&quot;);</span><br><span class="line">        boolean isContinueRun &#x3D; true;</span><br><span class="line">        while (isContinueRun) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;methodA end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public void methodB() &#123;</span><br><span class="line">        System.out.println(&quot;methodB begin&quot;);</span><br><span class="line">        System.out.println(&quot;methodB end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多个线程在调用 methodA和methodB时,会由于一个线程在等待另一个线程而造成死锁.</p>
<h3 id="线程的死锁"><a href="#线程的死锁" class="headerlink" title="线程的死锁"></a>线程的死锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author chen weijie</span><br><span class="line"> * @date 2018-04-18 12:11 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DealThreadTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public String userName;</span><br><span class="line">    public Object lock1 &#x3D; new Object();</span><br><span class="line">    public Object lock2 &#x3D; new Object();</span><br><span class="line">    public void setFlag(String userName) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (userName.equals(&quot;a&quot;)) &#123;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.printf(&quot;userName&#x3D;&#x3D;&quot; + userName);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;按lock1---&gt;lock2的代码执行了..&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userName.equals(&quot;b&quot;)) &#123;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.printf(&quot;userName&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + userName);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock2) &#123;</span><br><span class="line">                System.out.println(&quot;按lock2---&gt;lock1的代码执行了..&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个线程互相等待对方的锁而导致的线程死锁;</p>
<h3 id="检查是否有死锁"><a href="#检查是否有死锁" class="headerlink" title="检查是否有死锁"></a>检查是否有死锁</h3><p>jdk自带的工具类,进入bin目录,执行jps命令.得到runId,在执行jstack命令 jstack -l runId</p>
<h3 id="锁对象的改变"><a href="#锁对象的改变" class="headerlink" title="锁对象的改变"></a>锁对象的改变</h3><p>String lock = “aa”;</p>
<p>synchronized(lock){</p>
<p>lock =”bb”;</p>
<p>}</p>
<p>这样会变成另一个锁,对象的值变了,此时都争抢的是变化后的值.所以此时还是同步的.</p>
<p>如果一个对象,它的属性发生变化,运行的结果还是同步的.</p>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile关键字主要是使得变量在各个线程间可见.</p>
<p>volatile关键字的作用是强制从公共堆栈中取得变量的值,而不是从私有数据栈中取得变量的值.</p>
<p><img src="/images/thread/%E8%AF%BB%E5%8F%96%E5%85%AC%E5%85%B1%E5%86%85%E5%AD%98.png" alt="读取公共内存"></p>
<h2 id="volatile关键字和synchronized关键字之间的区别"><a href="#volatile关键字和synchronized关键字之间的区别" class="headerlink" title="volatile关键字和synchronized关键字之间的区别"></a>volatile关键字和synchronized关键字之间的区别</h2><p>volatile关键字增加了实例变量在多个线程之间的可见性,但是volatile关键字不支持原子性.</p>
<ol>
<li>关键字volatile是线程同步的轻量级的实现,所以volatile性能肯定比synchronized好,并且volatile只能修饰变量,而synchronized可以修饰方法以及代码块.jdk新版本的发布导致synchronized关键字使用的比例还是比较高的.</li>
<li>多线程访问volatile不会发生阻塞,而synchronized会出现阻塞.</li>
<li>volatile能保证数据的可见性,但不能保证原子性.而synchronized可以保证原子性也可以间接保证可见性,因为他会将私有内存和功能内存中的数据做同步.</li>
<li>关键字volatile是解决多个线程之间的可见性,而synchronized关键字解决的是多个线程之间访问资源的同步性.</li>
</ol>
<h2 id="i"><a href="#i" class="headerlink" title="i++"></a>i++</h2><p>关键字volatile提示线程每次从共享内存中读取变量,而不是从私有内存中读取,这样保证了同步数据的可见性.但是不能保存数据操作的原子性,比如i++</p>
<p>i++的操作分为三步:</p>
<ol>
<li>从内存中读取i的值,</li>
<li>计算i的值,</li>
<li>将i的值写入内存</li>
</ol>
<p>假如在第二步的时候,另一个线程也改变了i的值,就会出现脏数据.</p>
<p><img src="/images/thread/%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="变量在内存中工作过程"></p>
<ol>
<li>read和load阶段,从主存复制变量到当前线程工作内存;</li>
<li>use和assign阶段:执行代码.改变共享变量值;</li>
<li>store和write阶段: 用工作内存数据刷新主存对应变量的值;</li>
</ol>
<p>在多线程环境中,use和assign时多次出现的,但这一操作并不是原子性,也就是read和load之后,如果主内存的count变量发生了变化之后,线程工作内存中的值已经加载,不会产生对应的变化,也就是私有内存和公共内存的变量不同步,所以会出现费线程安全问题.</p>
<p>volatile修饰的变量,JVM只保证从主内存加载到工作线程红的值是最新的.也就是volatile关键字只能保证变量读时的可见性,不能保证原子性.就是如果多个线程对一个实例变量访问还是需要加锁同步.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-04-08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-04-08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">多线程编程核心技术-java多线程基本方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-08 00:50:28" itemprop="dateCreated datePublished" datetime="2018-04-08T00:50:28+08:00">2018-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>进程</strong>: 进程是操作系统结构的基础,是一次程序的运行;是一个程序及其数据在处理机上顺序执行所发生的活动;是程序在一个数据集合上运行的过程,是系统进行资源分配和调度的独立单位.</p>
<p>指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p>
<p><strong>线程</strong>: 进程间独立运行的子任务.是程序执行流的最小单元</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><p>调度：</p>
<pre><code> 在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。</code></pre>
</li>
<li><p>并发性：<br>   在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。</p>
</li>
<li><p>拥有资源：<br>   不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。</p>
</li>
<li><p>独立性：</p>
<pre><code> 在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为</code></pre>
<p>为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。</p>
</li>
<li><p>系统开销：</p>
<pre><code>由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现也变得比较容易。在有的系统中，现成的切换、同步、和通信都无需操作系统内核的干预。</code></pre>
</li>
<li><p>支持多处理机系统：</p>
<pre><code>在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代处理机OS都无一例外地引入了多线程。</code></pre>
</li>
</ol>
<h1 id="多线程的实现及基本方法"><a href="#多线程的实现及基本方法" class="headerlink" title="多线程的实现及基本方法"></a>多线程的实现及基本方法</h1><p>继承Thread类和实现Runnable接口,thread类也实现了Runnable接口,所以本质上时一样的.但Runnable接口是避免了单继承的缺点.</p>
<p>使用多线程时,代码的调用顺序或者使用顺序和代码的运行结果是无关的.</p>
<p>线程的启动顺序,不代表线程的执行顺序.</p>
<h2 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h2><p>自定义线程类中的实例变量针对其它线程可以有共享和不共享之分</p>
<ol>
<li>不共享的线程是每个线程有自己运行的代码块.</li>
<li>共享的线程的情况就是多个线程访问同一代码块中的变量.</li>
</ol>
<p>由于多线程共享一段代码的时候(调用run方法),会出现各个线程顺序不定的访问代码.为了实现排队访问同一变量的目的,可以在方法前添加synchronize关键字.</p>
<p>//在执行run方法前,先判断方法是否加synchronize锁,如果上锁,说明其它线程在调用run方法,必须等待其它线程对run方法调用结束后才可以执行run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ShareVariableThread2 extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private int i &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    synchronized public void run() &#123;</span><br><span class="line">        i--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;计算,count&#x3D;&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ShareVariableThread2 thread2 &#x3D;new ShareVariableThread2();</span><br><span class="line">    Thread t5 &#x3D;new Thread(thread2,&quot;t5&quot;);</span><br><span class="line">    Thread t6 &#x3D;new Thread(thread2,&quot;t6&quot;);</span><br><span class="line">    Thread t7 &#x3D;new Thread(thread2,&quot;t7&quot;);</span><br><span class="line">    Thread t8 &#x3D;new Thread(thread2,&quot;t8&quot;);</span><br><span class="line">    t5.start();</span><br><span class="line">    t6.start();</span><br><span class="line">    t7.start();</span><br><span class="line">    t8.start();</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>非线程安全是指,多线程对同一个对象的同一个变量进行操作的时候会出现值被更改,值不同步的情况,进而影响程序执行的进程.</p>
<p>currentThread()方法 判断正在被哪个线程调用</p>
<p>isAlive()判断线程是否处于活跃状态</p>
<p>sleep()方法使得线程放弃cpu使用时间，N ms</p>
<p>getId()获取线程的唯一id</p>
<h2 id="停止线程的三种方法"><a href="#停止线程的三种方法" class="headerlink" title="停止线程的三种方法"></a>停止线程的三种方法</h2><p>stop()是可以停止一个线程的运行，但是它是线程不安全的，它是不推荐使用的方法，在将来的发布版本中可能被去掉，可能产生不可预料的结果。</p>
<p>interrupt()方法，不会终止一个正在运行的线程。需要加入一个判断才可以完成线程的停止。</p>
<p>正常的run方法完成后线程终结。</p>
<h2 id="停止不了的线程"><a href="#停止不了的线程" class="headerlink" title="停止不了的线程"></a>停止不了的线程</h2><p>调用interrupt()方法仅仅是在当前线程中打了一个停止的标记,并不是真正的停止线程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void interrupt() &#123;</span><br><span class="line">    if (this !&#x3D; Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b &#x3D; blocker;</span><br><span class="line">        if (b !&#x3D; null) &#123;</span><br><span class="line">            interrupt0();           &#x2F;&#x2F; Just to set the interrupt flag</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="判断线程是否处于停止状态"><a href="#判断线程是否处于停止状态" class="headerlink" title="判断线程是否处于停止状态"></a>判断线程是否处于停止状态</h2><p>this.interrupted()  测试当前线程是否已经中断,执行后具有将状态标志置为false的功能;</p>
<p>this.isInterrupted() 测试线程是否是中断状态,但不清除状态标志.</p>
<h2 id="能停止的线程-异常法"><a href="#能停止的线程-异常法" class="headerlink" title="能停止的线程-异常法"></a>能停止的线程-异常法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通过判断线程是否是停止状态,如果是停止状态,则停止执行后续代码</span><br><span class="line"> *</span><br><span class="line"> * @author chen weijie</span><br><span class="line"> * @date 2018-04-10 12:03 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StatusStopThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 500000; i++) &#123;</span><br><span class="line"></span><br><span class="line">            if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StatusStopThreadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StatusStopThread thread &#x3D; new StatusStopThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;sleep............&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(&quot;end--------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然根据线程标记的中断状态,for循环停止了运行,但是’end…..’语句还是输出了,证明线程还是在运行.如何真正中断线程呢? 答案时抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通过抛出异常中断线程</span><br><span class="line"> *</span><br><span class="line"> * @author chen weijie</span><br><span class="line"> * @date 2018-04-10 12:14 AM</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ExceptionStopThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        super.run();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5000000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + i);</span><br><span class="line">            if (this.isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;中断....&quot;);</span><br><span class="line">                throw new RuntimeException(&quot;exception interrupt thread&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="在沉睡中终止"><a href="#在沉睡中终止" class="headerlink" title="在沉睡中终止"></a>在沉睡中终止</h2><p>抛出sleep状态被打断的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#39;127.0.0.1:33558&#39;, transport: &#39;socket&#39;</span><br><span class="line">beginning............</span><br><span class="line">在沉睡中被中止.......interrupt</span><br><span class="line">end........</span><br><span class="line">Disconnected from the target VM, address: &#39;127.0.0.1:33558&#39;, transport: &#39;socket&#39;</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at com.chen.api.util.thread.study.chapter1.sleepStopException.SleepInterruptThread.run(SleepInterruptThread.java:16)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="暴力停止线程"><a href="#暴力停止线程" class="headerlink" title="暴力停止线程"></a>暴力停止线程</h2><p>暴力终结不会出现在沉睡中interrupt那种抛出异常,非常暴力.</p>
<p>stop被作废,主要是因为,如果强制让线程停止,则有可能使得一些清理性的工作得不到完成.另外一个情况就是对锁定对象进行了”解锁”,导致数据得不到同步的处理.</p>
<h2 id="释放锁的不良后果"><a href="#释放锁的不良后果" class="headerlink" title="释放锁的不良后果"></a>释放锁的不良后果</h2><p>使用stop()释放锁,将会给数据造成不一致的结果,这样程序处理的数据可能遭到破坏.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedObject &#123;</span><br><span class="line"></span><br><span class="line">    private String userName &#x3D;&quot;a&quot;;</span><br><span class="line">    private String passWord&#x3D;&quot;aa&quot;;</span><br><span class="line">  synchronized  public void printString(String userName,String passWord)&#123;</span><br><span class="line"></span><br><span class="line">        this.userName &#x3D;userName;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        this.passWord&#x3D;passWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private SynchronizedObject object;</span><br><span class="line">    public MyThread(SynchronizedObject object) &#123;</span><br><span class="line">        this.object &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        object.printString(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        SynchronizedObject object &#x3D; new SynchronizedObject();</span><br><span class="line">        MyThread myThread &#x3D; new MyThread(object);</span><br><span class="line">        myThread.start();</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        myThread.stop();</span><br><span class="line">        System.out.println(object.getUserName() + &quot;----------&quot; + object.getPassWord());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="return-停止线程"><a href="#return-停止线程" class="headerlink" title="return 停止线程"></a>return 停止线程</h2><p>return和抛出异常都可以停止线程,但是建议使用抛出异常的方式,因为这样可以在catch块中向上抛,使得线程停止的事件得以传播.</p>
<h2 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h2><p>suspend()方法是中断线程的,resume()是唤醒线程的.</p>
<p>这两方法的缺点: </p>
<ol>
<li>独占,容易造成同步对象的独占,使得其它线程无法访问公共同步对象.</li>
<li>不同步,这两个方法容易出现线程的暂停而导致数据不同步的情况.</li>
</ol>
<h2 id="yeild方法"><a href="#yeild方法" class="headerlink" title="yeild方法"></a>yeild方法</h2><p>该方法的作用是放弃当前的cpu资源,将它让给其它的任务去占用,但是放弃的时间不确定,所以有可能刚刚放弃,马上又获得cpu的时间了.</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>cpu会优先执行优先级比较高的线程对象中的任务.所以优先级高的线程会比优先级低的线程获取更多的cpu时间;</p>
<p>cpu尽量尽量将执行资源让给优先级比较高的线程执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Changes the priority of this thread.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * First the &lt;code&gt;checkAccess&lt;&#x2F;code&gt; method of this thread is called</span><br><span class="line"> * with no arguments. This may result in throwing a</span><br><span class="line"> * &lt;code&gt;SecurityException&lt;&#x2F;code&gt;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Otherwise, the priority of this thread is set to the smaller of</span><br><span class="line"> * the specified &lt;code&gt;newPriority&lt;&#x2F;code&gt; and the maximum permitted</span><br><span class="line"> * priority of the thread&#39;s thread group.</span><br><span class="line"> *</span><br><span class="line"> * @param newPriority priority to set this thread to</span><br><span class="line"> * @exception  IllegalArgumentException  If the priority is not in the</span><br><span class="line"> *               range &lt;code&gt;MIN_PRIORITY&lt;&#x2F;code&gt; to</span><br><span class="line"> *               &lt;code&gt;MAX_PRIORITY&lt;&#x2F;code&gt;.</span><br><span class="line"> * @exception  SecurityException  if the current thread cannot modify</span><br><span class="line"> *               this thread.</span><br><span class="line"> * @see        #getPriority</span><br><span class="line"> * @see        #checkAccess()</span><br><span class="line"> * @see        #getThreadGroup()</span><br><span class="line"> * @see        #MAX_PRIORITY</span><br><span class="line"> * @see        #MIN_PRIORITY</span><br><span class="line"> * @see        ThreadGroup#getMaxPriority()</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    if((g &#x3D; getThreadGroup()) !&#x3D; null) &#123;</span><br><span class="line">        if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority &#x3D; g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority &#x3D; newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p> 线程优先级分为10个 但JDK定义了三个常量: MIN_PRIORITY=1  NORM_PRIORITY=5  MAX_PRIORITY=10 </p>
<p> 线程优先级的继承性: 比如A线程启动B线程,则B线程的优先级与A是一样的.</p>
<h2 id="优先级具有随机性"><a href="#优先级具有随机性" class="headerlink" title="优先级具有随机性"></a>优先级具有随机性</h2><p> 优先级较高的线程会获取较多的cpu资源,所以两个具有相同任务的线程优先级不同,优先级高的线程的任务先执行完毕,但不是绝对的,因为线程的优先级具有随机性.</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p> java线程中有2种: 一种是守护线程,另一种是用户线程</p>
<ol>
<li><p>守护线程时一种特殊的线程,他的特性有陪伴的含义,当进程中不存在非守护线程了,守护进程自动销毁.</p>
</li>
<li><p>任何一个守护线程都是整个JVM中所有非守护线程的保姆.只要当前JVM中存在任何一个非守护线程没有结束,守护线程就在工作,当最后一个非守护线程结束时没守护线程才随着JVM一同结束同坐,</p>
</li>
<li><p>Daemon的作用时为其它线程的运行提供遍历服务,守护线程最典型的应用就是GC,他就是一个很称职的守护者.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-04-06/kafka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-producer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-04-06/kafka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-producer/" class="post-title-link" itemprop="url">kafka源码剖析-producer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-06 23:53:43" itemprop="dateCreated datePublished" datetime="2018-04-06T23:53:43+08:00">2018-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kafkaProducer分析"><a href="#kafkaProducer分析" class="headerlink" title="kafkaProducer分析"></a>kafkaProducer分析</h1><h2 id="发送消息的流程"><a href="#发送消息的流程" class="headerlink" title="发送消息的流程"></a>发送消息的流程</h2><p><img src="/images/kafka/producer/kafka%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B.png" alt="kafka发送消息的整个流程"></p>
<ol>
<li>producerInterceptors对消息进行拦截</li>
<li>Serializer对消息的key和value进行序列化</li>
<li>Partitioner为消息选择合适的分区</li>
<li>RecordAccumulator收集消息,实现批量发送</li>
<li>Sender从RecordAccumulator获取消息</li>
<li>构造ClientRequest</li>
<li>将ClientRequest交给networkClientRequest,准备发送</li>
<li>networkClient 将请求放入kafkaChanel缓存</li>
<li>执行网络IO,发送请求</li>
<li>收到响应,调用ClientRequest的回调函数</li>
<li>调用RecordBatch的回调函数,最终调用每个消息上注册的回调函数.</li>
</ol>
<h2 id="kafkaProducer接口实现的方法介绍"><a href="#kafkaProducer接口实现的方法介绍" class="headerlink" title="kafkaProducer接口实现的方法介绍"></a>kafkaProducer接口实现的方法介绍</h2><ol>
<li>send()方法,发送消息,将消息放入RecordAccumulator暂存,等待发送;</li>
<li>flush()方法,刷新操作,等待RecordAccumulator中所有消息发送完成,在刷新完成之前会阻塞调用的线程</li>
<li>partitionFor()方法,在kafkaProducer中维护了一个Metadata对象,用于存储kafka集群的元数据,会定时更新,该方法负责从元数据中获取制定topic中的分区信息</li>
<li>close()方法,关闭此producer对象,主要操作是设置close标志,等待RecordAccumulator中的消息清空,关闭sender线程.</li>
</ol>
<h2 id="kafkaProducer的具体实现"><a href="#kafkaProducer的具体实现" class="headerlink" title="kafkaProducer的具体实现:"></a>kafkaProducer的具体实现:</h2><p>kafkaProducer的重要参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;clientId生成器</span><br><span class="line">private static final AtomicInteger PRODUCER_CLIENT_ID_SEQUENCE &#x3D; new AtomicInteger(1);</span><br><span class="line">&#x2F;&#x2F;clientId</span><br><span class="line">private String clientId;</span><br><span class="line">&#x2F;&#x2F;分区选择器</span><br><span class="line">private final Partitioner partitioner;</span><br><span class="line">&#x2F;&#x2F;消息的最大长度,包括消息头.序列化后的key和value</span><br><span class="line">private final int maxRequestSize;</span><br><span class="line">&#x2F;&#x2F;发送单个消息的缓冲区大小</span><br><span class="line">private final long totalMemorySize;</span><br><span class="line">&#x2F;&#x2F;kafka的元数据</span><br><span class="line">private final Metadata metadata;</span><br><span class="line">&#x2F;&#x2F;用于收集缓存消息,等待Sender线程发送</span><br><span class="line">private final RecordAccumulator accumulator;</span><br><span class="line">&#x2F;&#x2F;发送消息的sender任务,实现了Runnable接口</span><br><span class="line">private final Sender sender;</span><br><span class="line">&#x2F;&#x2F;执行sender任务发送消息的线程</span><br><span class="line">private final Thread ioThread;</span><br><span class="line">&#x2F;&#x2F;压缩算法,收集器收集的消息进行压缩</span><br><span class="line">private final CompressionType compressionType;</span><br><span class="line">&#x2F;&#x2F;key序列化器</span><br><span class="line">private final Serializer&lt;K&gt; keySerializer;</span><br><span class="line">&#x2F;&#x2F;value序列化器</span><br><span class="line">private final Serializer&lt;V&gt; valueSerializer;</span><br><span class="line">&#x2F;&#x2F;配置对象</span><br><span class="line">private final ProducerConfig producerConfig;</span><br><span class="line">&#x2F;&#x2F;等待更新kafka集群元数据的最大时长</span><br><span class="line">private final long maxBlockTimeMs;</span><br><span class="line">&#x2F;&#x2F;从消息发送到收到ACK相应的最大时长</span><br><span class="line">private final int requestTimeoutMs;</span><br><span class="line">&#x2F;&#x2F;消息发送之前对消息进行拦截或者修改</span><br><span class="line">private final ProducerInterceptors&lt;K, V&gt; interceptors;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/kafka/producer/send%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="send方法的调用流程"></p>
<h2 id="ProducerInterceptor"><a href="#ProducerInterceptor" class="headerlink" title="ProducerInterceptor"></a>ProducerInterceptor</h2><p>该对象是可以在消息发送之前对其进行拦截或者修改,用户可以实现该接口,然后自定义方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ProducerInterceptor&lt;K, V&gt; extends Configurable &#123;</span><br><span class="line">    public ProducerRecord&lt;K, V&gt; onSend(ProducerRecord&lt;K, V&gt; record);</span><br><span class="line">    public void onAcknowledgement(RecordMetadata metadata, Exception exception);</span><br><span class="line">    public void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="kafka集群元数据"><a href="#kafka集群元数据" class="headerlink" title="kafka集群元数据"></a>kafka集群元数据</h2><h3 id="基本类"><a href="#基本类" class="headerlink" title="基本类"></a>基本类</h3><p>由于kafka生产者在发送消息的时候需要实时的了解kafka分区的相关情况,kafkaProducer中维护了Metadata其中,它用以下三个类封装了集群的相关的元数据</p>
<p><img src="/images/kafka/producer/kafka%E5%85%83%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E7%9A%84%E5%AF%B9%E8%B1%A1.png" alt="kafka元数据对象封装的对象"></p>
<h4 id="kafka集群的元数据"><a href="#kafka集群的元数据" class="headerlink" title="kafka集群的元数据"></a>kafka集群的元数据</h4><p>某个topic有几个分区、每个分区的leader副本在哪个节点上、follower副本在哪个节点上、isr集合、这些节点的ip和端口号。</p>
<h3 id="cluster类"><a href="#cluster类" class="headerlink" title="cluster类"></a>cluster类</h3><p>这三个类所组成的对象封装在一个叫做Cluster的类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;kafka集群中节点列表</span><br><span class="line">private final List&lt;Node&gt; nodes;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">private final Set&lt;String&gt; unauthorizedTopics;</span><br><span class="line">&#x2F;&#x2F;记录了topicPartition 与partitionInfo之间的关系</span><br><span class="line">private final Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition;</span><br><span class="line">&#x2F;&#x2F;topic名称与PartitionInfo的映射关系</span><br><span class="line">private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic;</span><br><span class="line">private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic;</span><br><span class="line">&#x2F;&#x2F;node与partitionInfo的映射关系</span><br><span class="line">private final Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode;</span><br><span class="line">&#x2F;&#x2F;BrokerId与node节点之间的对应关系</span><br><span class="line">private final Map&lt;Integer, Node&gt; nodesById;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="metadata类"><a href="#metadata类" class="headerlink" title="metadata类"></a>metadata类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;两次发出更新clsuter保存的元数据信息的最小时间差</span><br><span class="line">private final long refreshBackoffMs;</span><br><span class="line">&#x2F;&#x2F;每隔多久更新一次</span><br><span class="line">private final long metadataExpireMs;</span><br><span class="line">&#x2F;&#x2F;kafka集群元数据的版本号,每更新一次,值加1</span><br><span class="line">private int version;</span><br><span class="line">&#x2F;&#x2F;上一次更新元数据的时间戳</span><br><span class="line">private long lastRefreshMs;</span><br><span class="line">&#x2F;&#x2F;上一次更新元数据成功的时间戳</span><br><span class="line">private long lastSuccessfulRefreshMs;</span><br><span class="line">&#x2F;&#x2F;记录kafka集群的元数据</span><br><span class="line">private Cluster cluster;</span><br><span class="line">private boolean needUpdate;</span><br><span class="line">&#x2F;&#x2F;topic最新的元数据</span><br><span class="line">private final Set&lt;String&gt; topics;</span><br><span class="line">private final List&lt;Listener&gt; listeners;</span><br><span class="line">private boolean needMetadataForAllTopics;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>metadata类中主要的waitOnMetadata()方法主要时触发元数据的更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private long waitOnMetadata(String topic, long maxWaitMs) throws InterruptedException &#123;</span><br><span class="line">      &#x2F;&#x2F; add topic to metadata topic list if it is not there already.</span><br><span class="line">      if (!this.metadata.containsTopic(topic))</span><br><span class="line">          this.metadata.add(topic);</span><br><span class="line">          </span><br><span class="line">      &#x2F;&#x2F;成功获取分区的详细信息</span><br><span class="line">      if (metadata.fetch().partitionsForTopic(topic) !&#x3D; null)</span><br><span class="line">          return 0;</span><br><span class="line"></span><br><span class="line">      long begin &#x3D; time.milliseconds();</span><br><span class="line">      long remainingWaitMs &#x3D; maxWaitMs;</span><br><span class="line">      while (metadata.fetch().partitionsForTopic(topic) &#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F;设置needupdate,获取当前元数据版本号</span><br><span class="line">          int version &#x3D; metadata.requestUpdate();</span><br><span class="line">          sender.wakeup();&#x2F;&#x2F;唤醒sender线程</span><br><span class="line">          &#x2F;&#x2F;阻塞等待元数据更新完毕</span><br><span class="line">          metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">          long elapsed &#x3D; time.milliseconds() - begin;</span><br><span class="line">          if (elapsed &gt;&#x3D; maxWaitMs)</span><br><span class="line">              throw new TimeoutException(&quot;Failed to update metadata after &quot; + maxWaitMs + &quot; ms.&quot;);</span><br><span class="line">          if (metadata.fetch().unauthorizedTopics().contains(topic))</span><br><span class="line">              throw new TopicAuthorizationException(topic);</span><br><span class="line">          remainingWaitMs &#x3D; maxWaitMs - elapsed;</span><br><span class="line">      &#125;</span><br><span class="line">      return time.milliseconds() - begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Serializer和Deserializer"><a href="#Serializer和Deserializer" class="headerlink" title="Serializer和Deserializer"></a>Serializer和Deserializer</h2><p>客户端发送的消息的key和value都是byte数组,这两个接口实现了将java对象序列化和反序列化为byte数组的功能.</p>
<h2 id="partitioner"><a href="#partitioner" class="headerlink" title="partitioner"></a>partitioner</h2><p>kafkaProducer.send()方法的下一步操作是选择消息的分区.DefaultPartitioner中对partition的实现.直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化一个随机数,是线程安全的AtomicInteger对象</span><br><span class="line">private final AtomicInteger counter &#x3D; new AtomicInteger(new Random().nextInt());</span><br><span class="line"></span><br><span class="line">public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">    &#x2F;&#x2F;从cluster中获取分片信息</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions &#x3D; cluster.partitionsForTopic(topic);</span><br><span class="line">    int numPartitions &#x3D; partitions.size();</span><br><span class="line">    if (keyBytes &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;对于没有key的情况,递增counter</span><br><span class="line">        int nextValue &#x3D; counter.getAndIncrement();</span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions &#x3D; cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        if (availablePartitions.size() &gt; 0) &#123;</span><br><span class="line">            int part &#x3D; DefaultPartitioner.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            return availablePartitions.get(part).partition();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; no partitions are available, give a non-available partition</span><br><span class="line">            return DefaultPartitioner.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; hash the keyBytes to choose a partition</span><br><span class="line">        &#x2F;&#x2F;对于有key的情况,对key进行hash(murmur2的hash算法),然后与分区数量取模</span><br><span class="line">        return DefaultPartitioner.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="RecordAccumulator分析"><a href="#RecordAccumulator分析" class="headerlink" title="RecordAccumulator分析"></a>RecordAccumulator分析</h1><p>kafkaProducer可以有同步和异步两种方式发送消息,两者的底层实现都是异步的.主线程send()方法发送消息的时候,现将消息放到RecordAccumulator中缓存,然后主线程可以从send()方法中返回了,其实消息没有真正的发送,而是缓存在RecordAccumulator对象中,业务线程不断的通过send方法追加消息,达到一定条件会唤醒Sender线程,发送RecordAccumulator中的消息.</p>
<p>RecordAccumulator至少有一个业务线程和一个Sender线程并发操作,所以RecordAccumulator时线程安全的.</p>
<p>RecordAccumulator中有一个以TopicPartition为key的ConcurrentMap,每个value都是Deque<RecordBatch>,每个RecordBatch都拥有一个MemoryRecords的对象的引用,MemoryRecords才是消息最终存放的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class RecordAccumulator&#123;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MemoryRecords对象"><a href="#MemoryRecords对象" class="headerlink" title="MemoryRecords对象"></a>MemoryRecords对象</h2><p>该对象很重有四个字段比较重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;压缩器,对消息数据进行压缩,将压缩后的数据输出到buffer</span><br><span class="line">private final Compressor compressor;</span><br><span class="line">&#x2F;&#x2F;记录buffer字段最多可以写入多少字节的数据</span><br><span class="line">private final int writeLimit;</span><br><span class="line">&#x2F;&#x2F;用于保存消息数据的javaNIO ByteBuffer</span><br><span class="line">private ByteBuffer buffer;</span><br><span class="line">&#x2F;&#x2F;MemoryRecords对象是只读模式,还是可写模式,该对象发送前时,将其设置为只读模式.</span><br><span class="line">private boolean writable;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>compressor中重要的字段有bufferStream和appendStream.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 压缩操作</span><br><span class="line">public Compressor(ByteBuffer buffer, CompressionType type) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line"></span><br><span class="line">        if (type !&#x3D; CompressionType.NONE) &#123;</span><br><span class="line">            &#x2F;&#x2F; for compressed records, leave space for the header and the shallow message metadata</span><br><span class="line">            &#x2F;&#x2F; and move the starting position to the value payload offset</span><br><span class="line">            buffer.position(initPos + Records.LOG_OVERHEAD + Record.RECORD_OVERHEAD);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; create the stream</span><br><span class="line">        bufferStream &#x3D; new ByteBufferOutputStream(buffer);</span><br><span class="line">        &#x2F;&#x2F;根据压缩类型创建合适的压缩流</span><br><span class="line">        appendStream &#x3D; wrapForOutput(bufferStream, type, COMPRESSION_DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;包装压缩流</span><br><span class="line">    public static DataOutputStream wrapForOutput(ByteBufferOutputStream buffer, CompressionType type, int bufferSize) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (type) &#123;</span><br><span class="line">                case NONE:</span><br><span class="line">                    return new DataOutputStream(buffer);</span><br><span class="line">                case GZIP:</span><br><span class="line">                    return new DataOutputStream(new GZIPOutputStream(buffer, bufferSize));</span><br><span class="line">                case SNAPPY:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        OutputStream stream &#x3D; (OutputStream) snappyOutputStreamSupplier.get().newInstance(buffer, bufferSize);</span><br><span class="line">                        return new DataOutputStream(stream);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        throw new KafkaException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                case LZ4:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        OutputStream stream &#x3D; (OutputStream) lz4OutputStreamSupplier.get().newInstance(buffer);</span><br><span class="line">                        return new DataOutputStream(stream);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        throw new KafkaException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                default:</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Unknown compression type: &quot; + type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new KafkaException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> compressor提供了一系列put*()方法,向appendStream中写入数据,这是个装饰器模式,通过bufferStream装饰,添加自动扩容的功能.</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过emptyRecords()方法得到MemoryRecords对象,</p>
<p>append() 判断MemoryRecords对象是否为可写模式,然后调用Compressor.put*()方法,将消息写入到ByteBuffer对象</p>
<p>hashRoomFor() 估计对象中是否有空间继续吸入数据</p>
<p>close()方法,将buffer字段指向另一个ByteBuffer对象,将writable设置为false.</p>
<p>sizeInBytes()方法:返回MemoryRecords.buffer()的大小</p>
<h2 id="RecordBatch"><a href="#RecordBatch" class="headerlink" title="RecordBatch"></a>RecordBatch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class RecordBatch &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录的个数</span><br><span class="line">    public int recordCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;最大record的字节数</span><br><span class="line">    public int maxRecordSize &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;尝试发送当前recordBatch的次数</span><br><span class="line">    public volatile int attempts &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;最后一次尝试发送的时间戳    </span><br><span class="line">    public long lastAttemptMs;</span><br><span class="line">    &#x2F;&#x2F;用来存储数据的MemoryRecords对象</span><br><span class="line">    public final MemoryRecords records;</span><br><span class="line">    &#x2F;&#x2F;MemoryRecords对象中存储的数据会批量发送给topicPartition</span><br><span class="line">    public final TopicPartition topicPartition;</span><br><span class="line">    &#x2F;&#x2F;标示RecordBatch状态的future对象</span><br><span class="line">    public final ProduceRequestResult produceFuture;</span><br><span class="line">    &#x2F;&#x2F;上一次追加消息的时间</span><br><span class="line">    public long lastAppendTime;</span><br><span class="line">    &#x2F;&#x2F;thunks对象的集合</span><br><span class="line">    private final List&lt;Thunk&gt; thunks;</span><br><span class="line">    &#x2F;&#x2F;某消息在recordBatch对象中的偏移量</span><br><span class="line">    private long offsetCounter &#x3D; 0L;</span><br><span class="line">    &#x2F;&#x2F;是否正在进行重试</span><br><span class="line">    private boolean retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RecordBatch主要用于封装MemoryRecords以及其他的一些统计类型的信息。</p>
<p>ProduceRequestResult: 完成生产者请求的一个结果类，但是该类并没有根据并发库下的Future来实现而是根据CountDownLatch来实现。当RecordBatch中全部消息被正常响应，或超市或关闭生产者时，会调用done方法标记完成，可以通过error字段区分是异常完成还是正常完成</p>
<h3 id="bufferPool"><a href="#bufferPool" class="headerlink" title="bufferPool"></a>bufferPool</h3><p>ByteBuffer的创建和释放是比较消耗资源的,为了实现资源的高效利用,基本上每个成熟的框架或者工具都有一套管理机制.kafka使用bufferPool进行管理.</p>
<p>bufferPool对象只针对特定大小的byteBuffer字段进行管理,memoryRecords的大小由RecordAccumulator.bathSize字段指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class BufferPool &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;整个bufferPool的大小</span><br><span class="line">    private final long totalMemory;</span><br><span class="line">    private final int poolableSize;</span><br><span class="line">    &#x2F;&#x2F;因为有多线程并发分配和回收byteBuffer,所以使用所控制并发线程的安全</span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    &#x2F;&#x2F;是一个队列,缓存了指定大小的byteBuffer对象</span><br><span class="line">    private final Deque&lt;ByteBuffer&gt; free;</span><br><span class="line">    &#x2F;&#x2F;记录因申请不到足够空间而阻塞的线程,此队列中实际记录的是阻塞线程对应的Condition对象</span><br><span class="line">    private final Deque&lt;Condition&gt; waiters;</span><br><span class="line">    &#x2F;&#x2F;整个可用空间的大小,totalMemory-free</span><br><span class="line">    private long availableMemory;</span><br><span class="line">    private final Metrics metrics;</span><br><span class="line">    private final Time time;</span><br><span class="line">    private final Sensor waitTime;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>allocate方法负责从bufferPool中申请ByteBuffer,当缓冲池中空间不足时,就会阻塞调用线程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;申请空间</span><br><span class="line"></span><br><span class="line">public ByteBuffer allocate(int size, long maxTimeToBlockMs) throws InterruptedException &#123;</span><br><span class="line">        if (size &gt; this.totalMemory)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Attempt to allocate &quot; + size</span><br><span class="line">                                               + &quot; bytes, but there is a hard limit of &quot;</span><br><span class="line">                                               + this.totalMemory</span><br><span class="line">                                               + &quot; on memory allocations.&quot;);</span><br><span class="line">    &#x2F;&#x2F;加锁同步</span><br><span class="line">        this.lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; check if we have a free buffer of the right size pooled</span><br><span class="line">            if (size &#x3D;&#x3D; poolableSize &amp;&amp; !this.free.isEmpty())</span><br><span class="line">                return this.free.pollFirst();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; now check if the request is immediately satisfiable with the</span><br><span class="line">            &#x2F;&#x2F; memory on hand or if we need to block</span><br><span class="line">            int freeListSize &#x3D; this.free.size() * this.poolableSize;</span><br><span class="line">            if (this.availableMemory + freeListSize &gt;&#x3D; size) &#123;</span><br><span class="line">                &#x2F;&#x2F; we have enough unallocated or pooled memory to immediately</span><br><span class="line">                &#x2F;&#x2F; satisfy the request</span><br><span class="line">                freeUp(size);</span><br><span class="line">                this.availableMemory -&#x3D; size;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                return ByteBuffer.allocate(size);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; we are out of memory and will have to block</span><br><span class="line">                int accumulated &#x3D; 0;</span><br><span class="line">                ByteBuffer buffer &#x3D; null;</span><br><span class="line">                Condition moreMemory &#x3D; this.lock.newCondition();</span><br><span class="line">                long remainingTimeToBlockNs &#x3D; TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);</span><br><span class="line">                this.waiters.addLast(moreMemory);</span><br><span class="line">                &#x2F;&#x2F; loop over and over until we have a buffer or have reserved</span><br><span class="line">                &#x2F;&#x2F; enough memory to allocate one</span><br><span class="line">                while (accumulated &lt; size) &#123;</span><br><span class="line">                    long startWaitNs &#x3D; time.nanoseconds();</span><br><span class="line">                    long timeNs;</span><br><span class="line">                    boolean waitingTimeElapsed;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        waitingTimeElapsed &#x3D; !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        this.waiters.remove(moreMemory);</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        long endWaitNs &#x3D; time.nanoseconds();</span><br><span class="line">                        timeNs &#x3D; Math.max(0L, endWaitNs - startWaitNs);</span><br><span class="line">                        this.waitTime.record(timeNs, time.milliseconds());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (waitingTimeElapsed) &#123;</span><br><span class="line">                        this.waiters.remove(moreMemory);</span><br><span class="line">                        throw new TimeoutException(&quot;Failed to allocate memory within the configured max blocking time &quot; + maxTimeToBlockMs + &quot; ms.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    remainingTimeToBlockNs -&#x3D; timeNs;</span><br><span class="line">                    &#x2F;&#x2F; check if we can satisfy this request from the free list,</span><br><span class="line">                    &#x2F;&#x2F; otherwise allocate memory</span><br><span class="line">                    if (accumulated &#x3D;&#x3D; 0 &amp;&amp; size &#x3D;&#x3D; this.poolableSize &amp;&amp; !this.free.isEmpty()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; just grab a buffer from the free list</span><br><span class="line">                        buffer &#x3D; this.free.pollFirst();</span><br><span class="line">                        accumulated &#x3D; size;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; we&#39;ll need to allocate memory, but we may only get</span><br><span class="line">                        &#x2F;&#x2F; part of what we need on this iteration</span><br><span class="line">                        freeUp(size - accumulated);</span><br><span class="line">                        int got &#x3D; (int) Math.min(size - accumulated, this.availableMemory);</span><br><span class="line">                        this.availableMemory -&#x3D; got;</span><br><span class="line">                        accumulated +&#x3D; got;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; remove the condition for this thread to let the next thread</span><br><span class="line">                &#x2F;&#x2F; in line start getting memory</span><br><span class="line">                Condition removed &#x3D; this.waiters.removeFirst();</span><br><span class="line">                if (removed !&#x3D; moreMemory)</span><br><span class="line">                    throw new IllegalStateException(&quot;Wrong condition: this shouldn&#39;t happen.&quot;);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; signal any additional waiters if there is more memory left</span><br><span class="line">                &#x2F;&#x2F; over for them</span><br><span class="line">                if (this.availableMemory &gt; 0 || !this.free.isEmpty()) &#123;</span><br><span class="line">                    if (!this.waiters.isEmpty())</span><br><span class="line">                        this.waiters.peekFirst().signal();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; unlock and return the buffer</span><br><span class="line">                lock.unlock();</span><br><span class="line">                if (buffer &#x3D;&#x3D; null)</span><br><span class="line">                    return ByteBuffer.allocate(size);</span><br><span class="line">                else</span><br><span class="line">                    return buffer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (lock.isHeldByCurrentThread())</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放空间</span><br><span class="line"></span><br><span class="line">public void deallocate(ByteBuffer buffer, int size) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; this.poolableSize &amp;&amp; size &#x3D;&#x3D; buffer.capacity()) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            this.free.add(buffer);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.availableMemory +&#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line">        Condition moreMem &#x3D; this.waiters.peekFirst();</span><br><span class="line">        if (moreMem !&#x3D; null)</span><br><span class="line">            moreMem.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="RecordAccumulator详解"><a href="#RecordAccumulator详解" class="headerlink" title="RecordAccumulator详解"></a>RecordAccumulator详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public final class RecordAccumulator &#123;</span><br><span class="line"></span><br><span class="line">    private volatile boolean closed;</span><br><span class="line">    private final AtomicInteger flushesInProgress;</span><br><span class="line">    private final AtomicInteger appendsInProgress;</span><br><span class="line">    &#x2F;&#x2F;每个recordBath底层ByteBuffer的大小</span><br><span class="line">    private final int batchSize;</span><br><span class="line">    &#x2F;&#x2F;压缩类型</span><br><span class="line">    private final CompressionType compression;</span><br><span class="line">    private final long lingerMs;</span><br><span class="line">    private final long retryBackoffMs;</span><br><span class="line">    &#x2F;&#x2F;bufferPool对象</span><br><span class="line">    private final BufferPool free;</span><br><span class="line">    private final Time time;</span><br><span class="line">    &#x2F;&#x2F;topicPartition与recordBath集合的映射关系,CopyOnWriteMap时线程安全的集合</span><br><span class="line">    private final ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches;</span><br><span class="line">    &#x2F;&#x2F;未发送完成的RecordBatch集合</span><br><span class="line">    private final IncompleteRecordBatches incomplete;</span><br><span class="line">    &#x2F;&#x2F; The following variables are only accessed by the sender thread, so we don&#39;t need to protect them.</span><br><span class="line">    private final Set&lt;TopicPartition&gt; muted;</span><br><span class="line">    &#x2F;&#x2F;使用drain方法批量导入RecordBath时,为了防止饥饿,记录上次发送停止时的位置,下次饥饿从此位置开始</span><br><span class="line">    private int drainIndex;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; drain(Cluster cluster,</span><br><span class="line">                                                     Set&lt;Node&gt; nodes,</span><br><span class="line">                                                     int maxSize,</span><br><span class="line">                                                     long now)</span><br><span class="line">                                                     </span><br><span class="line">    public ReadyCheckResult ready(Cluster cluster, long nowMs)                                                      </span><br><span class="line">                                                     </span><br><span class="line">    private RecordAppendResult tryAppend(long timestamp, byte[] key, byte[] value, Callback callback, Deque&lt;RecordBatch&gt; deque)</span><br><span class="line">    </span><br><span class="line">    public RecordAppendResult append(TopicPartition tp,</span><br><span class="line">                                               long timestamp,</span><br><span class="line">                                               byte[] key,</span><br><span class="line">                                               byte[] value,</span><br><span class="line">                                               Callback callback,</span><br><span class="line">                                               long maxTimeToBlock) throws InterruptedException                                  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kafkaProducer.send()方法最终会调用recordsAccumulator.append()方法将消息追加到RecordAccumulator中</p>
<ol>
<li>首先在batches集合中查找topicPartition对应的Deque,查找不到则创建新的Deque,并添加到batches集合中;</li>
<li>对Deque加锁(使用synchronize关键字加锁)</li>
<li>使用tryAppend()方法,尝试向Deque中最后一个RecordBatch追加record</li>
<li>synchronize块结束,自动解锁</li>
<li>追加成功,返回RecordAppendResult,</li>
<li>追加失败,则尝试从bufferPool中申请新的byteBuffer</li>
<li>对Deque加锁,</li>
<li>追加成功,则返回,追加失败则使用第五步得到的ByteBuffer创建RecordBatch,</li>
<li>将Record追加到新建的RecordBatch,并将新建的RecordBatch追加到Deque尾部</li>
<li>将新建的RecordBatch追加到incomplete集合中</li>
<li>synchronize代码块结束,自动解锁</li>
<li>返回RecordAppendResult,RecordAppendResult中的字段作为唤醒Sender线程的条件.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public RecordAppendResult append(TopicPartition tp,</span><br><span class="line">                                 long timestamp,</span><br><span class="line">                                 byte[] key,</span><br><span class="line">                                 byte[] value,</span><br><span class="line">                                 Callback callback,</span><br><span class="line">                                 long maxTimeToBlock) throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F; We keep track of the number of appending thread to make sure we do not miss batches in</span><br><span class="line">    &#x2F;&#x2F; abortIncompleteBatches().</span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; check if we have an in-progress batch</span><br><span class="line">        Deque&lt;RecordBatch&gt; dq &#x3D; getOrCreateDeque(tp);</span><br><span class="line">        synchronized (dq) &#123;</span><br><span class="line">            if (closed)</span><br><span class="line">                throw new IllegalStateException(&quot;Cannot send after the producer is closed.&quot;);</span><br><span class="line">            RecordAppendResult appendResult &#x3D; tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            if (appendResult !&#x3D; null)</span><br><span class="line">                return appendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; we don&#39;t have an in-progress record batch try to allocate a new batch</span><br><span class="line">        int size &#x3D; Math.max(this.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</span><br><span class="line">        log.trace(&quot;Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;&quot;, size, tp.topic(), tp.partition());</span><br><span class="line">        ByteBuffer buffer &#x3D; free.allocate(size, maxTimeToBlock);</span><br><span class="line">        synchronized (dq) &#123;</span><br><span class="line">            &#x2F;&#x2F; Need to check if producer is closed again after grabbing the dequeue lock.</span><br><span class="line">            if (closed)</span><br><span class="line">                throw new IllegalStateException(&quot;Cannot send after the producer is closed.&quot;);</span><br><span class="line"></span><br><span class="line">            RecordAppendResult appendResult &#x3D; tryAppend(timestamp, key, value, callback, dq);</span><br><span class="line">            if (appendResult !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Somebody else found us a batch, return the one we waited for! Hopefully this doesn&#39;t happen often...</span><br><span class="line">                free.deallocate(buffer);</span><br><span class="line">                return appendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            MemoryRecords records &#x3D; MemoryRecords.emptyRecords(buffer, compression, this.batchSize);</span><br><span class="line">            RecordBatch batch &#x3D; new RecordBatch(tp, records, time.milliseconds());</span><br><span class="line">            FutureRecordMetadata future &#x3D; Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            incomplete.add(batch);</span><br><span class="line">            return new RecordAppendResult(future, dq.size() &gt; 1 || batch.records.isFull(), true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>drain方法是将各个node节点的RecordBatch进行分组.在网络IO层面发送的时候,生产者时面向node层面发送消息数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Integer, List&lt;RecordBatch&gt;&gt; drain(Cluster cluster,</span><br><span class="line">                                                 Set&lt;Node&gt; nodes,</span><br><span class="line">                                                 int maxSize,</span><br><span class="line">                                                 long now) &#123;</span><br><span class="line">        if (nodes.isEmpty())</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#x2F;&#x2F;转换后的结果</span><br><span class="line">        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Node node : nodes) &#123; &#x2F;&#x2F;遍历指定ready node集合</span><br><span class="line">            int size &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F;获取当前node上的分区集合</span><br><span class="line">            List&lt;PartitionInfo&gt; parts &#x3D; cluster.partitionsForNode(node.id());</span><br><span class="line">            &#x2F;&#x2F;记录要发送的RecordBatch drainIndex 时Batches的下标,记录上次发送停止的位置, 如果一直从0开发发送,会造成其它的分区饥饿</span><br><span class="line">            List&lt;RecordBatch&gt; ready &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;* to make starvation less likely this loop doesn&#39;t start at 0 *&#x2F;</span><br><span class="line">            int start &#x3D; drainIndex &#x3D; drainIndex % parts.size();</span><br><span class="line">            do &#123;</span><br><span class="line">            &#x2F;&#x2F;获取分区的详细情况</span><br><span class="line">                PartitionInfo part &#x3D; parts.get(drainIndex);</span><br><span class="line">                TopicPartition tp &#x3D; new TopicPartition(part.topic(), part.partition());</span><br><span class="line">                &#x2F;&#x2F; Only proceed if the partition has no in-flight batches.</span><br><span class="line">                if (!muted.contains(tp)) &#123;</span><br><span class="line">                    Deque&lt;RecordBatch&gt; deque &#x3D; getDeque(new TopicPartition(part.topic(), part.partition()));</span><br><span class="line">                    if (deque !&#x3D; null) &#123;</span><br><span class="line">                        synchronized (deque) &#123;</span><br><span class="line">                            RecordBatch first &#x3D; deque.peekFirst();</span><br><span class="line">                            if (first !&#x3D; null) &#123;</span><br><span class="line">                                boolean backoff &#x3D; first.attempts &gt; 0 &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</span><br><span class="line">                                &#x2F;&#x2F; Only drain the batch if it is not during backoff period.</span><br><span class="line">                                if (!backoff) &#123;</span><br><span class="line">                                    if (size + first.records.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</span><br><span class="line">                                        &#x2F;&#x2F; there is a rare case that a single batch size is larger than the request size due</span><br><span class="line">                                        &#x2F;&#x2F; to compression; in this case we will still eventually send this batch in a single</span><br><span class="line">                                        &#x2F;&#x2F; request</span><br><span class="line">                                        break;</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        RecordBatch batch &#x3D; deque.pollFirst();</span><br><span class="line">                                        batch.records.close();</span><br><span class="line">                                        size +&#x3D; batch.records.sizeInBytes();</span><br><span class="line">                                        ready.add(batch);</span><br><span class="line">                                        batch.drainedMs &#x3D; now;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                this.drainIndex &#x3D; (this.drainIndex + 1) % parts.size();</span><br><span class="line">            &#125; while (start !&#x3D; drainIndex);</span><br><span class="line">            batches.put(node.id(), ready);</span><br><span class="line">        &#125;</span><br><span class="line">        return batches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Sender分析"><a href="#Sender分析" class="headerlink" title="Sender分析"></a>Sender分析</h1><p>流程: 首先根据RecordAccumulator的缓存情况,筛选出可以向哪些node节点发送信息,即之前介绍的ready方法,然后根据生产者与各个节点的连接情况,过滤node节点,生成相应的请求,每个node节点只生成一个请求,最后调用netWorkClient将将请求发送出去.</p>
<p>Sender实现了Runnable接口,并运行在单独的ioThread中,sender的run()方法调用了其重载run(long),这是sender方法的核心.</p>
<p><img src="/images/kafka/producer/sender%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="sender方法的时序图"></p>
<ol>
<li>从metadata获取kafka集群的元数据</li>
<li>调用RecordAccumulator.read()方法,根据RecordAccumulator的缓存情况,选出可以想那些node节点发送消息,返回readyCheckResult对象</li>
<li>如果readyCheckResult中标识有unknownLeadersExist,则调用Metadata的requestUpdate方法,标记需要更新kafka的集群消息.</li>
<li>针对readyCheckResult中readynodes集合,循环调用netWorkClient.Ready()方法,目的时检查网络IO是否符合发送消息的条件,不符合的将会从readyNodes节点中删除</li>
<li>调用RecordAccumulator.drain()方法获取待发送的消息集合.</li>
<li>调用RecordAccumulator.abortExpiredBatches()方法处理超时的消息,具体是遍历全部的recordBatch 调用maybeExpire()进行处理,如果已经超时调用recordBatch.done()方法出发自定义的callback,将RecordBatch从队列中移除,释放ByteBuffer.</li>
<li>调用Sender.createProduceRequests()方法将待发送的消息封装成ClientRequest</li>
<li>调用networkClient.send()方法,将ClientRequest写入kafkaChanel的send字段.</li>
<li>调用netWorkClient.poll()方法,将kafkaChannel.send字段中保存的clientRequest发送出去,还会处理客户端发回的相应,处理超时的请求,调用用户自定义的callback</li>
</ol>
<h2 id="创建请求"><a href="#创建请求" class="headerlink" title="创建请求"></a>创建请求</h2><p>![produce request和produce response](/images/kafka/producer/produce request和produce response.png)</p>
<p><img src="/images/kafka/producer/%E5%8D%8F%E8%AE%AE%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt="协议各个字段的解释"></p>
<p>createProduceRequests的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Transfer the record batches into a list of produce requests on a per-node basis</span><br><span class="line"> *&#x2F;</span><br><span class="line">private List&lt;ClientRequest&gt; createProduceRequests(Map&lt;Integer, List&lt;RecordBatch&gt;&gt; collated, long now) &#123;</span><br><span class="line">    List&lt;ClientRequest&gt; requests &#x3D; new ArrayList&lt;ClientRequest&gt;(collated.size());</span><br><span class="line">    for (Map.Entry&lt;Integer, List&lt;RecordBatch&gt;&gt; entry : collated.entrySet())</span><br><span class="line">    &#x2F;&#x2F;调用produceRequest方法,将发往同一node的RecordBatch分装成一个ClientRequest对象</span><br><span class="line">        requests.add(produceRequest(now, entry.getKey(), acks, requestTimeout, entry.getValue()));</span><br><span class="line">    return requests;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Create a produce request from the given record batches</span><br><span class="line"> *&#x2F;</span><br><span class="line">private ClientRequest produceRequest(long now, int destination, short acks, int timeout, List&lt;RecordBatch&gt; batches) &#123;</span><br><span class="line">    Map&lt;TopicPartition, ByteBuffer&gt; produceRecordsByPartition &#x3D; new HashMap&lt;TopicPartition, ByteBuffer&gt;(batches.size());</span><br><span class="line">    final Map&lt;TopicPartition, RecordBatch&gt; recordsByPartition &#x3D; new HashMap&lt;TopicPartition, RecordBatch&gt;(batches.size());</span><br><span class="line">    &#x2F;&#x2F;将recordBatch 列表按照partition分类,整理成上述两个集合</span><br><span class="line">    for (RecordBatch batch : batches) &#123;</span><br><span class="line">        TopicPartition tp &#x3D; batch.topicPartition;</span><br><span class="line">        produceRecordsByPartition.put(tp, batch.records.buffer());</span><br><span class="line">        recordsByPartition.put(tp, batch);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建produceRequest 和requestSend</span><br><span class="line">    ProduceRequest request &#x3D; new ProduceRequest(acks, timeout, produceRecordsByPartition);</span><br><span class="line">    RequestSend send &#x3D; new RequestSend(Integer.toString(destination),</span><br><span class="line">                                       this.client.nextRequestHeader(ApiKeys.PRODUCE),</span><br><span class="line">                                       request.toStruct());</span><br><span class="line">    RequestCompletionHandler callback &#x3D; new RequestCompletionHandler() &#123;</span><br><span class="line">        public void onComplete(ClientResponse response) &#123;</span><br><span class="line">            handleProduceResponse(response, recordsByPartition, time.milliseconds());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return new ClientRequest(now, acks !&#x3D; 0, send, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="KSelector"><a href="#KSelector" class="headerlink" title="KSelector"></a>KSelector</h2><p>在介绍netWorkClient之前,先了解其结构,它是属于kafka自己的包下的结构.</p>
<p><img src="/images/kafka/producer/kselector.png" alt="kselector"></p>
<h2 id="networkClient"><a href="#networkClient" class="headerlink" title="networkClient"></a>networkClient</h2><p><img src="/images/kafka/producer/networkClient.png" alt="networkClient"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-04-05/kafka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-04-05/kafka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">kafka源码剖析-快速入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-05 15:56:51" itemprop="dateCreated datePublished" datetime="2018-04-05T15:56:51+08:00">2018-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>kafka是一种分布式的,基于发布订阅的消息系统.由scala语言编写的.由linkedin于2011年开源,2012年10月从apache孵化器毕业的顶级项目.</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ol>
<li><strong>kafka具有近乎实时的消息处理能力</strong>,面对海量消息的查询和存储也能高效的处理.kafka消息存储在磁盘中,它以顺序读写的方式访问磁盘,从而避免了随机读写磁盘导致的性能瓶颈.</li>
<li><strong>kafka支持批量读写消息,并且会对消息进行批量压缩</strong>.这样提高了网络的利用率,也提高了压缩效率.</li>
<li><strong>kafka支持消息分区,每个分区中的消息可以保证顺序传输,而分区之间的消息可以并发操作,这样提高了kafka的并发能力</strong>.</li>
<li>kafka支持在线增加分区,支持在线水平扩展.</li>
<li>kafka支持为多个分区创建多个副本,其中只会有一个leader副本负责读写,其它副本负责与leader进行同步,提高了数据的容灾能力,kafka将会将leader副本均匀的分布在集群中的进服务器上,实现性能的最大化.</li>
</ol>
<h2 id="kafka的应用场景"><a href="#kafka的应用场景" class="headerlink" title="kafka的应用场景"></a>kafka的应用场景</h2><ol>
<li>kafka可以作为传统的消息中间件,实现消息队列和消息的发布订阅.</li>
<li>kafka可以作为系统中的数据总线,将其接入多个子系统,子系统可以将消息推送到kafka中进行保存,之后流转到目的的系统中.</li>
<li>kafka可以作为日志收集中心,多个系统产生的日志统一收集到kafka中,然后由数据分析平台进行统一管理.日志会被kafka持久化到硬盘,同时支持离线数据处理和实时数据处理.</li>
<li>kafka可以作为数据库主从同步的工具.</li>
</ol>
<h2 id="以kafka为中心的解决方案"><a href="#以kafka为中心的解决方案" class="headerlink" title="以kafka为中心的解决方案"></a>以kafka为中心的解决方案</h2><p>kafka的作用</p>
<ol>
<li><p><strong>解耦合</strong>,开发人员不需要知道各个子系统/服务/存储之间的关系,只需要面向kafka编程即可.两者只需要知道消息存放的topic和消息中的数据的格式即可.简单说,一个扮演生生产者一个扮演消费者,kafka是消息队列.</p>
</li>
<li><p><strong>数据持久化</strong>.网络传输时不可靠的,kafka把数据以消息的形式持久化到磁盘.即使kafka出现宕机,数据也不会丢失.kafka还提供了<strong>日志清理和日志压缩</strong>等功能.另外在磁盘操作中,耗时最长的是寻址时间,kafka采用<strong>顺序读写</strong>的方式,实现了高吞吐.</p>
</li>
<li><p><strong>扩展和容灾</strong> kafka的每个topic可以分为多个partition(分区),每个分区有多个replica(副本),实现了消息的冗余备份.各个分区中的消息是不同的,类似于数据库水平切分的思想.提高了并发读写能力.同一分区的不同副本之间存储的是相同的消息,副本之间是一主多存的关系,其中leader负责消息的读写,follower负责与leader进行备份,如果leader出现故障,follower重新选取leader副本提供服务.这样,通过分区的数量实现水平扩展,通过副本的数量提高容灾能力.</p>
<p>而且kafka的consumer端采用的是pull拉取消息,consumer端保存消息消费的具体位置,如果宕机重启后,consumer自己决定何时从哪消费消息;</p>
<p>kafka的consumer水平扩展,可以让多个consumer加入一个consumer组.在一个consumer group中,每个分区只能分配给一个consumer消费,当kafka服务端增加分区后,consumer group中可以添加consumer来提高consumer group的消费能力,当consumer group中的某个consumer出现故障时,会通过rebalance操作,将下线consumer消费的分区分配给其它consumer进行消费.当然一个consumer group可以订阅多个topic,每个consumer可以同时处理多个分区.</p>
</li>
<li><p><strong>顺序保证</strong>,kafka保证一个partition中的消息的有序性,不保证多个partition之间的数据有序性.</p>
</li>
<li><p><strong>缓冲和峰值处理能力</strong>,kafka的吞吐量较大,kafka能够顶住突发的访问压力,不会因为突发的压力造成系统崩溃不可用.</p>
</li>
<li><p><strong>异步通信</strong> ,提高处理其它的能力.</p>
</li>
</ol>
<h1 id="kafka的核心概念"><a href="#kafka的核心概念" class="headerlink" title="kafka的核心概念"></a>kafka的核心概念</h1><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息是kafka最基本的数据单位,消息是由一串字节构成,其中主要由key和value组成,其中key和value都是byte数组.key的主要作用时根据一定的策略将消息路由到指定的同一分区中,保证消息的顺序.</p>
<h2 id="topic-分区-partition-log"><a href="#topic-分区-partition-log" class="headerlink" title="topic/分区(partition)/log"></a>topic/分区(partition)/log</h2><p>topic是用于存储消息的逻辑概念,是一个消息集合.每个topic可以划分成多个分区,同一topic下的不同分区包含的信息是不同的.每个消息在被添加到分区中会被分配一个offset,它时消息在该分区中的唯一编号,kafka通过offset保证消息在分区内的顺序,同一分区中的消息是有序的,不同的分区内的消息,kafka不能保证其顺序性.</p>
<p>分区是kafka水平扩展的基础,增加kafka的分区可以增加kafka的并行处理能力.</p>
<p>分区在逻辑上对应一个log,当消息写入分区时,实际上是写入到了分区对应的log中.log是一个逻辑概念,对应磁盘上的一个文件夹,log由多个segment组成,每个segment对饮一个日志文件和索引文件.每一个日志文件是有大小限制的.索引文件采用稀疏索引的方式,大小并不会很大,在运行时将其映射到内存,提高索引速度.</p>
<p>kafka的topic在每个机器上是以文件存储的,而这些文件呢,会分目录,partition就是文件的目录.</p>
<h2 id="保留策略和日志压缩"><a href="#保留策略和日志压缩" class="headerlink" title="保留策略和日志压缩"></a>保留策略和日志压缩</h2><p>kafka中有两种保留策略,一种时根据消息保留的时间,一种时根据topic存储消息的大小.kafka有一个线程定时检查消息的大小.</p>
<p>此外kafka还会进行日志压缩,消息的key与value对应的值时不断变化的,消费者只关心最新value值,开启kafka的日志压缩功能,定期将相同可以的消息进行合并,只留最新的value的值.</p>
<h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><p>一个kafka服务器就是一个broker,broker的主要工作就是接收生产者的消息,分配offset,保存到硬盘.接收消费者和其它broker的请求,并根据请求类型处理并返回相应.</p>
<h2 id="副本-replica"><a href="#副本-replica" class="headerlink" title="副本(replica)"></a>副本(replica)</h2><p>kafka对消息进行冗余备份,每个partition有多个副本,每个副本中的消息有多个副本.选出一个leader副本负责读写请求.follower副本只是进行冗余备份和容错.</p>
<h2 id="ISR-In-Sync-Replica"><a href="#ISR-In-Sync-Replica" class="headerlink" title="ISR (In-Sync Replica)"></a>ISR (In-Sync Replica)</h2><p>ISR表示目前可用且与leader相差不多的副本集合,在broker宕机后重新选举新的leader继续对外提供服务.ISR集合必须满足以下条件</p>
<ol>
<li>副本所在的节点必须维持着与zookeeper的联系</li>
<li>副本最后一条消息的offset与leader副本的最有一条消息的offset的差值不能超过指定值.</li>
</ol>
<p>某个副本可能由于某种原因从ISR集合中退出,在满足以上条件后,会重新加入ISR集合.</p>
<h2 id="HW-LEO"><a href="#HW-LEO" class="headerlink" title="HW/LEO"></a>HW/LEO</h2><p>highWaterMark标记了一个特殊的offset,当消费者消费消息的时候,只能拉取到HW之前的消息,HW之后的消息对消费者来说时不可见的,HW也是由LEADER副本管理,当ISR集合中全部非follower副本都拉取HW制定消息进行同步后,leader副本会增加hw的值.</p>
<p>log end offset 是所有的副本都会标记的一个offset,它指向最后追加到当前副本的最后一个消息,当生产者向leader追加消息的时候,leader副本的leo标记会增加;当follower副本成功从leader副本中拉取消息更新到本地的时候,foller副本的leo就会增加,当isr集合中的所有的副本都完成了该消息的leo增加,则leader副本会增加HW.</p>
<h2 id="副本的同步复制"><a href="#副本的同步复制" class="headerlink" title="副本的同步复制"></a>副本的同步复制</h2><p>同步复制要求所有的能工作的follower副本完成复制,这条消息才会被认为提交成功.一旦有一个follower副本出现故障,就导致HW无法完成递增,消息就无法提交,生产者拿不到消息,这样故障的follower副本会拖慢整个体系的性能.</p>
<h2 id="副本的异步复制"><a href="#副本的异步复制" class="headerlink" title="副本的异步复制"></a>副本的异步复制</h2><p>异步复制中,leader副本收到生产者推送的消息后,就会被认为该消息提交成功,follower副本异步的从leader中同步消息.这样设计虽然避免了同步复制的问题,但同样存在一定的风险.</p>
<p>假设follower副本同步的消息比较慢,它保存的消息圆圆落后于leader副本,此时leader副本突然宕机进行选举的时候,副本会丢失消息.</p>
<p>此时ISR集合策略解决了这种问题. 当follower复制消息较慢的时候,副本被踢出isr集合.follower副本在更新消息的时候时批量写磁盘.</p>
<h2 id="Cluster-controller"><a href="#Cluster-controller" class="headerlink" title="Cluster/controller"></a>Cluster/controller</h2><p>多个broker可以做成一个cluster对外提供服务,每个cluster当中会选举出一个broker担任controller,controller是kafka集群的指挥中心,其它broker听从controller指挥实现功能,</p>
<p>controller负责管理分区的状态,管理每个分区的副本状态/监听zookeeper中的数据变化等工作,controller也是一主多从的实现.</p>
<h2 id="生产者-producer"><a href="#生产者-producer" class="headerlink" title="生产者(producer)"></a>生产者(producer)</h2><p>生产者的主要工作时生产消息,并将消息安装一定的规则推送到topic的分区中.例如根据消息的key的hash值选择分区或按照轮训全部分区的方式.</p>
<p>ACK，是指服务器收到消息之后，是存下来之后，再给客户端返回，还是直接返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">该参数是设置的,request.required.acks</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;0: 不等服务器ack就返回了，性能最高，可能丢数据 </span><br><span class="line">&#x2F;&#x2F;1. leader确认消息存下来了，再返回 </span><br><span class="line">&#x2F;&#x2F;all: leader和当前ISR中所有replica都确认消息存下来了，再返回（这种方式最可靠）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同步发送和异步发送"><a href="#同步发送和异步发送" class="headerlink" title="同步发送和异步发送"></a>同步发送和异步发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">所谓异步发送，就是指客户端有个本地缓冲区，消息先存放到本地缓冲区，然后有后台线程来发送。</span><br><span class="line"></span><br><span class="line">在异步发送下，有以下4个参数需要配置：</span><br><span class="line">（1）队列的最大长度 </span><br><span class="line">buffer.memory &#x2F;&#x2F;缺省为33554432, 即32M</span><br><span class="line"></span><br><span class="line">（2）队列满了，客户端是阻塞，还是抛异常出来（缺省是true) </span><br><span class="line">block.on.buffer.full </span><br><span class="line">&#x2F;&#x2F;true: 阻塞消息 </span><br><span class="line">&#x2F;&#x2F;false：抛异常</span><br><span class="line"></span><br><span class="line">（3）发送的时候，可以批量发送的数据量 </span><br><span class="line">batch.size &#x2F;&#x2F;缺省16384字节，即16K</span><br><span class="line"></span><br><span class="line">（4）最长等多长时间，批量发送 </span><br><span class="line">linger.ms &#x2F;&#x2F;缺省是0 </span><br><span class="line">&#x2F;&#x2F;类似TCP&#x2F;IP协议中的linger algorithm，&gt; 0 表示发送的请求，会在队列中积攥，然后批量发送。</span><br><span class="line"></span><br><span class="line">很显然，异步发送可以提高发送的性能，但一旦客户端挂了，就可能丢数据。</span><br><span class="line">对于RabbitMQ, ActiveMQ，他们都强调可靠性，因此不允许非ACK的发送，也没有异步发送模式。Kafka提供了这个灵活性，允许使用者在性能与可靠性之间做权衡。</span><br><span class="line"></span><br><span class="line">（5）消息的最大长度 </span><br><span class="line">max.request.size &#x2F;&#x2F;缺省是1048576，即1M</span><br><span class="line"></span><br><span class="line">这个参数会影响batch的大小，如果单个消息的大小 &gt; batch的最大值(16k)，那么batch会相应的增大</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="消费者-consumer"><a href="#消费者-consumer" class="headerlink" title="消费者(consumer)"></a>消费者(consumer)</h2><p>消费者的主要工作时从topic中拉取消息,对消息进行消费.每个消费者消费哪个分区,消费到哪个位置都是有consumer自己维护的,这样减少了server端的开销,同时减少服务端宕机带来的风险.</p>
<p>消费者采用pull的方式进行消费,这样消费者可以根据自己的消费能力进行处理.</p>
<p>在kafka里面，是保证消息不漏，也就是at least once。至于重复消费问题，需要业务自己去保证，比如业务加判重表。</p>
<h2 id="消费者组-consumer-group"><a href="#消费者组-consumer-group" class="headerlink" title="消费者组(consumer group)"></a>消费者组(consumer group)</h2><p>在kafka中,多个consumer组成一个consumer group ,一个consumer只能属于一个consumer group.consumer group保证其订阅的topic的每个分区只能被分配给此consumer group中的一个消费者处理.如果不同的consumer group 订阅了同一个topic ,各个消费者组之间彼此不会干扰.</p>
<p>kafka消费者组是逻辑上的订阅者.kafka还通过消费者组实现了水平扩展和故障转移.</p>
<p>当消费者数量超过分区的数量时,会造成消费者分不到分区,从而造成消费者的浪费.</p>
<h2 id="kafka集群的架构"><a href="#kafka集群的架构" class="headerlink" title="kafka集群的架构"></a>kafka集群的架构</h2><p><img src="/images/kafka/introduce/kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt="kafka集群的架构"></p>
<p>生产者会根据业务逻辑生产消息,之后根据路由规则将消息发送到制定分区的leader副本所在的broker上,在kafka的服务端接收到消息后,会将消息追加到log中保存,之后follower副本会与leader副本进行同步,当isr集合中所有副本都完成了消息的同步后,则leader副本的hw会增加,并向生产者返回相应,</p>
<p>当消费者加入到consumer group时,会出发rebalance操作将分区分配给不同的消费者消费.随后,消费者会会恢复其消费位置,并向kafka服务端发送拉取的请求,leader副本会验证请求的offset及其它信息,最后返回.</p>
<h1 id="搭建kafka源码环境"><a href="#搭建kafka源码环境" class="headerlink" title="搭建kafka源码环境"></a>搭建kafka源码环境</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/he582754810/article/details/53837142">scala环境</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hejjiiee/article/details/53510209">安装grandle</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yan_Chou/article/details/53322429">安装zookeeper环境</a></p>
</li>
<li><p>源码构建</p>
</li>
</ol>
<p>在kafka源码目录下,执行gradle idea命令</p>
<p>遇到问题 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jun1019/p/7440468.html">源码构建报错</a></p>
<ol start="5">
<li>安装scala插件</li>
</ol>
<p>在idea中安装scala插件</p>
<ol start="6">
<li>配置启动kafka</li>
</ol>
<p>在kafka服务端使用log4j输出日志,启动前需要把config下的 log4j.properties 配置文件放到core的/scala/main/scala 下,然后运行程序</p>
<ol start="7">
<li>kafka启动参数配置</li>
</ol>
<p><img src="/images/kafka/introduce/kakfa%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE.png" alt="kakfa启动参数配置"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-02-10/linux%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-02-10/linux%E5%85%A5%E9%97%A8-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">linux入门-用户管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-10 00:40:10" itemprop="dateCreated datePublished" datetime="2018-02-10T00:40:10+08:00">2018-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux用户和用户组"><a href="#linux用户和用户组" class="headerlink" title="linux用户和用户组"></a>linux用户和用户组</h1><p>linux是一个多用户分时系统,想要使用系统必须使用账号,而且账号必须设置密码.各个用户可以设置不同的文件权限,保证不同用户的数据安全.各个账号都有对应的用户id和用户组id.</p>
<h2 id="UID和GID"><a href="#UID和GID" class="headerlink" title="UID和GID"></a>UID和GID</h2><p>为了区分不同的用户,我们可以根据用户名去区分,但是对于OS,它其实是没有意义的字符串.linux采用32位的整数来记录用户id,简称UID,计算机会记录用户id和用户名称的关系.linux用户分为三种:普通用户,根用户和系统用户.</p>
<ul>
<li>普通用户</li>
</ul>
<p>普通用户是指使用linux系统的真是用户,这类用户的用户名/密码/权限都有详细的设置.普通用户只能在家目录/系统临时目录或其它授权的目录下操作.普通用户的id从500开始.</p>
<ul>
<li>根用户</li>
</ul>
<p>根用户也是root用户,它的id为0,也就是超级用户.root用户拥有对系统的完全控制权.</p>
<ul>
<li>系统用户</li>
</ul>
<p>系统用户是指系统运行时必须要有的用户,但并不是真实的使用者.id范围为1至500</p>
<h2 id="查看当前用户的groupId和userId"><a href="#查看当前用户的groupId和userId" class="headerlink" title="查看当前用户的groupId和userId"></a>查看当前用户的groupId和userId</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ id</span><br><span class="line">uid&#x3D;1000(zhuningning) gid&#x3D;1000(zhuningning) 组&#x3D;1000(zhuningning),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</span><br></pre></td></tr></table></figure>
<h2 id="查看用户所属的用户组"><a href="#查看用户所属的用户组" class="headerlink" title="查看用户所属的用户组"></a>查看用户所属的用户组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ groups</span><br><span class="line">zhuningning adm cdrom sudo dip plugdev lpadmin sambashare</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看当前登录的用户"><a href="#查看当前登录的用户" class="headerlink" title="查看当前登录的用户"></a>查看当前登录的用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ who</span><br><span class="line">zhuningning tty7         2018-05-31 02:04 (:0)</span><br><span class="line">zhuningning@ubuntu:~$ w</span><br><span class="line"> 23:23:19 up 21:19,  1 user,  load average: 0.47, 0.52, 0.31</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">zhuningn tty7     :0               02:04   21:19m  2:18   0.20s &#x2F;sbin&#x2F;upstart --user</span><br><span class="line">zhuningning@ubuntu:~$ users</span><br><span class="line">zhuningning</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="记录系统的用户名和密码的信息的文件"><a href="#记录系统的用户名和密码的信息的文件" class="headerlink" title="记录系统的用户名和密码的信息的文件"></a>记录系统的用户名和密码的信息的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;passwd</span><br><span class="line">cat &#x2F;etc&#x2F;shadow</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看隐藏的文件"><a href="#查看隐藏的文件" class="headerlink" title="查看隐藏的文件"></a>查看隐藏的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;home$ ls -la</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  5 root        root        4096 Sep 10  2017 .</span><br><span class="line">drwxr-xr-x 24 root        root        4096 May  9 07:06 ..</span><br><span class="line">drwxr-xr-x  2        1003        1003 4096 Sep 10  2017 chenweijie</span><br><span class="line">drwxr-xr-x  2 chenwj      chenwj      4096 Sep 10  2017 chenwj</span><br><span class="line">drwxr-xr-x 51 zhuningning zhuningning 4096 May 31 02:04 zhuningning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><ol>
<li>adduser john 添加用户</li>
<li>useradd -u 555 user1   为用户user1指定uId ,当然该id必须是唯一的</li>
<li>useradd -g user1 user2   为用户user2指定用户组为user1 </li>
<li>useradd -d /home/mydir3 user3  为user3指定家目录</li>
</ol>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>用户创建后没有密码是不可以登录系统的，只有设置了密码才可以登录系统。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;home$ sudo passwd chenweijie</span><br><span class="line">输入新的 UNIX 密码： </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于添加用户以及授权的操作"><a href="#关于添加用户以及授权的操作" class="headerlink" title="关于添加用户以及授权的操作"></a>关于添加用户以及授权的操作</h2><p>1.adduser  chenweijie 添加用户</p>
<p>2.授权 修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Allow root to run any commands anywhere</span><br><span class="line">root    ALL&#x3D;(ALL)     ALL</span><br><span class="line">chenweijie   ALL&#x3D;(ALL)     ALL</span><br></pre></td></tr></table></figure>

<p>3.语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     useradd 选项 用户名</span><br><span class="line">语义:</span><br><span class="line">  -c comment            指定一段注释性描述。</span><br><span class="line">  -d 目录                   指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line">  -g 用户组               指定用户所属的用户组。</span><br><span class="line">  -G 用户组 用户组   指定用户所属的附加组。</span><br><span class="line">  -s Shell文件            指定用户的登录Shell。</span><br><span class="line">  -u 用户号               指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class="line">  用户名                   指定新用户的登录名。</span><br><span class="line">userdel 选项 用户名</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">  -r,  把用户的主目录一起删除。</span><br><span class="line"> usermod 选项 用户名</span><br><span class="line">选项:</span><br><span class="line">   包括-c, -d, -m, -g, -G, -s, -u以及-o等,</span><br><span class="line">   这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：</span><br><span class="line">   -l 新用户名  指定一个新的账号，即将原来的用户名改为新的用户名。</span><br><span class="line"></span><br><span class="line">usermod -G groupname username 给已有的用户增加工作组</span><br><span class="line">newgrp   groupName 切换到用户组 以获取该组的权限</span><br><span class="line">groups 查看该当前用户所属的用户组，第一个是主要用户组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="关于用户权限的操作"><a href="#关于用户权限的操作" class="headerlink" title="关于用户权限的操作"></a>关于用户权限的操作</h2><p>添加组的命令： groupadd 组名 。 （在root管理权限）</p>
<p>查看linux中所有组的信息： cat /etc/group 。</p>
<p>创建用户，并同时指定将该用户分配到哪个组里： useradd -g 组名 用户名。 （在root管理权限）</p>
<p>查看linux中所有用户的信息： cat /etc/passwd 。</p>
<p>更改某个用户所在的组： usermod -g 组名 用户名。 （在root管理权限）</p>
<h2 id="用户的切换"><a href="#用户的切换" class="headerlink" title="用户的切换"></a>用户的切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exit 退出当前用户。</span><br><span class="line"></span><br><span class="line">su - 切换到用root用户是，不但身份变成了root ，而且还可以是用root的用户环境。</span><br><span class="line"></span><br><span class="line">sudo 是在sudo后加上要使用的命令，但是需要为该用户配置 &#x2F;etc&#x2F;sudoers 中的权限 </span><br><span class="line">        root    ALL&#x3D;(ALL:ALL) ALL 改命令表示该用户可以在任何地方登录后执行任何人的任何命令。</span><br><span class="line">        但是每次需要输入密码，如果想要不输入密码，则可以在最后设置为 NOPASSWD :ALL</span><br><span class="line">su是切换用户，su -是切换用户并且使用用户的环境，而sudo并没有切换用户，而是使用用户的身份和权限执行了命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例行任务管理"><a href="#例行任务管理" class="headerlink" title="例行任务管理"></a>例行任务管理</h2><p>1.单一时刻执行一次任务  at      atrm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at  now + 20 minutes </span><br><span class="line">&#x2F;sbin&#x2F;shutdown -h now</span><br><span class="line">执行组合键 ctrl+D</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.atq</p>
<p>查看任务队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ atq</span><br><span class="line">4    Fri Jun  1 01:05:00 2018 a zhuningning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.atrm taskNum</p>
<p>删除任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ atrm 4</span><br><span class="line">zhuningning@ubuntu:~$ atq</span><br><span class="line">zhuningning@ubuntu:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.周期性的执行任务  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先启动:service crond start </span><br><span class="line"></span><br><span class="line">编辑：crontab -e</span><br><span class="line"> </span><br><span class="line">查看任务:crontab -l </span><br><span class="line"></span><br><span class="line">删除所有的任务 : crontab -r </span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-02-08/redis%E9%9B%86%E7%BE%A4-Sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-02-08/redis%E9%9B%86%E7%BE%A4-Sentinel/" class="post-title-link" itemprop="url">redis集群-Sentinel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-08 00:58:20" itemprop="dateCreated datePublished" datetime="2018-02-08T00:58:20+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis Sentinel是用来实现Redis(2.8+)高可用的一套解决方案。Redis Sentinel由两个部分组成：由一个或者多个Sentinel实例组成Sentinel系统；<strong>由一个主Redis服务器</strong>(Master Redis)和多个从Redis服务器(Slave Redis)组成主从备份的Redis系统。</p>
<p>Sentinel系统本身是一个分布式的系统，它的作用是监视Redis服务器，在Master Redis下线时，自动将某个Slave Redis提升为新的主服务器。Redis系统由Master Redis处理客户端的命令请求，Slave Redis作为主服务器的备份而存在。</p>
<h1 id="Redis-Sentinel主要作用"><a href="#Redis-Sentinel主要作用" class="headerlink" title="Redis Sentinel主要作用"></a>Redis Sentinel主要作用</h1><ul>
<li>监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒(Notification)：当被监控的某个Redis服务器出现问题时， Sentinel可以通过API向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<h1 id="构建Redis-Sentinel集群"><a href="#构建Redis-Sentinel集群" class="headerlink" title="构建Redis Sentinel集群"></a>构建Redis Sentinel集群</h1><p>主多从的Redis系统中，可以使用多个Sentinel进行监控任务以保证系统足够稳健。此时，不仅Sentinel会同时监控主数据库和从数据库，Sentinel之间也会相互监控.</p>
<h2 id="redis服务器配置-redis-conf文件"><a href="#redis服务器配置-redis-conf文件" class="headerlink" title="redis服务器配置 redis.conf文件"></a>redis服务器配置 redis.conf文件</h2><p>主节点(由于主从节点有可能切换所以涉及密码的两个参数每个节点都需要配置)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">requirepass test</span><br><span class="line">masterauth test</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从节点1 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">requirepass test</span><br><span class="line">masterauth test</span><br><span class="line">slaveof 127.0.0.1 7000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从节点2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7002</span><br><span class="line">requirepass test</span><br><span class="line">masterauth test</span><br><span class="line">slaveof 127.0.0.1 7000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置Sentinel-conf-三个文件只有port和日志目录不一样"><a href="#配置Sentinel-conf-三个文件只有port和日志目录不一样" class="headerlink" title="配置Sentinel.conf (三个文件只有port和日志目录不一样)"></a>配置Sentinel.conf (三个文件只有port和日志目录不一样)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">port 27000</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 2</span><br><span class="line">sentinel auth-pass mymaster test</span><br><span class="line">logfile &quot;&#x2F;usr&#x2F;local&#x2F;redisSentinel&#x2F;7000&#x2F;sentinelLog&#x2F;log.log&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置文件解释"><a href="#配置文件解释" class="headerlink" title="配置文件解释"></a>配置文件解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">port 27000</span><br><span class="line">Sentinel实例之间的通讯端口，该端口号默认为26379。</span><br><span class="line"></span><br><span class="line">bind 127.0.0.1</span><br><span class="line">Sentinel默认会绑定到127.0.0.1，这里要在多台机器间通信，我们将它绑定到主机IP上。</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">Sentinel去监视一个名为mymaster的主服务器，这个主服务器的IP地址为127.0.0.1  ，端口号为7000。将这个主服务器判断为失效至少需要2个Sentinel同意，一般设置为N&#x2F;2+1(N为Sentinel总数)。只要同意Sentinel的数量不达标，自动故障迁移就不会执行。</span><br><span class="line"></span><br><span class="line">不过要注意，无论你设置要多少个Sentinel同意才能判断一个服务器失效， 一个Sentinel都需要获得系统中多数Sentinel的支持，才能发起一次自动故障迁移，并预留一个给定的配置纪元。(configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号)。</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">down-after-milliseconds选项指定了Sentinel认为服务器已经断线所需的毫秒数。如果服务器在给定的毫秒数之内，没有返回Sentinel发送的PING命令的回复，或者返回一个错误，那么Sentinel将这个服务器标记为主观下线(subjectively down，简称SDOWN)。</span><br><span class="line"></span><br><span class="line">不过只有一个Sentinel将服务器标记为主观下线并不一定会引起服务器的自动故障迁移，只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线(objectively down，简称ODOWN)， 这时自动故障迁移才会执行。将服务器标记为客观下线所需的Sentinel数量由对主服务器的配置(sentinel monitor参数)决定。</span><br><span class="line"></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">如果在多少毫秒内没有把宕掉的那台Master恢复，那Sentinel认为这是一次真正的宕机。在下一次选取时排除该宕掉的Master作为可用的节点，然后等待一定的设定值的毫秒数后再来探测该节点是否恢复，如果恢复就把它作为一台Slave加入Sentinel监测节点群，并在下一次切换时为他分配一个”选取号”。</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs mymaster 2</span><br><span class="line">parallel-syncs选项指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步。这个数字越小，完成故障转移所需的时间就越长。</span><br><span class="line"></span><br><span class="line">如果从服务器被设置为允许使用过期数据集(slave-serve-stale-data选项)， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求。因为尽管复制过程的绝大部分步骤都不会阻塞从服务器，但从服务器在载入主服务器发来的RDB文件时，仍然会造成从服务器在一段时间内不能处理命令请求。</span><br><span class="line"></span><br><span class="line">如果全部从服务器一起对新的主服务器进行同步，那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。你可以通过将这个值设为1来保证每次只有一个从服务器处于不能处理命令请求的状态。</span><br><span class="line"></span><br><span class="line">sentinel auth-pass mymaster test</span><br><span class="line">当Master设置了密码时，Sentinel连接Master和Slave时需要通过设置参数auth-pass配置相应密码。</span><br><span class="line"></span><br><span class="line">logfile &#x2F;usr&#x2F;local&#x2F;redisSentinel&#x2F;7000&#x2F;sentinelLog&#x2F;log.log</span><br><span class="line">日志文件所在位置，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="启动sentinel集群"><a href="#启动sentinel集群" class="headerlink" title="启动sentinel集群"></a>启动sentinel集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;src&#x2F;redis-sentinel sentinel.conf &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="通过redis客户端工具查看当前Sentinel的信息"><a href="#通过redis客户端工具查看当前Sentinel的信息" class="headerlink" title="通过redis客户端工具查看当前Sentinel的信息"></a>通过redis客户端工具查看当前Sentinel的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSentinel&#x2F;7000$ .&#x2F;src&#x2F;redis-cli -p 27000 -h 127.0.0.1 INFO Sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name&#x3D;mymaster,status&#x3D;ok,address&#x3D;127.0.0.1:7000,slaves&#x3D;2,sentinels&#x3D;3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Sentinel启动后会输出类似的日志"><a href="#Sentinel启动后会输出类似的日志" class="headerlink" title="Sentinel启动后会输出类似的日志"></a>Sentinel启动后会输出类似的日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21    6839:X 09 Feb 01:14:11.494 # Sentinel ID is b9095b246a20441e432f693f9b9042d7bb605372</span><br><span class="line">22    6839:X 09 Feb 01:14:11.494 # +monitor master mymaster 127.0.0.1 7000 quorum 2</span><br><span class="line">23    6839:X 09 Feb 01:14:11.495 * +slave slave 127.0.0.1:7001 127.0.0.1 7001 @ mymaster 127.0.0.1 7000</span><br><span class="line">24    6839:X 09 Feb 01:14:11.527 * +slave slave 127.0.0.1:7002 127.0.0.1 7002 @ mymaster 127.0.0.1 7000</span><br><span class="line">25    6839:X 09 Feb 01:18:56.295 * +sentinel sentinel 5a18eecd2dcb3ce949a30d15e12dc4e14d3dc73b 127.0.0.1 27001 @ mymaster 127.0.0.1 7000</span><br><span class="line">26    6839:X 09 Feb 01:20:54.521 * +sentinel sentinel 7df87dde32ceeced13dfd020f99c914414b9f474 127.0.0.1 27002 @ mymaster 127.0.0.1 7000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>+slave和+sentinel分别代表成功发现了从数据库和其他Sentinel。</p>
<h2 id="sentinel-conf文件生成信息"><a href="#sentinel-conf文件生成信息" class="headerlink" title="sentinel.conf文件生成信息"></a>sentinel.conf文件生成信息</h2><p>重新打开sentinel.conf文件，发现Sentinel自动生成了一些信息，记录了监控过程中的状态变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">199    # Generated by CONFIG REWRITE</span><br><span class="line">200    sentinel config-epoch mymaster 0</span><br><span class="line">201    sentinel leader-epoch mymaster 0</span><br><span class="line">202    sentinel known-slave mymaster 127.0.0.1 7001</span><br><span class="line">203    sentinel known-slave mymaster 127.0.0.1 7002</span><br><span class="line">204    sentinel known-sentinel mymaster 127.0.0.1 27002 7df87dde32ceeced13dfd020f99c914414b9f474</span><br><span class="line">205    sentinel known-sentinel mymaster 127.0.0.1 27001 5a18eecd2dcb3ce949a30d15e12dc4e14d3dc73b</span><br><span class="line">206    sentinel current-epoch 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看Sentinel监控的主从服务器"><a href="#查看Sentinel监控的主从服务器" class="headerlink" title="查看Sentinel监控的主从服务器"></a>查看Sentinel监控的主从服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSentinel&#x2F;7000$ .&#x2F;src&#x2F;redis-cli -h 127.0.0.1 -p 27000 </span><br><span class="line">127.0.0.1:27000&gt; sentinel master mymaster</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;mymaster&quot;</span><br><span class="line"> 3) &quot;ip&quot;</span><br><span class="line"> 4) &quot;127.0.0.1&quot;</span><br><span class="line"> 5) &quot;port&quot;</span><br><span class="line"> 6) &quot;7000&quot;</span><br><span class="line"> 7) &quot;runid&quot;</span><br><span class="line"> 8) &quot;1d998c438067f7fd3ad51742380bf16257fd0877&quot;</span><br><span class="line"> 9) &quot;flags&quot;</span><br><span class="line">10) &quot;master&quot;</span><br><span class="line">11) &quot;link-pending-commands&quot;</span><br><span class="line">12) &quot;0&quot;</span><br><span class="line">13) &quot;link-refcount&quot;</span><br><span class="line">14) &quot;1&quot;</span><br><span class="line">15) &quot;last-ping-sent&quot;</span><br><span class="line">16) &quot;0&quot;</span><br><span class="line">17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">18) &quot;168&quot;</span><br><span class="line">19) &quot;last-ping-reply&quot;</span><br><span class="line">20) &quot;168&quot;</span><br><span class="line">21) &quot;down-after-milliseconds&quot;</span><br><span class="line">22) &quot;5000&quot;</span><br><span class="line">23) &quot;info-refresh&quot;</span><br><span class="line">24) &quot;6675&quot;</span><br><span class="line">25) &quot;role-reported&quot;</span><br><span class="line">26) &quot;master&quot;</span><br><span class="line">27) &quot;role-reported-time&quot;</span><br><span class="line">28) &quot;1804688&quot;</span><br><span class="line">29) &quot;config-epoch&quot;</span><br><span class="line">30) &quot;0&quot;</span><br><span class="line">31) &quot;num-slaves&quot;</span><br><span class="line">32) &quot;2&quot;</span><br><span class="line">33) &quot;num-other-sentinels&quot;</span><br><span class="line">34) &quot;2&quot;</span><br><span class="line">35) &quot;quorum&quot;</span><br><span class="line">36) &quot;2&quot;</span><br><span class="line">37) &quot;failover-timeout&quot;</span><br><span class="line">38) &quot;180000&quot;</span><br><span class="line">39) &quot;parallel-syncs&quot;</span><br><span class="line">40) &quot;2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Sentinel验证"><a href="#Sentinel验证" class="headerlink" title="Sentinel验证"></a>Sentinel验证</h1><p>我们让7000节点上的mymaster主动休眠30秒来观察failover过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 -h 127.0.0.1 -a test DEBUG sleep 30</span><br></pre></td></tr></table></figure>
<p>日志如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSentinel&#x2F;7000$ .&#x2F;src&#x2F;redis-cli -p 7000 -h 127.0.0.1 -a test DEBUG sleep 30</span><br><span class="line">5303:M 09 Feb 01:47:41.392 # Connection with master lost.</span><br><span class="line">5303:M 09 Feb 01:47:41.393 * Caching the disconnected master state.</span><br><span class="line">5303:M 09 Feb 01:47:41.393 * Discarding previously cached master state.</span><br><span class="line">5303:M 09 Feb 01:47:41.393 * MASTER MODE enabled (user request from &#39;id&#x3D;5 addr&#x3D;127.0.0.1:36346 fd&#x3D;8 name&#x3D;sentinel-5a18eecd-cmd age&#x3D;1727 idle&#x3D;0 flags&#x3D;x db&#x3D;0 sub&#x3D;0 psub&#x3D;0 multi&#x3D;3 qbuf&#x3D;0 qbuf-free&#x3D;32768 obl&#x3D;36 oll&#x3D;0 omem&#x3D;0 events&#x3D;r cmd&#x3D;exec&#39;)</span><br><span class="line">5303:M 09 Feb 01:47:41.395 # CONFIG REWRITE executed with success.</span><br><span class="line">5303:M 09 Feb 01:47:41.463 * 1 changes in 900 seconds. Saving...</span><br><span class="line">5303:M 09 Feb 01:47:41.464 * Background saving started by pid 9725</span><br><span class="line">9725:C 09 Feb 01:47:41.506 * DB saved on disk</span><br><span class="line">9725:C 09 Feb 01:47:41.507 * RDB: 8 MB of memory used by copy-on-write</span><br><span class="line">5303:M 09 Feb 01:47:41.565 * Background saving terminated with success</span><br><span class="line">5312:S 09 Feb 01:47:42.196 # Connection with master lost.</span><br><span class="line">5312:S 09 Feb 01:47:42.196 * Caching the disconnected master state.</span><br><span class="line">5312:S 09 Feb 01:47:42.196 * Discarding previously cached master state.</span><br><span class="line">5312:S 09 Feb 01:47:42.197 * SLAVE OF 127.0.0.1:7001 enabled (user request from &#39;id&#x3D;5 addr&#x3D;127.0.0.1:38372 fd&#x3D;8 name&#x3D;sentinel-5a18eecd-cmd age&#x3D;1728 idle&#x3D;0 flags&#x3D;x db&#x3D;0 sub&#x3D;0 psub&#x3D;0 multi&#x3D;3 qbuf&#x3D;133 qbuf-free&#x3D;32635 obl&#x3D;36 oll&#x3D;0 omem&#x3D;0 events&#x3D;r cmd&#x3D;exec&#39;)</span><br><span class="line">5312:S 09 Feb 01:47:42.200 # CONFIG REWRITE executed with success.</span><br><span class="line">5312:S 09 Feb 01:47:42.284 * 1 changes in 900 seconds. Saving...</span><br><span class="line">5312:S 09 Feb 01:47:42.286 * Background saving started by pid 9726</span><br><span class="line">5312:S 09 Feb 01:47:42.286 * Connecting to MASTER 127.0.0.1:7001</span><br><span class="line">5312:S 09 Feb 01:47:42.287 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">5312:S 09 Feb 01:47:42.287 * Non blocking connect for SYNC fired the event.</span><br><span class="line">5312:S 09 Feb 01:47:42.287 * Master replied to PING, replication can continue...</span><br><span class="line">5312:S 09 Feb 01:47:42.287 * Partial resynchronization not possible (no cached master)</span><br><span class="line">5303:M 09 Feb 01:47:42.287 * Slave 127.0.0.1:7002 asks for synchronization</span><br><span class="line">5303:M 09 Feb 01:47:42.287 * Full resync requested by slave 127.0.0.1:7002</span><br><span class="line">5303:M 09 Feb 01:47:42.287 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">5303:M 09 Feb 01:47:42.289 * Background saving started by pid 9727</span><br><span class="line">5312:S 09 Feb 01:47:42.290 * Full resync from master: 4e882289bf41e7cef05f83f5e1d81fb8ad97e63e:348338</span><br><span class="line">9726:C 09 Feb 01:47:42.345 * DB saved on disk</span><br><span class="line">9726:C 09 Feb 01:47:42.346 * RDB: 6 MB of memory used by copy-on-write</span><br><span class="line">9727:C 09 Feb 01:47:42.366 * DB saved on disk</span><br><span class="line">9727:C 09 Feb 01:47:42.366 * RDB: 8 MB of memory used by copy-on-write</span><br><span class="line">5303:M 09 Feb 01:47:42.368 * Background saving terminated with success</span><br><span class="line">5312:S 09 Feb 01:47:42.368 * MASTER &lt;-&gt; SLAVE sync: receiving 77 bytes from master</span><br><span class="line">5303:M 09 Feb 01:47:42.368 * Synchronization with slave 127.0.0.1:7002 succeeded</span><br><span class="line">5312:S 09 Feb 01:47:42.368 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">5312:S 09 Feb 01:47:42.368 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class="line">5312:S 09 Feb 01:47:42.368 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br><span class="line">5312:S 09 Feb 01:47:42.387 * Background saving terminated with success</span><br><span class="line">OK</span><br><span class="line">5296:M 09 Feb 01:48:05.885 # Connection with slave client id #2 lost.</span><br><span class="line">5296:M 09 Feb 01:48:05.885 # Connection with slave client id #3 lost.</span><br><span class="line">5296:S 09 Feb 01:48:15.954 * SLAVE OF 127.0.0.1:7001 enabled (user request from &#39;id&#x3D;26 addr&#x3D;127.0.0.1:34652 fd&#x3D;26 name&#x3D;sentinel-b9095b24-cmd age&#x3D;10 idle&#x3D;0 flags&#x3D;x db&#x3D;0 sub&#x3D;0 psub&#x3D;0 multi&#x3D;3 qbuf&#x3D;0 qbuf-free&#x3D;32768 obl&#x3D;36 oll&#x3D;0 omem&#x3D;0 events&#x3D;r cmd&#x3D;exec&#39;)</span><br><span class="line">5296:S 09 Feb 01:48:15.956 # CONFIG REWRITE executed with success.</span><br><span class="line">5296:S 09 Feb 01:48:16.010 * 1 changes in 900 seconds. Saving...</span><br><span class="line">5296:S 09 Feb 01:48:16.011 * Background saving started by pid 9733</span><br><span class="line">9733:C 09 Feb 01:48:16.046 * DB saved on disk</span><br><span class="line">9733:C 09 Feb 01:48:16.047 * RDB: 4 MB of memory used by copy-on-write</span><br><span class="line">5296:S 09 Feb 01:48:16.111 * Background saving terminated with success</span><br><span class="line">5296:S 09 Feb 01:48:16.813 * Connecting to MASTER 127.0.0.1:7001</span><br><span class="line">5296:S 09 Feb 01:48:16.813 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">5296:S 09 Feb 01:48:16.813 * Non blocking connect for SYNC fired the event.</span><br><span class="line">5296:S 09 Feb 01:48:16.813 * Master replied to PING, replication can continue...</span><br><span class="line">5296:S 09 Feb 01:48:16.814 * Partial resynchronization not possible (no cached master)</span><br><span class="line">5303:M 09 Feb 01:48:16.815 * Slave 127.0.0.1:7000 asks for synchronization</span><br><span class="line">5303:M 09 Feb 01:48:16.815 * Full resync requested by slave 127.0.0.1:7000</span><br><span class="line">5303:M 09 Feb 01:48:16.815 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">5303:M 09 Feb 01:48:16.816 * Background saving started by pid 9734</span><br><span class="line">5296:S 09 Feb 01:48:16.818 * Full resync from master: 4e882289bf41e7cef05f83f5e1d81fb8ad97e63e:355186</span><br><span class="line">9734:C 09 Feb 01:48:16.855 * DB saved on disk</span><br><span class="line">9734:C 09 Feb 01:48:16.856 * RDB: 6 MB of memory used by copy-on-write</span><br><span class="line">5303:M 09 Feb 01:48:16.859 * Background saving terminated with success</span><br><span class="line">5296:S 09 Feb 01:48:16.859 * MASTER &lt;-&gt; SLAVE sync: receiving 77 bytes from master</span><br><span class="line">5303:M 09 Feb 01:48:16.859 * Synchronization with slave 127.0.0.1:7000 succeeded</span><br><span class="line">5296:S 09 Feb 01:48:16.859 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">5296:S 09 Feb 01:48:16.859 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class="line">5296:S 09 Feb 01:48:16.860 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生产环境推荐"><a href="#生产环境推荐" class="headerlink" title="生产环境推荐"></a>生产环境推荐</h2><p>对于一个最小集群，Redis应该是一个Master带上两个Slave，并且开启下列选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>
<p>这样能保证写入Master的同时至少写入一个Slave，如果出现网络分区阻隔并发生failover的时候，可以保证写入的数据最终一致而不是丢失，写入老的Master会直接失败。</p>
<p>Slave可以适当设置优先级，除了0之外(0表示永远不提升为Master)，越小的优先级，越有可能被提示为Master。如果Slave分布在多个机房，可以考虑将和Master同一个机房的Slave的优先级设置的更低以提升他被选为新的Master的可能性。</p>
<p>考虑到可用性和选举的需要，Sentinel进程至少为3个，推荐为5个。如果有网络分区，应当适当分布(比如2个在A机房， 2个在B机房，一个在C机房)等。</p>
<h2 id="增加和移除Sentinel"><a href="#增加和移除Sentinel" class="headerlink" title="增加和移除Sentinel"></a>增加和移除Sentinel</h2><p>增加新的Sentinel实例非常简单，修改好配置文件，启动即可，其他Sentinel会自动发现该实例并加入集群。如果要批量启动一批Sentinel节点，最好以30秒的间隔一个一个启动为好，这样能确保整个 Sentinel集群的大多数能够及时感知到新节点，满足当时可能发生的选举条件。</p>
<p>移除一个Sentinel实例会相对麻烦一些，因为Sentinel不会忘记已经感知到的Sentinel实例，所以最好按照下列步骤来处理：</p>
<ul>
<li>停止将要移除的sentinel进程。</li>
<li>给其余的sentinel进程发送SENTINEL RESET *命令来重置状态，忘记将要移除的sentinel，每个进程之间间隔30秒。</li>
<li>确保所有sentinel对于当前存货的sentinel数量达成一致，可以通过SENTINEL MASTER <mastername>命令来观察，或者查看配置文件。</li>
</ul>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>客户端从过去直接连接Redis ，变成：</p>
<ul>
<li>先连接一个Sentinel实例</li>
<li>使用 SENTINEL get-master-addr-by-name master-name 获取Redis地址信息。</li>
<li>连接返回的Redis地址信息，通过ROLE命令查询是否是Master。如果是，连接进入正常的服务环节。否则应该断开重新查询。</li>
<li>(可选)客户端可以通过SENTINEL sentinels <master-name>来更新自己的Sentinel实例列表。</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>由于Redis是异步复制，所以Sentinel其实无法达到强一致性，它承诺的是最终一致性：最后一次failover的Redis Master赢者通吃，其他Slave的数据将被丢弃，重新从新的Master复制数据</p>
<p><a target="_blank" rel="noopener" href="http://www.yunweipai.com/archives/20444.html">参考Sentinel</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-02-08/redis%E9%9B%86%E7%BE%A4-%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-02-08/redis%E9%9B%86%E7%BE%A4-%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">redis集群-主从配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-08 00:57:55" itemprop="dateCreated datePublished" datetime="2018-02-08T00:57:55+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于redis支持的redis cluster和redis sentinel 的集群模式为了保证高可用和高负载需要多台服务器.用redis的主从模式,读写分离,是另一种高可用的方案(容灾效果相对不好).</p>
<h1 id="redis主从模式的特点"><a href="#redis主从模式的特点" class="headerlink" title="redis主从模式的特点"></a>redis主从模式的特点</h1><ul>
<li>一个master可以拥有多个slave</li>
<li>多个slave链接同一个master，也可以链接其它slave</li>
<li>主从复制不会阻塞master,在同步数据时，master可以继续处理client请求.</li>
<li>slave 配置为slave-read-only on需要升级为主节点或者写入配置文件中, 而不能在默认slave情况下直接设置</li>
<li>master与slave断开后会检测心跳, 从新建立连接.</li>
<li>可以直接copy DUMP文件从新重启master</li>
<li>在Master为空以后，slave同步数据会抹掉全部数据.</li>
<li>在实际的使用中最好主服务器还是使用50%到65%的内存,剩下的用于bgsave命令的运行和创建记录写命令的缓冲区.</li>
<li>从服务器在同步主服务器的数据的时候,会清空从服务器中的数据,并被替换为主服务器发来的数据.</li>
</ul>
<p>以下为redis的主从配置实战</p>
<h1 id="下载并编译redis源码包"><a href="#下载并编译redis源码包" class="headerlink" title="下载并编译redis源码包"></a>下载并编译redis源码包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.10.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf redis-3.2.10.tar.gz</span><br><span class="line"></span><br><span class="line">cd &#x2F;redis-3.2.10&#x2F;src&#x2F;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配置redis主从"><a href="#配置redis主从" class="headerlink" title="配置redis主从"></a>配置redis主从</h1><p>主：127.0.0.1:6379</p>
<p>从：127.0.0.1:6380</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir redis-6379 redis-6380</span><br><span class="line"></span><br><span class="line">sudo cp redis-3.2.10&#x2F;* -r redis-6379&#x2F;</span><br><span class="line"></span><br><span class="line">sudo cp redis-3.2.10&#x2F;* -r redis-6380&#x2F;</span><br><span class="line"></span><br><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6379&#x2F;run  &#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6380&#x2F;run</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置主节点-redis-config-注意-prod环境需要配置bind-参数"><a href="#配置主节点-redis-config-注意-prod环境需要配置bind-参数" class="headerlink" title="配置主节点 redis.config (注意,prod环境需要配置bind 参数)"></a>配置主节点 redis.config (注意,prod环境需要配置bind 参数)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6379&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置从节点-redis-config"><a href="#配置从节点-redis-config" class="headerlink" title="配置从节点 redis.config"></a>配置从节点 redis.config</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6380&#x2F;run&#x2F;redis_6380.pid</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其它配置采用默认配置即可</p>
<h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6379$ sudo .&#x2F;src&#x2F;redis-server redis.conf &amp;</span><br><span class="line"></span><br><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6380$ sudo .&#x2F;src&#x2F;redis-server redis.conf &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="连接客户端测试"><a href="#连接客户端测试" class="headerlink" title="连接客户端测试"></a>连接客户端测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6380$ sudo .&#x2F;src&#x2F;redis-cli -h 127.0.0.1 -p 6380</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;533,lag&#x3D;0</span><br><span class="line">master_repl_offset:533</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:532</span><br><span class="line">127.0.0.1:6379&gt; set master 127.0.0.1:6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set slave 127.0.0.1:6380</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redisSlave&#x2F;redis-6379$ sudo .&#x2F;src&#x2F;redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:750</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6380&gt; get master</span><br><span class="line">&quot;127.0.0.1:6379&quot;</span><br><span class="line">127.0.0.1:6380&gt; get slave</span><br><span class="line">&quot;127.0.0.1:6380&quot;</span><br><span class="line">127.0.0.1:6380&gt; set slave test</span><br><span class="line">(error) READONLY You can&#39;t write against a read only slave.</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上信息中role分别代表master 和slave.</p>
<p>在主节点中set master和slave,在从节点中可以获取到值的信息.表示主从配置成功.</p>
<h1 id="从节点复制从节点"><a href="#从节点复制从节点" class="headerlink" title="从节点复制从节点"></a>从节点复制从节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">6381配置和6380的一样都是作为6379的丛节点.</span><br><span class="line"></span><br><span class="line">6382的配置和6380不同的是,slaveof参数为6381</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:3284</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6382,state&#x3D;online,offset&#x3D;113,lag&#x3D;0</span><br><span class="line">master_repl_offset:113</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:112</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6382&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6381</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:99</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主挂掉了后从执行：</span><br><span class="line">src&#x2F;redis-cli -p 6380 slaveof NO ONE</span><br><span class="line"></span><br><span class="line">主恢复后从执行：</span><br><span class="line">src&#x2F;redis-cli -p 6380 slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<h1 id="主从配置密码"><a href="#主从配置密码" class="headerlink" title="主从配置密码"></a>主从配置密码</h1><p>主:redis.conf中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass abc</span><br></pre></td></tr></table></figure>

<p>从:redis.conf中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth abc</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈伟杰"
      src="/images/favicon.ico">
  <p class="site-author-name" itemprop="name">陈伟杰</p>
  <div class="site-description" itemprop="description">学习，坚持。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenwj1103" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenwj1103" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈伟杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">638k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
