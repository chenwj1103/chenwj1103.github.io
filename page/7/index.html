<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.chenwj.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习，坚持。">
<meta property="og:type" content="website">
<meta property="og:title" content="茄子的博客">
<meta property="og:url" content="http://www.chenwj.cn/page/7/index.html">
<meta property="og:site_name" content="茄子的博客">
<meta property="og:description" content="学习，坚持。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈伟杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.chenwj.cn/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>茄子的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="茄子的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茄子的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">74</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-01-12/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-01-12/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">redis设计与实现-持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-12 01:41:01" itemprop="dateCreated datePublished" datetime="2018-01-12T01:41:01+08:00">2018-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>服务器中的非空数据库以及他们的键值对统称为<strong>数据库状态</strong>.</p>
<p>redis是内存数据库,如果不将数据保存到磁盘,一旦服务器进程退出,服务器中的数据库状态也会消失不见.</p>
<p>RDB持久化功能生成的RDB文件时一个经过压缩的二进制文件.通过该文件还可以生成生成RDB文件时的数据库状态.</p>
<h2 id="RDB文件的创建和载入"><a href="#RDB文件的创建和载入" class="headerlink" title="RDB文件的创建和载入"></a>RDB文件的创建和载入</h2><p>save和bgsave命令可以生成RDB文件.</p>
<ol>
<li>save命令会阻塞服务器进程,直到RDB文件创建完毕,阻塞期间,服务器不能处理任何命令请求.</li>
<li>bgsave会派生出一个子进程来创建RDB文件.这期间父进程会处理命令请求.子进程创建完成之后,会通知父进程.</li>
</ol>
<p>RDB文件的载入时在服务器启动时自动执行的,服务器只要检测到有RDB文件存在,就会自动载入.</p>
<h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><ol>
<li>在执行save命令的过程中,服务器会拒绝任何命令请求;</li>
<li>在执行bgsave命令时,如果执行save和bgsave命令都会被拒绝,而执行bgrewriteaof命令时,会在bgsave命令执行完,才执行.</li>
<li>执行bgrewriteaof命令时,执行bgsave命令会被拒绝,因为这两个命令都是采用子进程去执行.</li>
<li>载入RDB过程中,服务器处于阻塞状态</li>
</ol>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>通过在redis.conf文件中配置save属性,可以让服务器自动执行bgsave命令.</p>
<p>设置保存条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/persistence/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E4%BF%9D%E5%AD%98%E6%9D%A1%E4%BB%B6.png" alt="服务器状态中的保存条件"></p>
<h3 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h3><p>dirty属性记录距离上一次成功执行save和bgsave命令之后,服务器对数据库状态(所有数据库)执行了多少次修改操作;</p>
<p>lastsave属性时一个时间戳记录距离上一次成功执行save和bgsave命令的时间;</p>
<h3 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h3><p>服务器的周期性函数serverCron默认100毫秒检查一次,其中一次就是检查save选项的条件是否满足</p>
<p><img src="/images/redis/persistence/serverCron%E5%87%BD%E6%95%B0%E6%A3%80%E6%9F%A5%E4%BF%9D%E5%AD%98%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="serverCron函数检查保存条件的过程"></p>
<p>上述时serverCom函数检查save条件的伪代码实现,只要满足一个条件就执行bgsave命令.bgsave命令执行完之后dirty属性会被置为0.</p>
<h2 id="RDB的文件结构"><a href="#RDB的文件结构" class="headerlink" title="RDB的文件结构"></a>RDB的文件结构</h2><p>RDB文件的结构如下</p>
<p><img src="/images/redis/persistence/RDB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="RDB文件的结构"></p>
<p>该结构中大写表示常量,小写表示变量和数据.</p>
<ol>
<li>REDIS是长度为5字节的二进制数据,程序在载入的时候通过此标识检查是否为RDB文件.</li>
<li>db_verison 是字符串类型的整数,表示的是RDB文件的版本.</li>
<li>databses表示的时0个或者多个数据库,如果数据库状态为空,则该长度为空.如果时非空,则长度根据数据的数量也会不同.</li>
<li>EOF长度为1个字节,当程序读到这个位置的时候遇到此标识,表示数据库的所有键值对已经全部载入完毕.</li>
<li>check_num时一个8字节的无符号的整数.保存的是一个检验和.是由以上的四个参数计算得出的.在载入时会通过以上四个参数得出的校验和与该参数进行对比,以此来检验RDB文件是否有出错或者损坏的情况.</li>
</ol>
<p><img src="/images/redis/persistence/databases%E4%B8%BA%E7%A9%BA%E7%9A%84RDB%E6%96%87%E4%BB%B6.png" alt="databases为空的RDB文件"></p>
<h3 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h3><p><img src="/images/redis/persistence/%E5%B8%A6%E6%9C%892%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E7%9A%84RDB%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="带有2个非空数据的RDB文件的数据结构"></p>
<p>每个非空的数据库都会保存成以下三个部分</p>
<p><img src="/images/redis/persistence/RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84.png" alt="RDB文件中的数据库结构"></p>
<ol>
<li>SELECTED时一个1字节的常量,当程序读到该标识的时候,知道接下来是一个数据库号码.</li>
<li>db_number表示的是数据库编号.</li>
<li>key_value_pairs保存着该库里所有的键值对数据.</li>
</ol>
<p>保存了0号库和3号库的完整的RDB文件的结构如下:</p>
<p><img src="/images/redis/persistence/%E5%AE%8C%E6%95%B4%E7%9A%84RDB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="完整的RDB文件的结构"></p>
<h3 id="key-value-pairs"><a href="#key-value-pairs" class="headerlink" title="key_value_pairs"></a>key_value_pairs</h3><h4 id="在RDB中的键值对对象"><a href="#在RDB中的键值对对象" class="headerlink" title="在RDB中的键值对对象"></a>在RDB中的键值对对象</h4><p>键值对在RDB文件中由type key value三个部分组成.</p>
<p><img src="/images/redis/persistence/%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9.png" alt="不带过期时间的键值对"></p>
<p><img src="/images/redis/persistence/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9.png" alt="带有过期时间的键值对"></p>
<p>type表示底层编码或者对象类型,key是字符串对象,ExpireTime_MS 是一个常量告诉程序将来要读到的时一个过期时间戳.</p>
<h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4><p>RDB文件中的每个value都是一个对象,编码类型记在type中.</p>
<ul>
<li>字符串对象 (type=REDIS_RDB_TYPE_STRING)</li>
</ul>
<p>字符串对象的编码是Redis_encoding_int,则该对象会以如下的结构保存.其中encoding会是8bit 16bit或者32bit来保存数据</p>
<p><img src="/images/redis/persistence/%E4%BF%9D%E5%AD%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AF%B9%E8%B1%A1INT%E7%BC%96%E7%A0%81.png" alt="保存字符串的对象INT编码"></p>
<p>字符串对象的编码是Redis_encoding_raw,则该对象会以如下的结构保存</p>
<p>如果字符串长度小于等于20,则字符串会被保存为原来的样子,否则会被压缩后在保存(开启rdbcompressiong选项的情况下)</p>
<p><img src="/images/redis/persistence/%E4%BF%9D%E5%AD%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1raw%E7%BC%96%E7%A0%81.png" alt="保存字符串对象raw编码"></p>
<p>REDIS_RDB_ENC_LZF表示采用LZF算法.compressed_len压缩后的长度,origin_len原始长度.compressed_string 压缩后的字符串</p>
<p><img src="/images/redis/persistence/%E6%9C%89%E6%97%A0%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="有无压缩字符串的对比"></p>
<ul>
<li>列表对象(type=REDIS_RDB_TYPE_LIST)</li>
</ul>
<p>value值是一个编码为REDIS_ENCODING_LINKLIST编码类型的列表对象 结构如下</p>
<p><img src="/images/redis/persistence/linklist%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="linklist编码列表对象的保存结构"></p>
<ul>
<li>集合对象(type=REDIS_RDB_TYPE_SET)</li>
</ul>
<p>value值是一个编码为REDIS_ENCODING_HT编码类型的集合对象 结构如下</p>
<p><img src="/images/redis/persistence/HT%E7%BC%96%E7%A0%81%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="HT编码集合对象的保存结构"></p>
<ul>
<li>hash对象(type=REDIS_RDB_TYPE_HASH)</li>
</ul>
<p>value值是一个编码为REDIS_ENCODING_HT编码类型的hash对象 结构如下</p>
<p><img src="/images/redis/persistence/HT%E7%BC%96%E7%A0%81hash%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="HT编码hash表对象的保存结构"></p>
<p><img src="/images/redis/persistence/%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84HT%E7%BC%96%E7%A0%81hash%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="更详细的HT编码hash表对象的保存结构"></p>
<ul>
<li>有序集合对象(type=REDIS_RDB_TYPE_ZSET)</li>
</ul>
<p>value值是一个编码为REDIS_ENCODING_SKIPLISR编码类型的有序集合对象 结构如下</p>
<p><img src="/images/redis/persistence/skiplist%E7%BC%96%E7%A0%81%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="skiplist编码的有序集合的保存结构"></p>
<p><img src="/images/redis/persistence/%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84skiplist%E7%BC%96%E7%A0%81%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="更详细的skiplist编码的有序集合的保存结构"></p>
<ul>
<li>INTSET编码的集合(type=REDIS_RDB_TYPE_SET_INTSET)</li>
</ul>
<p><img src="/images/redis/persistence/INTSET%E7%BC%96%E7%A0%81%E7%9A%84%E9%9B%86%E5%90%88%E6%8F%8F%E8%BF%B0.png" alt="INTSET编码的集合描述"></p>
<ul>
<li>ZIPLIST编码的列表/hash表/有序集合(type=REDIS_RDB_TYPE_LIST_ZIPLIST/type=REDIS_RDB_TYPE_HASH_ZIPLIST/type=REDIS_RDB_TYPE_ZSET_ZIPLIST)</li>
</ul>
<p><img src="/images/redis/persistence/ziplist%E7%BC%96%E7%A0%81%E7%9A%84RDB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png" alt="ziplist编码的RDB数据结构描述"></p>
<h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>使用od命令来分析redis服务器产生的RDB文件</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:&#x2F;usr&#x2F;local&#x2F;redis-3.2.10$ od -c dump.rdb </span><br><span class="line">0000000   R   E   D   I   S   0   0   0   7 372  \t   r   e   d   i   s</span><br><span class="line">0000020   -   v   e   r 006   3   .   2   .   1   0 372  \n   r   e   d</span><br><span class="line">0000040   i   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e</span><br><span class="line">0000060 302   &quot; 376   X   Z 372  \b   u   s   e   d   -   m   e   m 302</span><br><span class="line">0000100 200 212  \f  \0 377   _   V   4 005 364 005 365   k</span><br><span class="line">0000115</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简单说几个参数  377代表EOF ,376代表SELECTED ,\0代表 0 </p>
<p>由于不经常用,如想了解具体细节,请自行翻阅其它资料.</p>
<h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>AOF是通过保存服务器所执行的写命令来记录数据库状态的,AOF文件的所有命令均以Redis命令请求协议的格式保存.</p>
<p><img src="/images/redis/persistence/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="AOF持久化流程图"></p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化实现的实现分为三个步骤:追加/文件写入/文件同步</p>
<h3 id="文件的追加"><a href="#文件的追加" class="headerlink" title="文件的追加"></a>文件的追加</h3><p>当AOF持久化功能打开时,服务器执行完一个写命令,会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</p>
<p><img src="/images/redis/persistence/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B1%9E%E6%80%A7.png" alt="服务器缓冲区属性"></p>
<h3 id="AOF文件的写入和同步"><a href="#AOF文件的写入和同步" class="headerlink" title="AOF文件的写入和同步"></a>AOF文件的写入和同步</h3><p>redis的服务器进程就是一个事件循环,这个循环中的文件事件负责接受客户端的命令请求,以及向客户端回复命令;时间事件负责指向serverCron这样的函数运行需要定时运行的函数,</p>
<p>服务器在处理文件事件时可能会指向写命令,使得一些内容被追加到aof_buf缓冲区,所以在服务器每次结束一个循环之前都会调用flushAppendOnlyFile函数.考虑是否将缓冲区中的内容写到AOF文件中</p>
<p>伪代码实现</p>
<p><img src="/images/redis/persistence/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="事件循环的伪代码实现"></p>
<p>flushAppendOnlyFile函数的行为有appendfsync选项的值来决定,以下是不同的appendfsync值产生的不同的持久化行为</p>
<p><img src="/images/redis/persistence/%E4%B8%8D%E5%90%8C%E7%9A%84appendfsync%E5%80%BC%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E8%A1%8C%E4%B8%BA.png" alt="不同的appendfsync值产生的不同的持久化行为"></p>
<p>现在操作系统中,在调用write函数写数据到文件的时候,会将数据保存在一个内存缓冲区里面,等到缓冲区的空间被填满,然后才将缓冲区中的内容写入到磁盘.但系统也提供了立即flush的函数.</p>
<ul>
<li>AOF持久化的效率和安全性</li>
</ul>
<p><img src="/images/redis/persistence/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A71.png" alt="AOF持久化的效率和安全性1"></p>
<p><img src="/images/redis/persistence/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%95%88%E7%8E%87%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A72.png" alt="AOF持久化的效率和安全性2"></p>
<h2 id="AOF文件载入和数据还原"><a href="#AOF文件载入和数据还原" class="headerlink" title="AOF文件载入和数据还原"></a>AOF文件载入和数据还原</h2><p>AOF文件中包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍,就而已还原服务器关闭之前的数据库状态.</p>
<p>由于redis的命令只是在客户端上下文中执行,而载入AOF文件所使用的命令直接来源于AOF文件,而不是网络连接.所以服务器使用了一个没有网络连接的伪客户端来执行命令.具体步骤如:</p>
<p><img src="/images/redis/persistence/AOF%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B.png" alt="AOF文件载入过程"></p>
<h2 id="AOF文件的重写"><a href="#AOF文件的重写" class="headerlink" title="AOF文件的重写"></a>AOF文件的重写</h2><p>AOF文件存储的是客户端的写命令,随着服务器运行时间越长,文件会越大.而且AOF文件进行数据还原所需要的时间就越多.所以需要对AOF文件进行重写.</p>
<p>通过重写功能,服务器会创建一个新的AOF文件来替代所有的AOF文件.新文件和原有的文件所存储的数据是一致的,但新文件的剔除了许多冗余的命令,所以新文件的体积通常会小很多.</p>
<p>AOF文件的重写并不需要对现有的文件进行读写操作,而是通过读取当前的数据库服务器状态来实现的.</p>
<p><img src="/images/redis/persistence/AOF%E9%87%8D%E5%86%99%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="AOF重写的例子"></p>
<p>AOF重写的伪代码实现:</p>
<p><img src="/images/redis/persistence/AOF%E9%87%8D%E5%86%99%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01.png" alt="AOF重写的伪代码实现1"></p>
<p><img src="/images/redis/persistence/AOF%E9%87%8D%E5%86%99%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B02.png" alt="AOF重写的伪代码实现2"></p>
<p><img src="/images/redis/persistence/AOF%E9%87%8D%E5%86%99%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B03.png" alt="AOF重写的伪代码实现3"></p>
<p>重写后产生的AOF文件</p>
<p><img src="/images/redis/persistence/%E9%87%8D%E5%86%99%E5%90%8E%E7%9A%84AOF%E6%96%87%E4%BB%B6.png" alt="重写后的AOF文件"></p>
<p>重写后的AOF文件对应的数据库:</p>
<p><img src="/images/redis/persistence/%E9%87%8D%E5%86%99%E5%90%8E%E7%9A%84AOF%E6%96%87%E4%BB%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="重写后的AOF文件对应的数据库"></p>
<ul>
<li>如果某个键的对应的value的值的个数大于64个,则需要拆成多条命令.</li>
</ul>
<h2 id="AOF后台重写-BGREWRITEAOF功能"><a href="#AOF后台重写-BGREWRITEAOF功能" class="headerlink" title="AOF后台重写(BGREWRITEAOF功能)"></a>AOF后台重写(BGREWRITEAOF功能)</h2><p>由于aof_rewrite函数在有多条数据需要重写的情况下会长时间阻塞线程,由于redis是单线程,所以AOF重写期间(使用aof_rewrite函数)服务器无法处理客户顿的请求.所以redis使用子进程来重写.</p>
<p>子进程执行重写期间数据库仍然有写操作,所以服务器当前的状态和AOF文件所保存的文件不一致.为此redis服务器创建了一个AOF重写缓冲区,它只有在服务器创建子进程之后才会使用,当redis服务器执行完一个写命令之后,它会同事给AOF缓冲区和AOF重写缓冲区发送此命令.</p>
<p>在子进程执行AOF重写期间,服务器需要执行以下三个工作:</p>
<ol>
<li>执行客户端发送过来的命令</li>
<li>执行后的写命令追加到AOF缓冲区</li>
<li>将执行后的写命令追加到AOF重写缓冲区</li>
</ol>
<p>这样会保证AOF缓冲区的内容会定时的写入和同步到AOF文件,现有的AOF文件会正常处理;而且从创建子进程开始所有的写命令都会被放入AOF重写缓冲区</p>
<p>当子进程执行完重写操作后,它会向父进程发送信号,父进程会完成以下工作:</p>
<ol>
<li>将AOF重写缓冲区中的内容写入到新的AOF文件中,以此来保证和数据库的状态一致;</li>
<li>对新的AOF文件进行改名,原子性的覆盖现有的AOF文件,完成新旧文件的替换</li>
</ol>
<p><img src="/images/redis/persistence/AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.png" alt="AOF后台重写过程"></p>
<h1 id="系统故障处理"><a href="#系统故障处理" class="headerlink" title="系统故障处理"></a>系统故障处理</h1><h2 id="检查出错的文件"><a href="#检查出错的文件" class="headerlink" title="检查出错的文件"></a>检查出错的文件</h2><ol>
<li>无论是AOF还是快照的方式,将数据持久化到硬盘还是非常有必要的.除此之外,用户还必须对持久化的文件进行备份.最好的备份是把最新的快照或者最新重写的AOF文件备份到别的服务器上.</li>
<li>redis-check-aof和redis-check-dump是在系统发生故障后,检查AOF文件和快照文件的状态,并在有需要的情况下对文件进行修复.</li>
</ol>
<h2 id="更换故障主服务器"><a href="#更换故障主服务器" class="headerlink" title="更换故障主服务器"></a>更换故障主服务器</h2><p>假设A/B两台机器都运行这Redis,其中A时主服务器,B是从服务器.突然A故障坏掉,如何使用同样安装了redis的C服务器作为新的主服务器?</p>
<p>非常简单:首先向B服务器发送一个save命令,让它创建一个新的快照文件.接着将快照文件发送给C,并在C上启动redis,最后让B成为C的从服务器,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof [--fix] &lt;file-aof&gt; 会扫描给定的AOF文件,寻找不正确或者不完整的命令,并且删除出错的命令以及位于出错命令之后的命令.</span><br><span class="line">redis-check-dump &lt;dump.rdb&gt; 目前没有办法修复出错的快照文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="http://blog.nosqlfan.com/html/3813.html">另外书籍中推荐了一片redis持久化解密的比较好的博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-01-10/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-01-10/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">redis设计与实现-数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-10 23:35:54" itemprop="dateCreated datePublished" datetime="2018-01-10T23:35:54+08:00">2018-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇将介绍redis数据库实现的相关操作.包括服务器保存数据库的方法,客户端切换数据库的方法,数据库保存键值对的方法,以及针对数据库的增删改查操作,还有键的过期时间和自动删除过期键的方法.</p>
<h1 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h1><p>redis服务器存在一个redisServer结构中,其中db数组的每一个项都是一个redisDb结构.</p>
<p>如下为服务器结构</p>
<p><img src="/images/redis/database/redisServer%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redisServer数据结构"></p>
<p>服务器初始化时,根据服务器的dbnum属性来决定创建多少个数据库.默认创建16个数据库</p>
<p><img src="/images/redis/database/redisServer%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png" alt="redisServer数据结构2"></p>
<p>服务器数据库实例如下:</p>
<p><img src="/images/redis/database/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B.png" alt="服务器数据库实例"></p>
<h1 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h1><p>每个redis客户端都有自己的目标数据库.默认为0,用户可以通过select语句进行切换.</p>
<p>如下为redisClient的数据结构</p>
<p><img src="/images/redis/database/redisClient%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redisClient的数据结构"></p>
<p>如下展示了客户端的目标数据库为1号数据库.</p>
<p><img src="/images/redis/database/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA1%E5%8F%B7%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="客户端的目标数据库为1号数据库"></p>
<p>redis仍然没有返回当前客户端使用的数据库的命令.所以,谨慎使用多数据库程序.</p>
<h1 id="数据库的空间键"><a href="#数据库的空间键" class="headerlink" title="数据库的空间键"></a>数据库的空间键</h1><p>redisDb结构的<strong>dict字典保存了数据库中的所有键值对.这字典被成为键空间</strong>.</p>
<p>键空间的键就是数据库的键,每个键是一个字符串对象.</p>
<p>键空间的值也是数据库的值,每个值可以时五种对象中的任意一种.</p>
<p><img src="/images/redis/database/%E9%94%AE%E7%A9%BA%E9%97%B4%E7%9A%84redisDb%E7%BB%93%E6%9E%84.png" alt="键空间的redisDb结构"></p>
<p><img src="/images/redis/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="数据库键空间的例子"></p>
<p>数据库键空间时一个字典,所以所有针对数据库的操作,都是对键空间字典来操作的.</p>
<h2 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h2><p>添加一个新键值对到数据库,实际上就是将键值对添加到键空间.键为字符串对象,而值则为任意一种类型的Redis对象.</p>
<p>如下为添加一个字符串对象.</p>
<p><img src="/images/redis/database/%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%90%8E%E7%9A%84%E9%94%AE%E7%A9%BA%E9%97%B4.png" alt="添加字符串对象后的键空间"></p>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><p>执行如下语句后键空间变为如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; del book</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/database/%E5%88%A0%E9%99%A4book%E9%94%AE%E5%90%8E%E7%9A%84%E9%94%AE%E7%A9%BA%E9%97%B4.png" alt="删除book键后的键空间"></p>
<h2 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h2><p>执行如下语句后键空间变为如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set message &quot;blah blah&quot;</span><br><span class="line">ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/database/set%E5%91%BD%E4%BB%A4%E6%9B%B4%E6%96%B0message%E9%94%AE.png" alt="set命令更新message键"></p>
<h2 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h2><p>执行如下语句后键空间变为如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; get message</span><br><span class="line"></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/database/get%E5%91%BD%E4%BB%A4%E5%8F%96%E5%80%BC.png" alt="get命令取值"></p>
<h2 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h2><ol>
<li>读取一个键之后,会更新服务器的键空间的命中次数或者不命中的次数. info stats查看</li>
<li>更新LRU操作</li>
<li>如果发现键已经过期,则先删除,再进行下一步操作.</li>
</ol>
<h1 id="设置键的生存时间或者过期时间"><a href="#设置键的生存时间或者过期时间" class="headerlink" title="设置键的生存时间或者过期时间"></a>设置键的生存时间或者过期时间</h1><p>设置 expire 或者pexpire 设置在多长时间后过期,ttl或者pttl查看过期时间</p>
<p>设置 expireat或者pexpireat设置在某一个时间点过期,为unix时间戳</p>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><p>以上的四种过期时间命令最终都会转变为 pexpireat命令来执行.</p>
<h2 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h2><p>redisDb结构的expires字典保存了数据库中所有键的过期时间,我们称这个字典为过期字典.</p>
<ol>
<li>过期字典的键是一个指针,这个指针指向键空间中的某个键对象.</li>
<li>过期字典的值是一个long long类型的整数,这个整数是一个时间戳,保存的键的过期时刻.<br><img src="/images/redis/database/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BE%8B%E5%AD%90.png" alt="带有过期字典的数据库例子"></li>
</ol>
<p>执行pexpireat命令,服务器会在数据库的过期字典中关联给定的数据库键和过期时间.</p>
<p><img src="/images/redis/database/%E6%89%A7%E8%A1%8Cpexireat%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="执行pexireat命令之后的数据库"></p>
<p><img src="/images/redis/database/%E6%89%A7%E8%A1%8Cpexpireat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt="执行pexpireat命令的伪代码"></p>
<h2 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h2><p>persist命令可以移除一个键的过期时间,即在过期字典中查找给定的键,并移除键和值(过期时间)在字典中的关联.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; persist book</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据库执行以上代码后的状态</p>
<p><img src="/images/redis/database/%E6%89%A7%E8%A1%8Cpersist%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="执行persist后的数据库"></p>
<h2 id="计算并返回剩余时间"><a href="#计算并返回剩余时间" class="headerlink" title="计算并返回剩余时间"></a>计算并返回剩余时间</h2><p>ttl 和pttl命令是计算键的过期时间和当前时间的差实现的.返回键的剩余剩余生存时间.</p>
<p><img src="/images/redis/database/pttl%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="pttl的伪代码实现"></p>
<p><img src="/images/redis/database/pttl%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01.png" alt="pttl的伪代码实现1"></p>
<h2 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h2><p>通过过期字典判断给定键的过期,相对于ttl的实现速度快一些.</p>
<ol>
<li>检查给定的键是否在过期字典中存在,如果存在,则取得过期时间.</li>
<li>判断当前unix时间错是否大约键的过期时间,如果大于则过期,否则未过期.</li>
</ol>
<p>过期键判定的伪代码实现<br><img src="/images/redis/database/%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A4%E5%AE%9A%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="过期键判定的伪代码实现"></p>
<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><p>如果一个键过期了,它设呢么时候被删除呢?有以下三种策略.</p>
<ol>
<li>定时删除:在设置键的过期时间的同时,创建一个定时器,让定时器在过期时间来临时,立即执行删除操作.</li>
<li>惰性删除:放任过期键不管,但每次从键空间获取键时都要检查键是否过期,如果过期则删除;如果没有过期则返回.</li>
<li>定期删除:每个一段时间,程序就会进行一次减产,删除里面的过期键.至于删除多少过期键,怎么检查,由算法决定.</li>
</ol>
<h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><p>定时删除是对内存最友好的,但是是对cpu不友好的.当某一个时刻,有大量的过期键需要删除的时候会占用大量的cpu时间,而此时如果有查询操作,影响查询效率.而且设置时间事件(采用链表的数据结构实现)事件复杂度为O(n).处理起来不太高效.</p>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>惰性删除对cpu是友好的,只有到了键非删除不可的时候才会被删除.但是对内存是不友好的.当键过期的时候,用户以为键被删除了,其实它还存在于键空间.如果用户痕迹不访问,则它会永远存在.这相当于内存泄露.</p>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p><strong>定时删除</strong>会占用太多的cpu时间.影响服务的相应时间和吞吐量.<strong>惰性删除</strong>会浪费过多内存,造成内存泄露.</p>
<p>定期删除时上述两种方式的折中策略,定时删除会每隔一段时间执行一次删除过期键的操作,并通过控制执行的市场和频率来减少对cpu时间的影响;除此之外定期删除还有效的减少了内存浪费.</p>
<p>定期删除策略的难点时确定删除操作的执行时间和频率.</p>
<h1 id="redis采用的过期键的删除策略"><a href="#redis采用的过期键的删除策略" class="headerlink" title="redis采用的过期键的删除策略"></a>redis采用的过期键的删除策略</h1><p>定期删除和惰性删除.</p>
<h2 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h2><p>惰性删除是采用expireIfNeeded函数来实现的,实现的执行过程如下所示</p>
<p><img src="/images/redis/database/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E9%94%AE%E7%AD%96%E7%95%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="惰性删除键策略的执行流程"></p>
<h2 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h2><p>定期删除策略会调用activeExpireCycle函数实现.每当周期性的调用serverScron函数执行时,就会调用activeExpireCycle.</p>
<p>伪代码实现如下:<br><img src="/images/redis/database/%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01.png" alt="定期删除的伪代码实现1"></p>
<p><img src="/images/redis/database/%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B02.png" alt="定期删除的伪代码实现2"></p>
<h1 id="AOF-RDB和复制功能对过期键的处理"><a href="#AOF-RDB和复制功能对过期键的处理" class="headerlink" title="AOF/RDB和复制功能对过期键的处理"></a>AOF/RDB和复制功能对过期键的处理</h1><h2 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h2><p>在执行save命令或者bgsave命令创建一个新的RDB文件时.程序会对数据库中的键进行检查,已过期的键不会保存到新建的RDB文件中.</p>
<h2 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h2><p>启动服务器的时候,如果开启了RDB功能,则服务器对RDB文件不行载入:</p>
<p>如果时主服务器模式运行.载入时会检查,未过期的键会被载入到数据库,过期则会被忽略;而从服务器模式运行的,在载入RDB文件的时候,所有键都会被载入.如果从服务器在进行数据同步的时候,从服务器的数据会被清空 </p>
<h2 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h2><p>当服务器以AOF持久化模式运行时,如果数据库中的某个键已经过期,但哈没有被删除,则AOF文件不会因此产生任何影响.当过期键被删除的时候会执行一条DEL 命令,来显示的记录该键已经被删除.</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>和生成的RDB文件类似,在执行AOF重写的过程中,程序会检查过期的键,如果过期,则不保存到重写的AOF文件中.</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在服务器运行在复制模式下时,从服务器的过期键的删除动作由主服务器控制</p>
<ol>
<li>主服务器删除一个过期键之后,会显示的向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键;</li>
<li>从服务器在执行客户端发送的度命令时,即使碰到过期键也不会将过期键删除,而时即系向处理未过期的键一样来处理过期键.(读取一条过期键的数据,会仍然返回结果)</li>
<li>从服务器只有收到住服务器的DEL命令之后,才会删除过期键. <strong>这样可以保证主从数据的一致性.</strong></li>
</ol>
<h1 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h1><p>数据库通知是redis2.8版本增加的功能.</p>
<p>通知分为两类,一种时键空间通知,即通知某一个键执行的所有命令,英译中时键事件通知,他们关注的是某个命令被什么键执行了.</p>
<p>由于数据库通知在实际应用中比较少,所以这里不做过多的介绍.想要详细了解可以自行翻阅相关资料.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-01-08/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-01-08/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A13/" class="post-title-link" itemprop="url">redis设计与实现-数据结构与对象3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-08 23:19:04" itemprop="dateCreated datePublished" datetime="2018-01-08T23:19:04+08:00">2018-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>redis的数据对象</p>
<p>redis不是使用前面介绍的数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统.包括字符串对象.列表对象.hash对象,集合对象和有序集合对象.</p>
</li>
</ul>
<h1 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h1><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键<strong>（键对象）</strong>， 另一个对象用作键值对的值<strong>（值对象）</strong></p>
<p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象的 type 属性记录了对象的类型</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
<td></td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
<td></td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
<td></td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
<td></td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
<td></td>
</tr>
</tbody></table>
<p>Redis 数据库保存的键值对来说， <strong>键总是一个字符串对象</strong>， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种.</p>
<p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型</p>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<ul>
<li>encoding 属性记录了对象所使用的编码如下所示:</li>
</ul>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td></td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
<td></td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>每种类型的对象都至少使用了两种不同的编码， 表 8-4 列出了每种类型的对象可以使用的编码。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody></table>
<ul>
<li>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SET story &quot;long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>字符串对象的编码可以是 int 、 raw 或者 embstr 。</p>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><p>如果一个字符串对象保存的是<strong>整数值</strong>， 并且这个整数值可以<strong>用 long 类型来表示</strong>， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面*<em>（将 void</em> 转换成 long ）<strong>， 并将字符串对象的</strong>编码设置为 int** 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;int&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/redis/struct2/int%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png" alt="int编码的字符串对象"></p>
<h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2><p>如果字符串对象保存的是一个<strong>字符串值</strong>， 并且这个字符串值的<strong>长度大于 39 字节</strong>， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET story &quot;Long, long, long ago there lived a king ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN story</span><br><span class="line">(integer) 43</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/struct2/raw%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png" alt="raw编码的字符串对象"></p>
<h2 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h2><p>如果字符串对象保存的是一个<strong>字符串值</strong>， 并且这个字符串值的长度<strong>小于等于 39 字节</strong>， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<ul>
<li>embstr和raw的区别:</li>
</ul>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 <strong>raw 编码会调用两次内存分配函数</strong>来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr <strong>编码则通过调用一次内存分配函数来分配一块连续的空间</strong>， 空间中依次包含 redisObject 和 sdshdr 两个结构， 如图 8-3 所示。</p>
<p><img src="/images/redis/struct2/embstr%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png" alt="embstr编码的字符串对象"></p>
<ul>
<li>embstr存储的好处</li>
</ul>
<ol>
<li>e**mbstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<ul>
<li>例子</li>
</ul>
<p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;int&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND number &quot; is a good number!&quot;</span><br><span class="line">(integer) 23</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086 is a good number!&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>注意</em></p>
<p>因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， <strong>所以 embstr 编码的字符串对象实际上是只读的</strong>： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
</li>
</ul>
<p><em>以下例子中执行append操作后,字符串的长度没有超过39,但由于embstr的只读特性.</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg &quot; again!&quot;</span><br><span class="line">(integer) 18</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p>
<h2 id="ziplist编码"><a href="#ziplist编码" class="headerlink" title="ziplist编码"></a>ziplist编码</h2><p>ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 1 &quot;three&quot; 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的numbers对象使用的是ziplist编码,则对象将会是如下的样子.</p>
<p><img src="/images/redis/struct2/ziplist%E7%BC%96%E7%A0%81%E7%9A%84list%E5%AF%B9%E8%B1%A1.png" alt="ziplist编码的list对象"></p>
<h2 id="linkedlist编码"><a href="#linkedlist编码" class="headerlink" title="linkedlist编码"></a>linkedlist编码</h2><p>linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。</p>
<p>如果numbers对象使用的是linklist编码,则对象将会时如下的样子.</p>
<p><img src="/images/redis/struct2/linklist%E7%BC%96%E7%A0%81%E7%9A%84list%E5%AF%B9%E8%B1%A1.png" alt="linklist编码的list对象"></p>
<p>linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<p><img src="/images/redis/struct2/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA.png" alt="完整的字符串对象表示"> </p>
<p>以上linklist中的字符串对象只是简单的表示.</p>
<h2 id="编码转化"><a href="#编码转化" class="headerlink" title="编码转化"></a>编码转化</h2><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ol>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 所有元素的长度都小于 64 字节</span><br><span class="line">redis&gt; RPUSH blah &quot;hello&quot; &quot;world&quot; &quot;again&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 将一个 65 字节长的元素推入列表对象中</span><br><span class="line">redis&gt; RPUSH blah &quot;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot;</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;linkedlist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除此之外， 以下代码展示了列表对象因为保存的元素数量过多而进行编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 列表对象包含 512 个元素</span><br><span class="line">redis&gt; EVAL &quot;for i&#x3D;1,512 do redis.call(&#39;RPUSH&#39;, KEYS[1], i) end&quot; 1 &quot;integers&quot;</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN integers</span><br><span class="line">(integer) 512</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 再向列表对象推入一个新元素，使得对象保存的元素数量达到 513 个</span><br><span class="line">redis&gt; RPUSH integers 513</span><br><span class="line">(integer) 513</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;linkedlist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是 ziplist 或者 hashtable 。</p>
<h2 id="ziplist编码-1"><a href="#ziplist编码-1" class="headerlink" title="ziplist编码"></a>ziplist编码</h2><p>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ol>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET profile name &quot;Tom&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile age 25</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile career &quot;Programmer&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码如果编码是zipist,则如下表示:</p>
<p><img src="/images/redis/struct2/ziplist%E7%BC%96%E7%A0%81%E7%9A%84hash%E5%AF%B9%E8%B1%A1.png" alt="ziplist编码的hash对象"></p>
<p><img src="/images/redis/struct2/hash%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png" alt="hash对象的压缩列表的底层实现"></p>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ol>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ol>
<p><img src="/images/redis/struct2/hashtable%E7%BC%96%E7%A0%81%E7%9A%84hash%E5%AF%B9%E8%B1%A1.png" alt="hashtable编码的hash对象"></p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ol>
<p>不能同时满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<p>以下代码展示了哈希对象因为键值对的键长度太大而引起编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span><br><span class="line">redis&gt; HSET book name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING book</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向哈希对象添加一个新的键值对，键的长度为 66 字节</span><br><span class="line">redis&gt; HSET book long_long_long_long_long_long_long_long_long_long_long_description &quot;content&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING book</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>除了键的长度太大会引起编码转换之外， 值的长度太大也会引起编码转换， 以下代码展示了这种情况的一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span><br><span class="line">redis&gt; HSET blah greeting &quot;hello world&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向哈希对象添加一个新的键值对，值的长度为 68 字节</span><br><span class="line">redis&gt; HSET blah story &quot;many string ... many string ... many string ... many string ... many&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后， 以下代码展示了哈希对象因为包含的键值对数量过多而引起编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个包含 512 个键值对的哈希对象</span><br><span class="line">redis&gt; EVAL &quot;for i&#x3D;1, 512 do redis.call(&#39;HSET&#39;, KEYS[1], i, i) end&quot; 1 &quot;numbers&quot;</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN numbers</span><br><span class="line">(integer) 512</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 再向哈希对象添加一个新的键值对，使得键值对的数量变成 513 个</span><br><span class="line">redis&gt; HMSET numbers &quot;key&quot; &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN numbers</span><br><span class="line">(integer) 513</span><br><span class="line"></span><br><span class="line"># 编码改变</span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>


<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<h2 id="inset编码"><a href="#inset编码" class="headerlink" title="inset编码"></a>inset编码</h2><p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在<strong>整数集合</strong>里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/redis/struct2/inset%E7%BC%96%E7%A0%81%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png" alt="inset编码的整数集合对象"></p>
<p> hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/redis/struct2/hashtable%E7%BC%96%E7%A0%81%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png" alt="hashtable编码的集合对象"></p>
<h2 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<p>举个例子， 以下代码创建了一个只包含整数元素的集合对象， 该对象的编码为 intset ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">不过， 只要我们向这个只包含整数元素的集合对象添加一个字符串元素， 集合对象的编码转移操作就会被执行：</span><br><span class="line"></span><br><span class="line">redis&gt; SADD numbers &quot;seven&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除此之外， 如果我们创建一个包含 512 个整数元素的集合对象， 那么对象的编码应该会是 intset ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;for i&#x3D;1, 512 do redis.call(&#39;SADD&#39;, KEYS[1], i) end&quot; 1 integers</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD integers</span><br><span class="line">(integer) 512</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p>但是， 只要我们再向集合添加一个新的整数元素， 使得这个集合的元素数量变成 513 ， 那么对象的编码转换操作就会被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD integers 10086</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD integers</span><br><span class="line">(integer) 513</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<h2 id="ziplist编码-2"><a href="#ziplist编码-2" class="headerlink" title="ziplist编码"></a>ziplist编码</h2><p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ziplist编码</p>
<p><img src="/images/redis/struct2/hashtable%E7%BC%96%E7%A0%81%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png" alt="ziplist编码的有序集合对象"></p>
<p><img src="/images/redis/struct2/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%9C%A8%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="有序集合在压缩列表中的实现"></p>
<h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， <strong>程序可以对有序集合进行范围型操作</strong>， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， <strong>程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的</strong></p>
<p><strong>注意</strong></p>
<p>值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值</p>
<p><img src="/images/redis/struct2/skiplist%E7%BC%96%E7%A0%81%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png" alt="skiplist编码的有序集合"></p>
<p><img src="/images/redis/struct2/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%90%8C%E6%97%B6%E8%A2%AB%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%AD%97%E5%85%B8%E5%92%8Cskiplist%E4%B8%AD.png" alt="有序集合同时被保存在字典和skiplist中"></p>
<h2 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<p>以下代码展示了有序集合对象因为包含了过多元素而引发编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 对象包含了 128 个元素</span><br><span class="line">redis&gt; EVAL &quot;for i&#x3D;1, 128 do redis.call(&#39;ZADD&#39;, KEYS[1], i, i) end&quot; 1 numbers</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; ZCARD numbers</span><br><span class="line">(integer) 128</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 再添加一个新元素</span><br><span class="line">redis&gt; ZADD numbers 3.14 pi</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 对象包含的元素数量变为 129 个</span><br><span class="line">redis&gt; ZCARD numbers</span><br><span class="line">(integer) 129</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;skiplist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下代码则展示了有序集合对象因为元素的成员过长而引发编码转换的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 向有序集合添加一个成员只有三字节长的元素</span><br><span class="line">redis&gt; ZADD blah 1.0 www</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向有序集合添加一个成员为 66 字节长的元素</span><br><span class="line">redis&gt; ZADD blah 2.0 oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;skiplist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h1><h2 id="命令的类型"><a href="#命令的类型" class="headerlink" title="命令的类型"></a>命令的类型</h2><p>一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。</p>
<p>另一种命令只能对特定类型的键执行</p>
<p>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</p>
<p>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</p>
<p>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</p>
<p>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</p>
<p>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</p>
<h2 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h2><p><img src="/images/redis/struct2/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="类型检查的实现"></p>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<p>例如对一个list对象的建执行llen命令</p>
<ol>
<li>如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；</li>
</ol>
<p><img src="/images/redis/struct2/LLEN%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="LLEN命令执行过程"></p>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ol>
<li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>
</ol>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。</p>
<p>键A创建了一个保存整数值100的字符串对象.如果创建一个键B同样保存一个整数值100的字符串对象,则数据库键会执行以下操作</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
<p><img src="/images/redis/struct2/%E8%A2%AB%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png" alt="被共享的字符串对象"></p>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p><strong>注意</strong></p>
<p>Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>举个例子， 如果我们创建一个值为 100 的键 A ， 并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数， 我们会发现值对象的引用计数为 2 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET A 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引用这个值对象的两个程序分别是持有这个值对象的服务器程序， 以及共享这个值对象的键 A ， 如图 8-22 所示。</p>
<p><img src="/images/redis/struct2/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%BA2%E7%9A%84%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1.png" alt="引用计数为2的共享对象"></p>
<h1 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h1><p>除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：</p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 等待一小段时间</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 20</span><br><span class="line"></span><br><span class="line"># 等待一阵子</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 180</span><br><span class="line"></span><br><span class="line"># 访问 msg 键的值</span><br><span class="line">redis&gt; GET msg</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"># 键处于活跃状态，空转时长为 0</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



























      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2018-01-03/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018-01-03/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A12/" class="post-title-link" itemprop="url">redis设计与实现-数据结构与对象2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-03 01:50:08" itemprop="dateCreated datePublished" datetime="2018-01-03T01:50:08+08:00">2018-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><ul>
<li>概念</li>
</ul>
<p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(log N) 最坏 O(N) 复杂度的节点查找</p>
<p>Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等</p>
<p> <img src="/images/redis/struct1/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="跳跃表的结构"></p>
<ul>
<li>展示了一个跳跃表示例， 位于图片最左边的是 <strong>zskiplist</strong> 结构</li>
</ul>
<p><code>header</code> ：指向跳跃表的表头节点。</p>
<p><code>tail</code> ：指向跳跃表的表尾节点。</p>
<p><code>level</code> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</p>
<p><code>length</code> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</p>
<ul>
<li>位于 zskiplist 结构右方的是四个 <strong>zskiplistNode</strong> 结构， 该结构包含以下属性：</li>
</ul>
<p><code>层（level）</code>：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p>
<p><code>后退（backward）指针</code>：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p>
<p><code>分值（score）</code>：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p>
<h2 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h2><ul>
<li>zskiplistNode 结构定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 分值</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="层"><a href="#层" class="headerlink" title="层"></a>层</h3><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个<strong>介于 1 和 32 之间的值</strong>作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。</p>
<p> <img src="/images/redis/struct1/%E4%B8%8D%E5%90%8C%E5%B1%82%E9%AB%98%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="不同层高的节点"></p>
<h3 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h3><p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， <strong>遍历跳跃表</strong>中所有节点的路径：</p>
<p>1.迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</p>
<p>2.在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</p>
<p>3.在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</p>
<p>4.当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</p>
<p> <img src="/images/redis/struct1/%E9%81%8D%E5%8E%86%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="遍历跳跃表"></p>
<h3 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h3><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<p>1.两个节点之间的跨度越大， 它们相距得就越远。</p>
<p>2.指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</p>
<ul>
<li>跨度的作用</li>
</ul>
<p>跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>例子:</p>
<p>图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p>
<p> <img src="/images/redis/struct1/%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E6%8E%92%E4%BD%8D.png" alt="计算节点的排位"></p>
<h3 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h3><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。</p>
<p> <img src="/images/redis/struct1/%E4%BB%8E%E8%A1%A8%E5%B0%BE%E9%83%A8%E5%90%91%E8%A1%A8%E5%A4%B4%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="从表尾部向表头的遍历"></p>
<h3 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h3><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， <strong>各个节点保存的成员对象必须是唯一的</strong>， <strong>但是多个节点保存的分值却可以是相同的</strong>： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<h2 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表如图 5-8 所示。<br>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示</p>
<p> <img src="/images/redis/struct1/%E5%A4%9A%E4%B8%AA%E8%B7%B3%E8%B7%83%E8%8A%82%E7%82%B9%E7%BB%84%E6%88%90%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="多个跳跃节点组成的跳跃表"></p>
<p> <img src="/images/redis/struct1/%E5%B8%A6%E6%9C%89skiplist%E7%BB%93%E6%9E%84%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="带有skiplist结构的跳跃表"></p>
<p>zskiplist结构定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意<strong>表头节点的层高并不计算在内</strong>。</p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>contents</strong> 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大<code>有序地排列</code>， 并且数组中<code>不包含任何重复项</code>。</p>
<p><strong>length</strong> 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p><strong>encoding</strong></p>
<p> 如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</p>
<p> 如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</p>
<p> 如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>图 6-1 展示了一个整数集合示例：</p>
<p>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。</p>
<p>length 属性的值为 5 ， 表示整数集合包含五个元素。</p>
<p>contents 数组按从小到大的顺序保存着集合中的五个元素。</p>
<p>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) * 5 = 16 * 5 = 80 位。</p>
<p> <img src="/images/redis/struct1/16bit%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png" alt="16bit的整数集合"></p>
<ul>
<li>注意</li>
</ul>
<p>当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是 -2675256175807981027 。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且<strong>新元素的类型比整数集合现有所有元素的类型都要长时</strong>， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<ul>
<li>升级整数集合并添加新元素共分为三步进行：</li>
</ul>
<p>1.根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</p>
<p>2.将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</p>
<p>3.将新元素添加到底层数组里面。</p>
<h3 id="升级例子"><a href="#升级例子" class="headerlink" title="升级例子"></a>升级例子</h3><p>假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示。</p>
<p> <img src="/images/redis/struct1/int16%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png" alt="int16整数集合"></p>
<p>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。</p>
<p> <img src="/images/redis/struct1/contents%E6%95%B0%E7%BB%84%E4%B8%AD%E5%90%84%E4%B8%AA%E5%85%83%E7%B4%A0%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="contents数组中各个元素所在的位置"></p>
<p>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。</p>
<p> <img src="/images/redis/struct1/%E7%A9%BA%E9%97%B4%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84.png" alt="空间重新分配后的数组"></p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。</p>
<p> <img src="/images/redis/struct1/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%85%83%E7%B4%A03%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="类型转换元素3的操作"></p>
<p> 接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内， 如图 6-7 所示。</p>
<p> <img src="/images/redis/struct1/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%85%83%E7%B4%A02%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="类型转换元素2的操作"></p>
<p> 然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图 6-9 所示。<br> <img src="/images/redis/struct1/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B0%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E6%93%8D%E4%BD%9C.png" alt="类型转换新添加元素的操作"></p>
<p> 最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p> <img src="/images/redis/struct1/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E5%AF%B9%E8%B1%A1.png" alt="类型转换后的对象"></p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子，即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p> <img src="/images/redis/struct1/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="压缩列表的各个组成部分"></p>
<p> <strong>lbytes</strong>    uint32_t    4 字节    记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</p>
<p> <strong>zltail</strong>    uint32_t    4 字节    记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</p>
<p> <strong>zllen</strong>    uint16_t    2 字节    记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</p>
<p> <strong>entryX</strong>    列表节点    不定    压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</p>
<p> <strong>zlend</strong>    uint8_t    1 字节    特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</p>
<p>三个节点的压缩列表</p>
<p> <img src="/images/redis/struct1/%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png" alt="三个节点的压缩列表"></p>
<p>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</p>
<p>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</p>
<p>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</p>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><ul>
<li>每个压缩列表节点可以保存一个字节数组或者一个整数值， </li>
</ul>
<p>其中， 字节数组可以是以下三种长度的其中一种：</p>
<ol>
<li><p>长度小于等于 63 （2^{6}-1）字节的字节数组； </p>
</li>
<li><p>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</p>
</li>
<li><p>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</p>
</li>
</ol>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ol>
<li><p>4 位长，介于 0 至 12 之间的无符号整数；</p>
</li>
<li><p>1 字节长的有符号整数；</p>
</li>
<li><p>3 字节长的有符号整数；</p>
</li>
<li><p>int16_t 类型整数；</p>
</li>
<li><p>int32_t 类型整数；</p>
</li>
<li><p>int64_t 类型整数。</p>
</li>
</ol>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如图 7-4 所示。</p>
<p> <img src="/images/redis/struct1/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="压缩列表节点的各个组成部分"></p>
<h3 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h3><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ol>
<li><p>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</p>
</li>
<li><p>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</p>
</li>
</ol>
<p>图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。</p>
<p> <img src="/images/redis/struct1/%E5%89%8D%E4%B8%80%E8%8A%82%E7%82%B9%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA1%E5%AD%97%E8%8A%82.png" alt="前一节点的长度为1字节"></p>
<p>图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。</p>
<p> <img src="/images/redis/struct1/%E5%89%8D%E4%B8%80%E8%8A%82%E7%82%B9%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA5%E5%AD%97%E8%8A%82.png" alt="前一节点的长度为5字节"></p>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p ， 如图 7-7 所示。<br><img src="/images/redis/struct1/%E8%AE%A1%E7%AE%97%E5%89%8D%E4%B8%80%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="计算前一节点的位置"></p>
<h4 id="一个从表尾节点向表头节点进行遍历的完整过程"><a href="#一个从表尾节点向表头节点进行遍历的完整过程" class="headerlink" title="一个从表尾节点向表头节点进行遍历的完整过程"></a>一个从表尾节点向表头节点进行遍历的完整过程</h4><p>首先，我们拥有指向压缩列表表尾节点 entry4 起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</p>
<p>通过用 p1 减去 entry4 节点 previous_entry_length 属性的值， 我们得到一个指向 entry4 前一节点 entry3 起始地址的指针 p2 ；</p>
<p>通过用 p2 减去 entry3 节点 previous_entry_length 属性的值， 我们得到一个指向 entry3 前一节点 entry2 起始地址的指针 p3 ；</p>
<p>通过用 p3 减去 entry2 节点 previous_entry_length 属性的值， 我们得到一个指向 entry2 前一节点 entry1 起始地址的指针 p4 ， entry1 为压缩列表的表头节点；</p>
<p>最终， 我们从表尾节点向表头节点遍历了整个列表。</p>
<p><img src="/images/redis/struct1/%E8%A1%A8%E5%B0%BE%E5%90%91%E8%A1%A8%E5%A4%B4%E9%81%8D%E5%8E%86%E7%9A%841.png" alt="表尾向表头遍历的1"></p>
<p><img src="/images/redis/struct1/%E8%A1%A8%E5%B0%BE%E5%90%91%E8%A1%A8%E5%A4%B4%E9%81%8D%E5%8E%86%E7%9A%842.png" alt="表尾向表头遍历的2"></p>
<p><img src="/images/redis/struct1/%E8%A1%A8%E5%B0%BE%E5%90%91%E8%A1%A8%E5%A4%B4%E9%81%8D%E5%8E%86%E7%9A%843.png" alt="表尾向表头遍历的3"></p>
<p><img src="/images/redis/struct1/%E8%A1%A8%E5%B0%BE%E5%90%91%E8%A1%A8%E5%A4%B4%E9%81%8D%E5%8E%86%E7%9A%844.png" alt="表尾向表头遍历的4"></p>
<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<p>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是<strong>字节数组</strong>编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</p>
<p>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着<strong>整数值</strong>， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</p>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定</p>
<ul>
<li>图 7-9 展示了一个保存字节数组的节点示例：</li>
</ul>
<p><img src="/images/redis/struct1/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="保存字节数组的节点"></p>
<p>编码的最高两位 00 表示节点保存的是一个字节数组；</p>
<p>编码的后六位 001011 记录了字节数组的长度 11 ；</p>
<p>content 属性保存着节点的值 “hello world” 。</p>
<ul>
<li>图 7-10 展示了一个保存整数值的节点示例：</li>
</ul>
<p><img src="/images/redis/struct1/%E4%BF%9D%E5%AD%98%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="保存整数值的节点"></p>
<p>编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</p>
<p>content 属性保存着节点的值 10086 。</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-12-26/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-12-26/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A11/" class="post-title-link" itemprop="url">redis设计与实现-数据结构与对象1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-26 00:43:48" itemprop="dateCreated datePublished" datetime="2017-12-26T00:43:48+08:00">2017-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><ul>
<li><p>概要</p>
<p>redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组),自己构建了一种SDS的抽象类型,即redis的默认字符串类型表示.</p>
</li>
</ul>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><ul>
<li><p>如图所示:</p>
<p><img src="/images/redis/struct1/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p>
</li>
</ul>
<p>1.free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</p>
<p>2.len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</p>
<p>3.buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</p>
<p><code>说明</code></p>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<ul>
<li><p>下图中与上图不同的是,free属性的值为5</p>
<p><img src="/images/redis/struct1/%E5%B8%A6%E6%9C%89%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%A9%BA%E9%97%B4%E7%9A%84SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p>
</li>
</ul>
<h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p>C语言使用N+1长度的字符数组来表示长度为N的字符串.</p>
<h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><ol>
<li><p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。</p>
</li>
<li><p>和 C 字符串不同， 因为 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>
</li>
</ol>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p> 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>c字符串内存再次分配:</p>
<p>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</p>
<p>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</p>
<p>SDS内存再次分配:</p>
<p>为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。</p>
<p>策略如:空间预分配 惰性空间释放</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>  所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p>
<h3 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h3><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <img src="/images/redis/struct1/SDS%E4%B8%8EC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="SDS与C字符串的区别"></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p> 链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。</p>
<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>链表节点的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 节点的值</span><br><span class="line">    void *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多个 listNode 可以通过 prev 和 next 指针组成双端链表</p>
<p> <img src="/images/redis/struct1/%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8.png" alt="双端链表"></p>
<p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话,即redis进行了封装,结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line"></span><br><span class="line">&#125; list;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下图是是一个list结构和三个listNode结构组成的链表</p>
<p> <img src="/images/redis/struct1/list%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8.png" alt="list结构和双端链表"></p>
<ul>
<li>Redis 的链表实现的特性可以总结如下：</li>
</ul>
<ol>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ol>
<ul>
<li>总结</li>
</ul>
<ol>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ol>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p> 字典可以表示数据库， 字典还是哈希键的底层实现之一.</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis 的字典使用哈希表作为底层实现， 一个<strong>哈希表</strong>里面可以有多个<strong>哈希表节点</strong>， 而每个哈希表节点就保存了字典中的一个<strong>键值对</strong>。</p>
<h3 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h3><p> hash表的结构如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F; 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>table 属性是一个数组</strong>， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p>
</li>
<li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p>
</li>
<li><p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p>
</li>
</ol>
<p>如下为一个空的hash表</p>
<p> <img src="/images/redis/struct1/%E7%A9%BAhash%E8%A1%A8.png" alt="空hash表"></p>
<h3 id="hash表节点"><a href="#hash表节点" class="headerlink" title="hash表节点"></a>hash表节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<p> <img src="/images/redis/struct1/next%E6%8C%87%E9%92%88%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E9%94%AE%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7.png" alt="next指针将两个索引值相同的键连接在一起"></p>
<h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><p>结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; rehash 索引</span><br><span class="line">    &#x2F;&#x2F; 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; &#x2F;* rehashing not in progress if rehashidx &#x3D;&#x3D; -1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<p>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。<br>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。<br>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p>
<p>普通状态下的字典.</p>
<p> <img src="/images/redis/struct1/%E5%B1%95%E7%A4%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8.png" alt="展示了一个普通状态下的字典"></p>
<h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>使用字典设置的哈希函数，计算键 key 的哈希值</p>
<p>hash = dict-&gt;type-&gt;hashFunction(key);</p>
<p>使用哈希表的 sizemask 属性和哈希值，计算出索引值,根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</p>
<p>index = hash &amp; dict-&gt;ht[x].sizemask;</p>
<p> <img src="/images/redis/struct1/hash%E7%AE%97%E6%B3%95.png" alt="hash算法"></p>
<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p> <img src="/images/redis/struct1/%E8%A7%A3%E5%86%B3%E9%94%AE%E5%86%B2%E7%AA%81.png" alt="解决键冲突"></p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<h3 id="Redis-对字典的哈希表执行-rehash-的步骤如下"><a href="#Redis-对字典的哈希表执行-rehash-的步骤如下" class="headerlink" title="Redis 对字典的哈希表执行 rehash 的步骤如下"></a>Redis 对字典的哈希表执行 rehash 的步骤如下</h3><p>1.为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p>
<p>  如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</p>
<p>  如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</p>
<p>2.将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p>
<p>3.当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>对图 4-8 所示字典的 ht[0] 进行<code>扩展</code>操作</p>
<p>1.ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 </p>
<p> <img src="/images/redis/struct1/rehash%E4%B9%8B%E5%89%8D%E7%9A%84%E5%AD%97%E5%85%B8.png" alt="rehash之前的字典"></p>
<p> <img src="/images/redis/struct1/%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84ht%5B1%5D%E5%88%86%E9%85%8D%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="为字典的ht[1]分配表空间"></p>
<p>2.将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。 </p>
<p><img src="/images/redis/struct1/%E7%A7%BB%E5%8A%A8%E9%94%AE%E5%80%BC%E5%AF%B9.png" alt="移动键值对"></p>
<p>3.释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</p>
<p><img src="/images/redis/struct1/rehash%E4%B9%8B%E5%90%8E%E7%9A%84%E5%AD%97%E5%85%B8.png" alt="rehash之后的字典"></p>
<h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><p><strong>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作</strong></p>
<p>1.服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；<br>2.服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</p>
<p><code>负载因子的计算公式</code>:</p>
<p>负载因子 = 哈希表已保存节点数量 / 哈希表大小</p>
<p>load_factor = ht[0].used / ht[0].size</p>
<p><strong>当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</strong></p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><h3 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h3><p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<h3 id="渐进式rehash的步骤"><a href="#渐进式rehash的步骤" class="headerlink" title="渐进式rehash的步骤"></a>渐进式rehash的步骤</h3><p>1.为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。<br>2.在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。<strong>rehashidx代表当前rehash的索引</strong><br>3.在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， <code>程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]</code> ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。<br>4.随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为<code> -1</code> ， 表示 rehash 操作已完成。</p>
<h3 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h3><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-12-20/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-12-20/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">redis设计与实现-介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-20 01:10:57" itemprop="dateCreated datePublished" datetime="2017-12-20T01:10:57+08:00">2017-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>可基于内存的、也可以持久化的日志型的、key-value形式的非关系型数据库<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2></li>
<li>是意大利的一家做实时统计系统的公司在使用mysql时，创始人Salvatore Sanfilippo发现mysql的性能非常低下。于2009年开发完成的redis数据库，并将该数据库开源。VMware公司从2010年赞助redis的开发。<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2></li>
<li>读写性能：读110000/s  写 80000/s</li>
<li>value支持的类型：string 、hash 、list 、set、 zset  、BitMap、 HyperLogLog 、 geospatial</li>
<li>所有的操作是原子操作</li>
<li>支持数据库的备份，支持主从备份（master-slave）</li>
<li>支持订阅发布、通知以及key过期等特性<h2 id="相同产品对比"><a href="#相同产品对比" class="headerlink" title="相同产品对比"></a>相同产品对比</h2></li>
<li>名称     类型    数据存储选项      查询类型        附加功能</li>
<li>Redis    使用内存存储（in-memory） 的非关系数据库。字符串、列表、集合、散列表、有序集合。每种数据类型都有自己的专属命令;另外还有批量操作（bulk operation）和不完全（partial）的事务支持;发布与订阅， 主从复制（master/slave replication）， 持久化， 脚本（存储过程，stored procedure）</li>
<li>memcached    使用内存存储的键值缓存;键值之间的映射; 创建命令、读取命令、更新命令、删除命令以及其他几个命令;为提升性能而设的多线程服务器</li>
<li>MySQL    关系数据库;每个数据库可以包含多个表，每个表可以包含多个行； 可以处理多个表的视图（view）； 支持空间（spatial）和第三方扩展;SELECT 、 INSERT 、 UPDATE 、 DELETE 、函数、存储过程;支持ACID性质（需要使用InnoDB）， 主从复制和主主复制 （master/master replication）</li>
<li>PostgreSQL    关系数据库 ;每个数据库可以包含多个表， 每个表可以包含多个行； 可以处理多个表的视图；  支持空间和第三方扩展；支持可定制类型    SELECT 、 INSERT 、 UPDATE 、 DELETE 、内置函数、自定义的存储过程    支持ACID性质，主从复制， 由第三方支持的多主复制 （multi-master replication）</li>
<li>MongoDB    使用硬盘存储（on-disk）的非关系文档存储;每个数据库可以包含多个表， 每个表可以包含多个无schema （schema-less）的BSON文档;创建命令、读取命令、更新命令、删除命令、条件查询命令，等等;    支持map-reduce操作，主从复制，分片， 空间索引（spatial index）</li>
</ul>
<h2 id="redis服务器命令"><a href="#redis服务器命令" class="headerlink" title="redis服务器命令"></a>redis服务器命令</h2><ul>
<li>启动服务命令  ./redis-server &amp;</li>
<li>启动客户端命令  ./redis-cli -h 127.0.0.1 -p 6379 -a password (远程启动)</li>
<li>ping 检测是否启动 如果启动返回的是pong</li>
<li>查看配置的命令 config get *   或者 info</li>
<li>保存当前数据库的数据到磁盘 save</li>
<li>恢复数据只需将备份文件（dump.rdb）放到安装目录启动服务即可（config get dir）</li>
<li>查看所有客户端 client list</li>
<li>查看数据库key的数量  dbsize</li>
<li>删除所有数据库的key  flushall</li>
</ul>
<h2 id="数据类型的基本命令"><a href="#数据类型的基本命令" class="headerlink" title="数据类型的基本命令"></a>数据类型的基本命令</h2><ul>
<li>String   存：set key value  取：get key  一个键最大存储512M</li>
<li>hash     存：hmset  key  name chen age 27   取 hgetall key (取一组数据)  hget key filed   删除：hdel key field2</li>
<li>list     存：lpush key value    取：lrange key index0   indexN</li>
<li>set      存: sadd key member  取：smembers key (不允许重复)</li>
<li>zset     存：zadd key score member  取:zrangebyscore  key 100 10000      或 zrange key 0 1000</li>
</ul>
<h2 id="keys操作命令"><a href="#keys操作命令" class="headerlink" title="keys操作命令"></a>keys操作命令</h2><ul>
<li>del key  删除操作</li>
<li>exists key 是否存在</li>
<li>expire key n  设置超时时间（s）</li>
<li>persist key  移除key的超时时间</li>
<li>ttl key  查看key的剩余超时时间 （-1代表永久存在）</li>
<li>rename  key newKey   修改key的名称</li>
<li>type key 返回可以的类型</li>
</ul>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><ul>
<li>订阅：subscribe channel</li>
<li>发布：publish channel “some thing”</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>开始事务 命令入队 执行事务</li>
<li>multi    command   exec</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>查看是否设置密码： config get requirepass</li>
<li>设置密码: config set requirepass “password”</li>
<li>登录验证: auth password</li>
</ul>
<h2 id="redis分区"><a href="#redis分区" class="headerlink" title="redis分区"></a>redis分区</h2><h2 id="java使用redis的相关操作"><a href="#java使用redis的相关操作" class="headerlink" title="java使用redis的相关操作"></a>java使用redis的相关操作</h2><h2 id="redis的数据类型的内部实现"><a href="#redis的数据类型的内部实现" class="headerlink" title="redis的数据类型的内部实现"></a>redis的数据类型的内部实现</h2><p><strong>首先Redis内部使用一个redisObject对象来表示所有的key和value。</strong></p>
<p>字段包括：数据类型（type）、编码方式（encoding）、数据指针（ptr）、虚拟内存（vm）、其他信息 （…）</p>
<p><code>type的值</code>：(String，hash，list，set，sorted set)</p>
<p><code>encoding</code> (raw,int,ht,zipmap,linkedlist,ziplist,intset)</p>
<p><code>vm字段</code>，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的</p>
<p><strong>字符串</strong>可以被编码为 raw (常规字符串) 或者int (用字符串表示64位无符号整数这种编码方式是为了节省空间).</p>
<p><strong>列表类型</strong>可以被编码为ziplist 或者 linkedlist. ziplist 是为了节省较小的列表空间而设计一种特殊编码方式.</p>
<p><strong>集合被编码</strong>为 intset 或者 hashtable. intset 是为了存储数字的较小集合而设计的一种特殊编码方式.</p>
<p><strong>哈希表</strong>可以被编码为 zipmap 或者hashtable. zipmap 是专为了较小的哈希表而设计的一种特殊编码方式</p>
<p><strong>有序集合</strong>被编码为ziplist 或者 skiplist 格式. ziplist可以表示较小的有序集合, skiplist 表示任意大小多的有序集合.</p>
<h2 id="基本数据类型介绍"><a href="#基本数据类型介绍" class="headerlink" title="基本数据类型介绍"></a>基本数据类型介绍</h2><h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><ul>
<li>常用命令：</li>
</ul>
<p>set,get,decr,incr 等。</p>
<ul>
<li>应用场景：</li>
</ul>
<p>String是最常用的一种数据类型，普通的key/value存储都可以归为此类。</p>
<ul>
<li>实现方式：</li>
</ul>
<p>默认存储是二进制安全的字符串，被redisObject所引用，当遇到incr、decr操作时。将其转为数值型进行计算，此时redisObject的encoding类型为int</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ul>
<li>常用命令：</li>
</ul>
<p>hget,hset,hgetall 等。</p>
<ul>
<li>应用场景：</li>
</ul>
<p>根据用户id查找用户的姓名，年龄，出生地等信息。</p>
<ul>
<li>存储方式 </li>
</ul>
<p>1.key为id 将他的基本信息存到一个对象后以序列化的方式存储。 序列化发序列化成本高<br>2.key为id：姓名  key为id：年龄 多个key-value键值对存储。    多个键值对 不好维护<br>3.采用hash存储</p>
<ul>
<li>实现方式</li>
</ul>
<p>当成员较少时，为了节省内存，value的redisObject采用的encoding是zipmap；当数量增大时自动转为HashMap，此时encoding是ht这个限制可以在配置文件中指定（默认配置在redis根目录下的redis.conf中）</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>常用命令：</li>
</ul>
<p>lpush,rpush,lpop,rpop,lrange等。</p>
<ul>
<li>应用场景：</li>
</ul>
<p>Redis list的应用场景非常多，比如各种粉丝列表，不需要排序的列表</p>
<ul>
<li>实现方式：</li>
</ul>
<p>list的实现为一个双向链表，即可以支持反向查找和遍历。<br>如果redisObject的type成员值是REDIS_LIST类型的，则当该list的元素个数小于配置值list-max-ziplist-entries且元素值字符串的长度小于配置值list-max-ziplist-value则可以编码成 REDIS_ENCODING_ZIPLIST 类型存储，否则采用 Dict 来存储(Dict实际是Hash Table的一种实现，list采用ziplist数据结构存储数据，（默认配置在redis根目录下的redis.conf中）</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>常用命令：</li>
</ul>
<p>sadd,spop,smembers,sunion 等。</p>
<ul>
<li>应用场景：</li>
</ul>
<p>set类似于list，但可以自动排重。当你需要一个要求元素不能重复的集合是可以使用set</p>
<ul>
<li>实现方式：</li>
</ul>
<p>当set集合中的元素为整数且元素个数小于配置set-max-intset-entries值时，使用intset数据结构存储(int16_t类型、int32_t 类型、 int64_t 类型。至于怎么选择是那种类型的数组，是根据其保存的值的取值范围来决定的).否则转化为Dict结构，Dict实际是Hash Table的一种实现</p>
<h3 id="Sorted-set"><a href="#Sorted-set" class="headerlink" title="Sorted set"></a>Sorted set</h3><ul>
<li>常用命令：</li>
</ul>
<p>zadd,zrange,zrem,zcard等</p>
<ul>
<li>使用场景：</li>
</ul>
<p>当你需要一个有序的并且不重复的集合列表，那么 可以选择sorted set数据结构</p>
<ul>
<li>实现方式：</li>
</ul>
<p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的 是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率</p>
<h2 id="redis版本介绍"><a href="#redis版本介绍" class="headerlink" title="redis版本介绍"></a>redis版本介绍</h2><p><a target="_blank" rel="noopener" href="http://book.51cto.com/art/201704/538507.htm">redis版本介绍</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-12-18/canal-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A2%E9%98%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-12-18/canal-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A2%E9%98%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">canal-阿里开源的增量数据订阅与消费框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-18 13:18:54" itemprop="dateCreated datePublished" datetime="2017-12-18T13:18:54+08:00">2017-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/canal/" itemprop="url" rel="index"><span itemprop="name">canal</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  最近拿到一个需求，需要根据数据的变化，实时通知业务方更新redis缓存。所以研究了canal开源框架。</p>
<p>  具体业务是，监控库中订单表的某条订单状态发生变化，则将该条数据的id通过kafka的生产者写入topic，业务方从topic中读取订单的id，然后从库里获取订单的数据更新redis。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p> <a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">canal源码</a>中包含canal的文档，server端 client端的 例子 源码包等等。</p>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p> canal是应阿里巴巴存在杭州和美国的双机房部署，存在跨机房同步的业务需求而提出的。目前内部使用的同步，已经支持mysql5.x和oracle部分版本的日志解析</p>
<h1 id="支持的业务（数据库同步，增量订阅-amp-消费。）"><a href="#支持的业务（数据库同步，增量订阅-amp-消费。）" class="headerlink" title="支持的业务（数据库同步，增量订阅&amp;消费。）"></a>支持的业务（数据库同步，增量订阅&amp;消费。）</h1><p>数据库镜像、数据库实时备份、多级索引（卖家和买家各自分库索引）、<strong>业务cache刷新</strong>、价格变化等重要业务消息、</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="mysql主备复制实现"><a href="#mysql主备复制实现" class="headerlink" title="mysql主备复制实现"></a>mysql主备复制实现</h2><p>如下图所示：</p>
<p> <img src="/images/canal/mysql%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0.jpg" alt="mysql主备复制实现"></p>
<p>从上图看主要分为三个步骤：</p>
<p>1.master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）；</p>
<p> <img src="/images/canal/%E6%9F%A5%E7%9C%8Bbinlog%E6%97%A5%E5%BF%97.png" alt="查看binlog日志"></p>
<p>2.slave将master的binary log events拷贝到它的中继日志(relay log)；</p>
<p>3.slave重做中继日志中的事件，将改变反映它自己的数据。</p>
<h2 id="canal的工作原理"><a href="#canal的工作原理" class="headerlink" title="canal的工作原理"></a>canal的工作原理</h2><p> <img src="/images/canal/canal%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="canal的工作原理"></p>
<p>原理如下：</p>
<p>1.canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议</p>
<p>2.mysql master收到dump请求，开始推送binary log给slave(也就是canal)</p>
<p>3.canal解析binary log对象(原始为byte流)</p>
<h1 id="部署（实例）"><a href="#部署（实例）" class="headerlink" title="部署（实例）"></a>部署（实例）</h1><h2 id="部署canal-server端"><a href="#部署canal-server端" class="headerlink" title="部署canal-server端"></a>部署canal-server端</h2><ol>
<li>开启mysql的binlog功能，并配置binlog模式为row。在mysql的my.cnf下加入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]  </span><br><span class="line">log-bin&#x3D;mysql-bin #添加这一行就ok  </span><br><span class="line">binlog-format&#x3D;ROW #选择row模式  </span><br><span class="line">server_id&#x3D;1 #配置mysql replaction需要定义，不能和canal的slaveId重复  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>canal的原理是模拟自己为mysql的slave，所以这里需要作为mysql slave的权限,而正对已有账户则可以直接grand操作。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER canal IDENTIFIED BY &#39;canal&#39;;  </span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;canal&#39;@&#39;%&#39;;</span><br><span class="line">-- GRANT ALL PRIVILEGES ON *.* TO &#39;canal&#39;@&#39;%&#39; ;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下载<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/releases">canal</a>对应的版需要修改</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>vim canal/conf/example/instance.properties </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">## mysql serverId (要求不与主库的id一样)</span><br><span class="line">canal.instance.mysql.slaveId &#x3D; 1234</span><br><span class="line"></span><br><span class="line"># position info （主库的ip和port）</span><br><span class="line">canal.instance.master.address &#x3D; 127.0.0.1:3306</span><br><span class="line">canal.instance.master.journal.name &#x3D; </span><br><span class="line">canal.instance.master.position &#x3D; </span><br><span class="line">canal.instance.master.timestamp &#x3D; </span><br><span class="line"></span><br><span class="line">#canal.instance.standby.address &#x3D; </span><br><span class="line">#canal.instance.standby.journal.name &#x3D;</span><br><span class="line">#canal.instance.standby.position &#x3D; </span><br><span class="line">#canal.instance.standby.timestamp &#x3D; </span><br><span class="line"></span><br><span class="line"># username&#x2F;password（主库的账号和密码）</span><br><span class="line">canal.instance.dbUsername &#x3D; canal</span><br><span class="line">canal.instance.dbPassword &#x3D; canal</span><br><span class="line">canal.instance.defaultDatabaseName &#x3D;</span><br><span class="line">canal.instance.connectionCharset &#x3D; UTF-8</span><br><span class="line"></span><br><span class="line"># table regex </span><br><span class="line">canal.instance.filter.regex &#x3D; .*\\..*</span><br><span class="line"># table black regex</span><br><span class="line">canal.instance.filter.black.regex &#x3D;  </span><br><span class="line"></span><br><span class="line">#################################################</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vim canal/conf/canal.properties </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">#########         common argument        ############# </span><br><span class="line">#################################################</span><br><span class="line">canal.id&#x3D; 1</span><br><span class="line">canal.ip&#x3D;</span><br><span class="line">canal.port&#x3D; 11111</span><br><span class="line">canal.zkServers&#x3D;</span><br><span class="line"># flush data to zk</span><br><span class="line">canal.zookeeper.flush.period &#x3D; 1000</span><br><span class="line"># flush meta cursor&#x2F;parse position to file</span><br><span class="line">canal.file.data.dir &#x3D; $&#123;canal.conf.dir&#125;</span><br><span class="line">canal.file.flush.period &#x3D; 1000</span><br><span class="line">## memory store RingBuffer size, should be Math.pow(2,n)</span><br><span class="line">canal.instance.memory.buffer.size &#x3D; 16384</span><br><span class="line">## memory store RingBuffer used memory unit size , default 1kb</span><br><span class="line">canal.instance.memory.buffer.memunit &#x3D; 1024 </span><br><span class="line">## meory store gets mode used MEMSIZE or ITEMSIZE</span><br><span class="line">canal.instance.memory.batch.mode &#x3D; MEMSIZE</span><br><span class="line"></span><br><span class="line">## detecing config</span><br><span class="line">canal.instance.detecting.enable &#x3D; false</span><br><span class="line">#canal.instance.detecting.sql &#x3D; insert into retl.xdual values(1,now()) on duplicate key update x&#x3D;now()</span><br><span class="line">canal.instance.detecting.sql &#x3D; select 1</span><br><span class="line">canal.instance.detecting.interval.time &#x3D; 3</span><br><span class="line">canal.instance.detecting.retry.threshold &#x3D; 3</span><br><span class="line">canal.instance.detecting.heartbeatHaEnable &#x3D; false</span><br><span class="line"></span><br><span class="line"># support maximum transaction size, more than the size of the transaction will be cut into multiple transactions delivery</span><br><span class="line">canal.instance.transaction.size &#x3D;  1024</span><br><span class="line"># mysql fallback connected to new master should fallback times</span><br><span class="line">canal.instance.fallbackIntervalInSeconds &#x3D; 60</span><br><span class="line"></span><br><span class="line"># network config</span><br><span class="line">canal.instance.network.receiveBufferSize &#x3D; 16384</span><br><span class="line">canal.instance.network.sendBufferSize &#x3D; 16384</span><br><span class="line">canal.instance.network.soTimeout &#x3D; 30</span><br><span class="line"></span><br><span class="line"># binlog filter config</span><br><span class="line">canal.instance.filter.query.dcl &#x3D; false</span><br><span class="line">canal.instance.filter.query.dml &#x3D; false</span><br><span class="line">canal.instance.filter.query.ddl &#x3D; false</span><br><span class="line">canal.instance.filter.table.error &#x3D; false</span><br><span class="line">canal.instance.filter.rows &#x3D; false</span><br><span class="line"></span><br><span class="line"># binlog format&#x2F;image check</span><br><span class="line">canal.instance.binlog.format &#x3D; ROW,STATEMENT,MIXED </span><br><span class="line">canal.instance.binlog.image &#x3D; FULL,MINIMAL,NOBLOB</span><br><span class="line"></span><br><span class="line"># binlog ddl isolation</span><br><span class="line">canal.instance.get.ddl.isolation &#x3D; false</span><br><span class="line"></span><br><span class="line">#################################################</span><br><span class="line">#########         destinations        ############# </span><br><span class="line">#################################################</span><br><span class="line">canal.destinations&#x3D; example,instance_user_cache_provider</span><br><span class="line"># conf root dir</span><br><span class="line">canal.conf.dir &#x3D; ..&#x2F;conf</span><br><span class="line"># auto scan instance dir add&#x2F;remove and start&#x2F;stop instance</span><br><span class="line">canal.auto.scan &#x3D; false</span><br><span class="line">canal.auto.scan.interval &#x3D; 5</span><br><span class="line"></span><br><span class="line">canal.instance.global.mode &#x3D; spring </span><br><span class="line">canal.instance.global.lazy &#x3D; false</span><br><span class="line">#canal.instance.global.manager.address &#x3D; 127.0.0.1:1099</span><br><span class="line">#canal.instance.global.spring.xml &#x3D; classpath:spring&#x2F;memory-instance.xml</span><br><span class="line">canal.instance.global.spring.xml &#x3D; classpath:spring&#x2F;file-instance.xml</span><br><span class="line">#canal.instance.global.spring.xml &#x3D; classpath:spring&#x2F;default-instance.xml</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>./bin/startup.sh</p>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>./bin/stop.sh</p>
<p>查看log日志</p>
<p>cat canal/log/canal/canal.log  </p>
<h2 id="部署canal-client端"><a href="#部署canal-client端" class="headerlink" title="部署canal-client端"></a>部署canal-client端</h2><h3 id="创建maven工程，添加pom依赖"><a href="#创建maven工程，添加pom依赖" class="headerlink" title="创建maven工程，添加pom依赖"></a>创建maven工程，添加pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.alibaba.otter&lt;&#x2F;groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;canal.client&lt;&#x2F;artifactId&gt;  </span><br><span class="line">    &lt;version&gt;1.0.12&lt;&#x2F;version&gt;  </span><br><span class="line">&lt;&#x2F;dependency&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Created by chenwj on 17-11-17. </span><br><span class="line"> *&#x2F;  </span><br><span class="line">import java.net.InetSocketAddress;  </span><br><span class="line">import java.util.List;  </span><br><span class="line">  </span><br><span class="line">import com.alibaba.otter.canal.client.CanalConnector;  </span><br><span class="line">import com.alibaba.otter.canal.common.utils.AddressUtils;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.Message;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.Column;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.Entry;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.EntryType;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.EventType;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.RowChange;  </span><br><span class="line">import com.alibaba.otter.canal.protocol.CanalEntry.RowData;  </span><br><span class="line">import com.alibaba.otter.canal.client.*;  </span><br><span class="line">import org.jetbrains.annotations.NotNull;  </span><br><span class="line">  </span><br><span class="line">public class ClientSample &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 创建链接   第一个为服务端的ip  第二个为端口 在canal.properties 配置文件中配置 第三个参数为实例的名称   第三个和第四个参数可以不配置</span><br><span class="line">        CanalConnector connector &#x3D; CanalConnectors.newSingleConnector(new InetSocketAddress(AddressUtils.getHostIp(),  </span><br><span class="line">                11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;);  </span><br><span class="line">        int batchSize &#x3D; 1000;  </span><br><span class="line">        int emptyCount &#x3D; 0;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            connector.connect();  </span><br><span class="line">            connector.subscribe(&quot;.*\\..*&quot;);  </span><br><span class="line">            connector.rollback();  </span><br><span class="line">            int totalEmtryCount &#x3D; 1200;  </span><br><span class="line">            while (emptyCount &lt; totalEmtryCount) &#123;  </span><br><span class="line">                Message message &#x3D; connector.getWithoutAck(batchSize); &#x2F;&#x2F; 获取指定数量的数据  </span><br><span class="line">                long batchId &#x3D; message.getId();  </span><br><span class="line">                int size &#x3D; message.getEntries().size();  </span><br><span class="line">                if (batchId &#x3D;&#x3D; -1 || size &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">                    emptyCount++;  </span><br><span class="line">                    System.out.println(&quot;empty count : &quot; + emptyCount);  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        Thread.sleep(1000);  </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    emptyCount &#x3D; 0;  </span><br><span class="line">                    &#x2F;&#x2F; System.out.printf(&quot;message[batchId&#x3D;%s,size&#x3D;%s] \n&quot;, batchId, size);  </span><br><span class="line">                    printEntry(message.getEntries());  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                connector.ack(batchId); &#x2F;&#x2F; 提交确认  </span><br><span class="line">                &#x2F;&#x2F; connector.rollback(batchId); &#x2F;&#x2F; 处理失败, 回滚数据  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;empty too many times, exit&quot;);  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            connector.disconnect();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private static void printEntry(@NotNull List&lt;Entry&gt; entrys) &#123;  </span><br><span class="line">        for (Entry entry : entrys) &#123;  </span><br><span class="line">            if (entry.getEntryType() &#x3D;&#x3D; EntryType.TRANSACTIONBEGIN || entry.getEntryType() &#x3D;&#x3D; EntryType.TRANSACTIONEND) &#123;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            RowChange rowChage &#x3D; null;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                rowChage &#x3D; RowChange.parseFrom(entry.getStoreValue());  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                throw new RuntimeException(&quot;ERROR ## parser of eromanga-event has an error , data:&quot; + entry.toString(),  </span><br><span class="line">                        e);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            EventType eventType &#x3D; rowChage.getEventType();  </span><br><span class="line">            System.out.println(String.format(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;,  </span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),  </span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),  </span><br><span class="line">                    eventType));  </span><br><span class="line">  </span><br><span class="line">            for (RowData rowData : rowChage.getRowDatasList()) &#123;  </span><br><span class="line">                if (eventType &#x3D;&#x3D; EventType.DELETE) &#123;  </span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());  </span><br><span class="line">                &#125; else if (eventType &#x3D;&#x3D; EventType.INSERT) &#123;  </span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    System.out.println(&quot;-------&gt; before&quot;);  </span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());  </span><br><span class="line">                    System.out.println(&quot;-------&gt; after&quot;);  </span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private static void printColumn(@NotNull List&lt;Column&gt; columns) &#123;  </span><br><span class="line">        for (Column column : columns) &#123;  </span><br><span class="line">            System.out.println(column.getName() + &quot; : &quot; + column.getValue() + &quot;    update&#x3D;&quot; + column.getUpdated());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="启动客户端的main方法"><a href="#启动客户端的main方法" class="headerlink" title="启动客户端的main方法"></a>启动客户端的main方法</h3><p>启动后看到控制端信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">empty count : 1  </span><br><span class="line">empty count : 2  </span><br><span class="line">empty count : 3  </span><br><span class="line">empty count : 4  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>触发数据改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table test (  </span><br><span class="line">uid int (4) primary key not null auto_increment,  </span><br><span class="line">name varchar(10) not null);  </span><br><span class="line">  </span><br><span class="line">insert into test (name) values(&#39;10&#39;);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; binlog[mysql-bin.000016:3281] , name[canal_test,test] , eventType : INSERT  </span><br><span class="line">uid : 7    update&#x3D;false  </span><br><span class="line">name : 10    update&#x3D;false  </span><br><span class="line">empty count : 1  </span><br><span class="line">empty count : 2  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上只是简单的单机模式的demo，集群模式和具体的配置文件中的参数详见<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/wiki/AdminGuide">配置</a>。</p>
<p>其中spring的配置文件采用默认的 canal.instance.global.spring.xml = classpath:spring/file-instance.xml</p>
<p>而xxxx-instance.xml (canal组件的配置定义，可以在多个instance配置中共享) </p>
<p>如下所示为多个示例</p>
<p> <img src="/images/canal/%E5%A4%9A%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%85%8D%E7%BD%AE.jpg" alt="多实例的文件"></p>
<p>数据对象格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Entry  </span><br><span class="line">    Header  </span><br><span class="line">        logfileName [binlog文件名]  </span><br><span class="line">        logfileOffset [binlog position]  </span><br><span class="line">        executeTime [binlog里记录变更发生的时间戳,精确到秒]  </span><br><span class="line">        schemaName   </span><br><span class="line">        tableName  </span><br><span class="line">        eventType [insert&#x2F;update&#x2F;delete类型]  </span><br><span class="line">    entryType   [事务头BEGIN&#x2F;事务尾END&#x2F;数据ROWDATA]  </span><br><span class="line">    storeValue  [byte数据,可展开，对应的类型为RowChange]  </span><br><span class="line">RowChange</span><br><span class="line"></span><br><span class="line">isDdl       [是否是ddl变更操作，比如create table&#x2F;drop table]</span><br><span class="line"></span><br><span class="line">sql         [具体的ddl sql]</span><br><span class="line"></span><br><span class="line">rowDatas    [具体insert&#x2F;update&#x2F;delete的变更数据，可为多条，1个binlog event事件可对应多条变更，比如批处理]</span><br><span class="line"></span><br><span class="line">beforeColumns [Column类型的数组，变更前的数据字段]</span><br><span class="line"></span><br><span class="line">afterColumns [Column类型的数组，变更后的数据字段]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Column</span><br><span class="line"></span><br><span class="line">index</span><br><span class="line"></span><br><span class="line">sqlType     [jdbc type]</span><br><span class="line"></span><br><span class="line">name        [column name]</span><br><span class="line"></span><br><span class="line">isKey       [是否为主键]</span><br><span class="line"></span><br><span class="line">updated     [是否发生过变更]</span><br><span class="line"></span><br><span class="line">isNull      [值是否为null]</span><br><span class="line"></span><br><span class="line">value       [具体的内容，注意为string文本]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/wiki">更详细讲解</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/hackerwin7/article/details/37923607">参考博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-12-03/SQL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%20%E7%B4%A2%E5%BC%95%20%E4%BA%8B%E5%8A%A1%20%E7%BA%A6%E6%9D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-12-03/SQL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%20%E7%B4%A2%E5%BC%95%20%E4%BA%8B%E5%8A%A1%20%E7%BA%A6%E6%9D%9F/" class="post-title-link" itemprop="url">《SQL基础》SQL学习指南学习笔记三 索引 事务 约束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-03 23:02:39" itemprop="dateCreated datePublished" datetime="2017-12-03T23:02:39+08:00">2017-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sql/" itemprop="url" rel="index"><span itemprop="name">sql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SQL约束用于规定表中的数据规则，如果存在违反约束的数据行为，行为将会被约束终止；</p>
<p>约束可以在创建表时规定，或者在创建表之后通过alter table 语句。</p>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">CREATE TABLE table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(size) constraint_name,</span><br><span class="line">column_name2 data_type(size) constraint_name,</span><br><span class="line">column_name3 data_type(size) constraint_name,</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">CREATE TABLE www (</span><br><span class="line">    id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(25) NOT NULL DEFAULT &#39;defaultName&#39;,</span><br><span class="line">    createTime DATETIME NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">)  ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;UTF8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="约束的种类"><a href="#约束的种类" class="headerlink" title="约束的种类"></a>约束的种类</h2><h3 id="NOT-NULL，非空约束"><a href="#NOT-NULL，非空约束" class="headerlink" title="NOT NULL，非空约束"></a>NOT NULL，非空约束</h3><p>指示某列不能存储 NULL 值。（如果不向字段添加值，就无法插入新记录或者更新记录）<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="UNIQUE-唯一约束"><a href="#UNIQUE-唯一约束" class="headerlink" title="UNIQUE:唯一约束"></a>UNIQUE:唯一约束</h3><p>保证某列的每行必须有唯一的值。（如果字段中添加的值和库里该字段中的值重复，则无法插入或者更新）</p>
<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;create table tb2(</span><br><span class="line">    tb2_id int unique,</span><br><span class="line">    tb2_name varchar(20),</span><br><span class="line">    tb2_age int,</span><br><span class="line">    unique(tb2_name)</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.40 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tb2(tb2_id,tb2_name,tb2_age) values(1,&#39;张三&#39;,20);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">例子2：</span><br><span class="line">&#x2F;&#x2F;违反唯一约束</span><br><span class="line">mysql&gt; insert into tb2 values(2,&#39;张三&#39;,25);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;张三&#39; for key &#39;tb2_name&#39;</span><br><span class="line"></span><br><span class="line">例子3：</span><br><span class="line">&#x2F;&#x2F;建表时，创建约束，有约束名</span><br><span class="line">mysql&gt; create table tb3( tb3_id int,tb3_name varchar(20),tb3_age int, constraint no_id unique (tb3_id));</span><br><span class="line">Query OK, 0 rows affected (0.33 sec)</span><br><span class="line"></span><br><span class="line">insert into tb3 values (1,&#39;张三&#39;,20);</span><br><span class="line">insert into tb3(tb3_id,tb3_age) values(2,24);</span><br><span class="line">select * from tb3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经有了tb3_id为1的行记录，再次插入，违反唯一约束</span><br><span class="line">mysql&gt; insert into tb3(tb3_id,tb3_name,tb3_age) values(1,&#39;李四&#39;,&#39;26&#39;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;no_id&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给tb3表添加主键约束，主键名为：pk_id</span><br><span class="line">alter table tb3 add constraint pk_id primary key (tb3_id);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给tb3_name添加唯一约束</span><br><span class="line">alter table tb3 add constraint un_name unique (tb3_name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已存在姓名为张三的记录，违反唯一约束</span><br><span class="line">mysql&gt; insert into tb3 values(3,&#39;张三&#39;,29);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;张三&#39; for key &#39;un_name&#39;</span><br><span class="line"></span><br><span class="line">删除约束</span><br><span class="line">mysql 删除约束的语句，使用index</span><br><span class="line">alter table tb3 drop index un_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="PRIMARY-KEY-主键约束"><a href="#PRIMARY-KEY-主键约束" class="headerlink" title="PRIMARY KEY: 主键约束"></a>PRIMARY KEY: 主键约束</h3><p>NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p>
<p>特点：PRIMARY KEY 约束唯一标识数据库表中的每条记录。<br>        主键必须包含唯一的值。<br>        主键列不能包含 NULL 值。<br>        每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">PRIMARY KEY (P_Id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">需要制定约束名称的，且可以制定多个列的主键约束。</span><br><span class="line"></span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">添加主键约束:</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (P_Id)</span><br><span class="line">如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：</span><br><span class="line">ALTER TABLE Persons ADD CONSTRAINT pk_personId  PRIMARY KEY (P_id,lastName)</span><br><span class="line"></span><br><span class="line">删除主键约束：</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP  PRIMARY KEY</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FOREIGN-KEY-外键约束"><a href="#FOREIGN-KEY-外键约束" class="headerlink" title="FOREIGN KEY: 外键约束"></a>FOREIGN KEY: 外键约束</h3><p>保证一个表中的数据匹配另一个表中的值的参照完整性；</p>
<p>约束用于预防破坏表之间连接的行为；</p>
<p>约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一；</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">P_Id int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：</span><br><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">O_Id int NOT NULL,</span><br><span class="line">OrderNo int NOT NULL,</span><br><span class="line">P_Id int,</span><br><span class="line">PRIMARY KEY (O_Id),</span><br><span class="line">CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)</span><br><span class="line">REFERENCES Persons(P_Id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当 &quot;Orders&quot; 表已被创建时，如需在 &quot;P_Id&quot; 列创建 FOREIGN KEY 约束</span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (P_Id)</span><br><span class="line">REFERENCES Persons(P_Id)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;撤销 FOREIGN KEY 约束</span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">DROP FOREIGN KEY fk_PerOrders</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CHECK-检查约束"><a href="#CHECK-检查约束" class="headerlink" title="CHECK :检查约束"></a>CHECK :检查约束</h3><p>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 保证列中的值符合指定的条件。</p>
<p>如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面的 SQL 在 &quot;Persons&quot; 表创建时在 &quot;P_Id&quot; 列上创建 CHECK 约束。CHECK 约束规定 &quot;P_Id&quot; 列必须只包含大于 0 的整数。</span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255),</span><br><span class="line">CHECK (P_Id&gt;0)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加CHECK约束</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD CHECK (P_Id&gt;0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除约束</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP CHECK chk_Person</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DEFAULT-规定没有给列赋值时的默认值。"><a href="#DEFAULT-规定没有给列赋值时的默认值。" class="headerlink" title="DEFAULT - 规定没有给列赋值时的默认值。"></a>DEFAULT - 规定没有给列赋值时的默认值。</h3><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Persons</span><br><span class="line">(</span><br><span class="line">P_Id int NOT NULL,</span><br><span class="line">LastName varchar(255) NOT NULL,</span><br><span class="line">FirstName varchar(255),</span><br><span class="line">Address varchar(255),</span><br><span class="line">City varchar(255) DEFAULT &#39;Sandnes&#39;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建DEFAULT约束</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City SET DEFAULT &#39;SANDNES&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如需撤销 DEFAULT 约束</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ALTER City DROP DEFAULT</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO INCREMENT"></a>AUTO INCREMENT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">该字段会使得每次新纪录插入表中时，生成唯一的数字。</span><br><span class="line">可以通过 alter table persons auto_increment&#x3D;100; 将自增值置为需要的值。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">mysql&gt; create table persons(ID int not null auto_increment,lastName varchar(255) not null ,city varchar(255), PRIMARY KEY(ID));</span><br><span class="line">Query OK, 0 rows affected (0.29 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into persons(lastName,city) values(&#39;zhangsan&#39;,&#39;beijing&#39;);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from persons;</span><br><span class="line">+----+----------+---------+</span><br><span class="line">| ID | lastName | city    |</span><br><span class="line">+----+----------+---------+</span><br><span class="line">|  1 | zhangsan | beijing |</span><br><span class="line">+----+----------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table persons auth_increment&#x3D;100;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; insert into persons(lastName,city) values(&#39;lisi&#39;,&#39;handan&#39;);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from persons;</span><br><span class="line">+-----+----------+---------+</span><br><span class="line">| ID  | lastName | city    |</span><br><span class="line">+-----+----------+---------+</span><br><span class="line">|   1 | zhangsan | beijing |</span><br><span class="line">| 100 | lisi     | handan  |</span><br><span class="line">+-----+----------+---------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="级联约束"><a href="#级联约束" class="headerlink" title="级联约束"></a>级联约束</h2><p>有了合适的外键约束后，如果读者视图插入新行或者修改行而导致父表中的外键列并无匹配值，则服务器会抛出异常</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from product;</span><br><span class="line">+------------+-------------------------+-----------------+--------------+--------------+</span><br><span class="line">| product_cd | name                    | product_type_cd | date_offered | date_retired |</span><br><span class="line">+------------+-------------------------+-----------------+--------------+--------------+</span><br><span class="line">| AUT        | auto loan               | LOAN            | 2000-01-01   | NULL         |</span><br><span class="line">| BUS        | business line of credit | LOAN            | 2000-01-01   | NULL         |</span><br><span class="line">| CD         | certificate of deposit  | ACCOUNT         | 2000-01-01   | NULL         |</span><br><span class="line">| CHK        | checking account        | ACCOUNT         | 2000-01-01   | NULL         |</span><br><span class="line">| MM         | money market account    | ACCOUNT         | 2000-01-01   | NULL         |</span><br><span class="line">| MRT        | home mortgage           | LOAN            | 2000-01-01   | NULL         |</span><br><span class="line">| SAV        | savings account         | ACCOUNT         | 2000-01-01   | NULL         |</span><br><span class="line">| SBL        | small business loan     | LOAN            | 2000-01-01   | NULL         |</span><br><span class="line">+------------+-------------------------+-----------------+--------------+--------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from product_type;</span><br><span class="line">+-----------------+-------------------------------+</span><br><span class="line">| product_type_cd | name                          |</span><br><span class="line">+-----------------+-------------------------------+</span><br><span class="line">| ACCOUNT         | Customer Accounts             |</span><br><span class="line">| INSURANCE       | Insurance Offerings           |</span><br><span class="line">| LOAN            | Individual and Business Loans |</span><br><span class="line">+-----------------+-------------------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update product set product_type_cd &#x3D;&#39;xyz&#39; where product_type_cd &#x3D;&#39;LOAN&#39;;</span><br><span class="line">ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (&#96;bank&#96;.&#96;product&#96;, CONSTRAINT &#96;fk_product_type_cd&#96; FOREIGN KEY (&#96;product_type_cd&#96;) REFERENCES &#96;product_type&#96; (&#96;product_type_cd&#96;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在product.product_type_cd列上有外键约束，而product_type表中没有哪一行的product_type_cd的列值为xyz，所有不会更新成功。<br>所谓级联的更新，在删除存在的外键和添加新的外键时包含on update cascade，这些外键约束的变化能够实现传播。</p>
<p>需要做以下修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alter table product add constraint fk_product_type_cd foreign key (product_type_cd) references product_type(product_type_cd) on update cascade;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="SQL索引-INDEX"><a href="#SQL索引-INDEX" class="headerlink" title="SQL索引 INDEX"></a>SQL索引 INDEX</h1><p>CREATE INDEX 语句用于在表中创建索引，在不读取整个表的情况下，索引数据库应用程序可以更快的查找数据。</p>
<p>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。</p>
<p>索引并不包含实体中的所有数据，而是那些用于定位表中的数据的列，以及描述行信息的列。</p>
<p>innodb引擎是支持事务的行锁引擎；mylsam引擎是不支持事务的表锁引擎，它支持全文索引（文本索引）</p>
<p>一般的索引为b树索引（平衡树索引） 它有一个或者多个分之节点，分之节点又指向单级叶子节点。分支节点用于遍历树，叶节点则保存真正的值和位置信息 。</p>
<h2 id="显示查询执行计划-（待完善）"><a href="#显示查询执行计划-（待完善）" class="headerlink" title="显示查询执行计划 （待完善）"></a>显示查询执行计划 （待完善）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; explain select * from account where cust_id in(1,5,9,11);</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | account | NULL       | ALL  | fk_a_cust_id  | NULL | NULL    | NULL |   24 |    33.33 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h2><p> 下面的 SQL 语句在 “Persons” 表的 “LastName” 列上创建一个名为 “PIndex” 的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX PIndex ON Persons(LastName);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>除了常规的索引的用途外，还可以限制索引列出现重复值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; alter table department add unique dept_name_unique_idx(name);</span><br><span class="line">Query OK, 0 rows affected (0.43 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from department;</span><br><span class="line">+------------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table      | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+------------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| department |          0 | PRIMARY              |            1 | dept_id     | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| department |          0 | dept_name_unique_idx |            1 | name        | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| department |          1 | dept_name_idx        |            1 | name        | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">+------------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p> 如果您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  CREATE INDEX PIndex ON Persons(LastName,FirstName);</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table employee add index emp_name_idx(lname,fname);</span><br><span class="line">Query OK, 0 rows affected (0.37 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from employee;</span><br><span class="line">+----------+------------+----------------+--------------+--------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table    | Non_unique | Key_name       | Seq_in_index | Column_name        | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+----------+------------+----------------+--------------+--------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| employee |          0 | PRIMARY        |            1 | emp_id             | A         |          18 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| employee |          1 | fk_e_emp_id    |            1 | superior_emp_id    | A         |           7 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| employee |          1 | fk_dept_id     |            1 | dept_id            | A         |           3 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| employee |          1 | fk_e_branch_id |            1 | assigned_branch_id | A         |           4 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| employee |          1 | emp_name_idx   |            1 | lname              | A         |          18 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| employee |          1 | emp_name_idx   |            2 | fname              | A         |          18 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">+----------+------------+----------------+--------------+--------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在创建多列索引时，必须仔细考虑那一列作为第一列，那一列作为第二列。</p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table department add index dept_name_idx(name);</span><br><span class="line">Query OK, 0 rows affected (0.35 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; alter table department drop index dept_name_idx;</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show index from department;</span><br><span class="line">+------------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table      | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+------------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| department |          0 | PRIMARY       |            1 | dept_id     | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| department |          1 | dept_name_idx |            1 | name        | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">+------------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>每一个索引实际上都是一个特殊的表，每次在添加或者删除行时，表中的所有索引都被修改。当数据越来越多时，会拖慢服务器的处理速度</p>
<p>仅仅当出现清晰需求时才添加索引。</p>
<p>如有特殊需求需要索引，可以添加索引，运行程序，然后删除索引。下次也是如此。</p>
<p><strong>默认策略</strong></p>
<ol>
<li>确保所有的逐渐被索引，大部分数据库服务器在创建主键约束的时候会自动生成唯一索引；</li>
<li>为所有被外键约束引用的列创建索引。在服务器准备删除父行时会搜索对应的子行是否存在，它必须发出一个查询搜索列中的特殊值。</li>
<li>大多是日期可以作为索引；</li>
</ol>
<h1 id="CREATE-VIEW-视图"><a href="#CREATE-VIEW-视图" class="headerlink" title="CREATE VIEW 视图"></a>CREATE VIEW 视图</h1><p>视图是基于 SQL 语句的结果集的可视化的表，不同于表的是，视图不涉及数据存储，因此用户不必担心数据会充满磁盘空间、</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<h2 id="视图的使用情况"><a href="#视图的使用情况" class="headerlink" title="视图的使用情况"></a>视图的使用情况</h2><ol>
<li>可以保证数据的安全性；</li>
<li>数据聚合；</li>
<li>隐藏复杂性；</li>
<li>连接分区数据；</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT * from view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>满足以下条件，视图则可以被更新。</p>
<ol>
<li>没有使用聚合函数；</li>
<li>没有使用having 或者group by语句；</li>
<li>没有使用union all 、union、distinct语句；</li>
<li>from包括不止一个表或者视图；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="撤销视图"><a href="#撤销视图" class="headerlink" title="撤销视图"></a>撤销视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create view viewTest as select * from persons where ID&gt;10;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from viewTest;</span><br><span class="line">+-----+----------+--------+</span><br><span class="line">| ID  | lastName | city   |</span><br><span class="line">+-----+----------+--------+</span><br><span class="line">| 100 | lisi     | handan |</span><br><span class="line">+-----+----------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; drop view viewTest;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from viewTest;</span><br><span class="line">ERROR 1146 (42S02): Table &#39;testDB.viewTest&#39; doesn&#39;t exist</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol>
<li><p>事务是指，一堆sql要么执行，要么执行，这成为原子性。</p>
</li>
<li><p>说到事务，就必须提锁。锁时数据库服务器用来控制数据资源被并行使用的一种机制。</p>
</li>
<li><p>数据库的写操作必须向服务器申请写锁才能够修改数据。而读操作必须获得读锁才能读取数据。</p>
</li>
<li><p>读写锁是指，一次事务只能有一个写锁不能有读锁或者多个读锁不能有写锁。</p>
</li>
<li><p>服务器要保证从查询开始到查询结束看到一个一致性的数据视图。这个方法成为版本控制。</p>
</li>
<li><p>锁的粒度分为表锁、页锁、行锁。</p>
</li>
<li><p>表锁需要较少的簿记就可以锁定整个表，但是用户增多时他会迅速产生不可接受的等待时间；行锁需要更多的簿记，但是各个用户在不同的行，允许多个用户同时修改一个表。</p>
</li>
<li><p>如果不显式的启动一个事务，单个sql会被独立于其它语句自动提交。启动事务必须先提交一个命令。</p>
</li>
<li><p>mysql服务器时默认的自动提交事务，但是可以修改。</p>
</li>
<li><p>rollback事务回滚，commit提交事务</p>
</li>
</ol>
<p>关于意外情况</p>
<ol>
<li>服务器宕机，服务器重启时事务会自动回滚；</li>
<li>提交一个SQL模式语句，比如alter table会引起当前事务提交和新事务的启动；</li>
<li>提交一个start transcation命令，将会引起一个新事务提交；</li>
<li>因为服务器检测到一个思索并且确定当前事务就是罪魁祸首，则服务器会结束当前事务，然后事务将会被回滚，同时释放错误信息。</li>
</ol>
<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><h3 id="元数据的类型"><a href="#元数据的类型" class="headerlink" title="元数据的类型"></a>元数据的类型</h3><ol>
<li>表名</li>
<li>表存储信息（表空间、初始值大小）</li>
<li>存储引擎</li>
<li>列名</li>
<li>列数据类型</li>
<li>默认值</li>
<li>非空列约束</li>
<li>主键列</li>
<li>主键名</li>
<li>主键索引名</li>
<li>索引名</li>
<li>索引类型</li>
<li>索引列</li>
<li>索引列排序顺序</li>
<li>索引存储信息</li>
<li>外键名</li>
<li>外键列</li>
<li>外键的关联表</li>
</ol>
<h3 id="视图的信息模式"><a href="#视图的信息模式" class="headerlink" title="视图的信息模式"></a>视图的信息模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.tables where table_schema&#x3D;&#39;bank&#39; order by 1;</span><br><span class="line">+---------------+--------------+-----------------+------------+--------+---------+------------+------------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-------------------+----------+----------------+---------------+</span><br><span class="line">| TABLE_CATALOG | TABLE_SCHEMA | TABLE_NAME      | TABLE_TYPE | ENGINE | VERSION | ROW_FORMAT | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH | MAX_DATA_LENGTH | INDEX_LENGTH | DATA_FREE | AUTO_INCREMENT | CREATE_TIME         | UPDATE_TIME         | CHECK_TIME | TABLE_COLLATION   | CHECKSUM | CREATE_OPTIONS | TABLE_COMMENT |</span><br><span class="line">+---------------+--------------+-----------------+------------+--------+---------+------------+------------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-------------------+----------+----------------+---------------+</span><br><span class="line">| def           | bank         | customer_viewer | VIEW       | NULL   |    NULL | NULL       |       NULL |           NULL |        NULL |            NULL |         NULL |      NULL |           NULL | NULL                | NULL                | NULL       | NULL              |     NULL | NULL           | VIEW          |</span><br><span class="line">| def           | bank         | customer        | BASE TABLE | InnoDB |      10 | Dynamic    |         11 |           1489 |       16384 |               0 |            0 |         0 |             14 | 2017-11-11 23:46:08 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | business        | BASE TABLE | InnoDB |      10 | Dynamic    |          4 |           4096 |       16384 |               0 |            0 |         0 |           NULL | 2017-11-11 23:46:08 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | transaction     | BASE TABLE | InnoDB |      10 | Dynamic    |         21 |            780 |       16384 |               0 |        49152 |         0 |             22 | 2017-11-11 23:46:10 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | branch          | BASE TABLE | InnoDB |      10 | Dynamic    |          4 |           4096 |       16384 |               0 |            0 |         0 |              5 | 2017-11-11 23:46:06 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | product_type    | BASE TABLE | InnoDB |      10 | Dynamic    |          3 |           5461 |       16384 |               0 |            0 |         0 |           NULL | 2017-11-11 23:46:07 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | account         | BASE TABLE | InnoDB |      10 | Dynamic    |         24 |            682 |       16384 |               0 |        65536 |         0 |             30 | 2017-11-11 23:46:09 | 2017-12-01 00:09:25 | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | product         | BASE TABLE | InnoDB |      10 | Dynamic    |          8 |           2048 |       16384 |               0 |        16384 |         0 |           NULL | 2017-12-03 02:17:13 | 2017-12-03 02:17:13 | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | officer         | BASE TABLE | InnoDB |      10 | Dynamic    |          4 |           4096 |       16384 |               0 |        16384 |         0 |              5 | 2017-11-11 23:46:09 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | individual      | BASE TABLE | InnoDB |      10 | Dynamic    |          9 |           1820 |       16384 |               0 |            0 |         0 |           NULL | 2017-11-11 23:46:08 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | employee_vw     | VIEW       | NULL   |    NULL | NULL       |       NULL |           NULL |        NULL |            NULL |         NULL |      NULL |           NULL | NULL                | NULL                | NULL       | NULL              |     NULL | NULL           | VIEW          |</span><br><span class="line">| def           | bank         | employee        | BASE TABLE | InnoDB |      10 | Dynamic    |         18 |            910 |       16384 |               0 |        49152 |         0 |             19 | 2017-12-03 01:19:37 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">| def           | bank         | department      | BASE TABLE | InnoDB |      10 | Dynamic    |          2 |           8192 |       16384 |               0 |            0 |         0 |              4 | 2017-12-03 01:17:04 | NULL                | NULL       | latin1_swedish_ci |     NULL |                |               |</span><br><span class="line">+---------------+--------------+-----------------+------------+--------+---------+------------+------------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+---------------------+------------+-------------------+----------+----------------+---------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="information-schema数据库表说明"><a href="#information-schema数据库表说明" class="headerlink" title="information_schema数据库表说明:"></a>information_schema数据库表说明:</h3><p>　　information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。<br>　　在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。</p>
<p><strong>SCHEMATA表</strong>：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</p>
<p><strong>TABLES表</strong>：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</p>
<p><strong>COLUMNS表</strong>：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</p>
<p><strong>STATISTICS表</strong>：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</p>
<p><strong>USER_PRIVILEGES</strong>（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</p>
<p><strong>SCHEMA_PRIVILEGES</strong>（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</p>
<p><strong>TABLE_PRIVILEGES</strong>（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</p>
<p><strong>COLUMN_PRIVILEGES</strong>（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</p>
<p><strong>CHARACTER_SETS</strong>（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</p>
<p><strong>COLLATIONS表</strong>：提供了关于各字符集的对照信息。</p>
<p><strong>COLLATION_CHARACTER_SET_APPLICABILITY</strong>表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</p>
<p><strong>TABLE_CONSTRAINTS</strong>表：描述了存在约束的表。以及表的约束类型。</p>
<p><strong>KEY_COLUMN_USAGE</strong>表：描述了具有约束的键列。</p>
<p><strong>ROUTINES</strong>表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</p>
<p><strong>VIEWS</strong>表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</p>
<p><strong>TRIGGERS</strong>表：提供了关于触发程序的信息。必须有super权限才能查看该表于触发程序的信息。必须有super权限才能查看该表</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-11-20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-11-20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-20 23:45:05" itemprop="dateCreated datePublished" datetime="2017-11-20T23:45:05+08:00">2017-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> 正则表达式是个极端强大工具，而且在字符串模式-匹配和字符串模式-替换方面富有弹性，<br>在Sun的Java JDK 1.40版本中，Java自带了支持正则表达式的包。</p>
<p>在java的regex包中，包括了两个类，Pattern(模式类)和Matcher(匹配器类)。Pattern类是用来表达和陈述所要搜索模式的对象，Matcher类是真正影响搜索的对象。</p>
<h3 id="正则表达式的基础知识"><a href="#正则表达式的基础知识" class="headerlink" title="正则表达式的基础知识"></a>正则表达式的基础知识</h3><ul>
<li>句点符号</li>
</ul>
<p>假设你在玩英文拼字游戏，想要找出三个字母的单词，而且这些单词必须以“t”字母开头，以“n”字母结束。另外，假设有一本英文字典，你可以用正则表达式搜索它的全部内容。要构造出这个正则表达式，你可以使用一个通配符——句点符号“.”。这样，完整的表达式就是<strong>t.n</strong>，它匹配“tan”、“ten”、“tin”和“ton”，还匹配“t#n”、“tpn”甚至“t n”，还有其他许多无意义的组合</p>
<ul>
<li>方括号符号</li>
</ul>
<p>为了解决句点符号匹配范围过于广泛这一问题，你可以在方括号（“[]”）里面指定看来有意义的字符。此时，只有方括号里面指定的字符才参与匹配。也就是说，正则表达式“t[aeio]n”只匹配“tan”、“Ten”、“tin”和“ton”。但“Toon”不匹配，因为在方括号之内你只能匹配单个字符</p>
<ul>
<li>“或”符号</li>
</ul>
<p>如果除了上面匹配的所有单词之外，你还想要匹配“toon”，那么，你可以使用“|”操作符。“|”操作符的基本意义就是“或”运算。要匹配“toon”，使用“t(a|e|i|o|oo)n”正则表达式。这里不能使用方扩号，因为方括号只允许匹配单个字符；这里必须使用圆括号“()”。圆括号还可以用来分组</p>
<ul>
<li>表示匹配次数的符号</li>
</ul>
<p><img src="/images/regex/%E8%A1%A8%E7%A4%BA%E6%AC%A1%E6%95%B0%E7%9A%84%E7%AC%A6%E5%8F%B7.jpg"></p>
<p>假设我们要在文本文件中搜索美国的社会安全号码。这个号码的格式是999-99-9999。用来匹配它的正则表达式如图一所示。在正则表达式中，连字符（“-”）有着特殊的意义，它表示一个范围，比如从0到9。因此，匹配社会安全号码中的连字符号时，它的前面要加上一个转义字符“\”。</p>
<p><img src="/images/regex/img1.gif"></p>
<p>假设进行搜索的时候，你希望连字符号可以出现，也可以不出现——即，999-99-9999和999999999都属于正确的格式。这时，你可以在连字符号后面加上“？”数量限定符号，如图二所示：</p>
<p><img src="/images/regex/img2.gif"></p>
<ul>
<li>“否”符号</li>
</ul>
<p>“^”符号称为“否”符号。如果用在方括号内，“^”表示不想要匹配的字符。例如，图四的正则表达式匹配所有单词，但以“X”字母开头的单词除外。</p>
<p><img src="/images/regex/img3.gif"></p>
<ul>
<li>圆括号和空白符号</li>
</ul>
<p>假设要从格式为“June 26, 1951”的生日日期中提取出月份部分，用来匹配该日期的正则表达式可以如图五所示：</p>
<p><img src="/images/regex/img4.gif"></p>
<p>新出现的“\s”符号是空白符号，匹配所有的空白字符，包括Tab字符。如果字符串正确匹配，接下来如何提取出月份部分呢？只需在月份周围加上一个圆括号创建一个组，然后用ORO API（本文后面详细讨论）提取出它的值。修改后的正则表达式如图六所示：</p>
<p><img src="/images/regex/img5.gif"></p>
<ul>
<li>为简便起见，你可以使用一些为常见正则表达式创建的快捷符号</li>
</ul>
<p><img src="/images/regex/%E5%85%B6%E5%AE%83%E7%AC%A6%E5%8F%B7%E8%A1%A8.jpg"></p>
<h3 id="java正则表达式的方法简介"><a href="#java正则表达式的方法简介" class="headerlink" title="java正则表达式的方法简介"></a>java正则表达式的方法简介</h3><h4 id="Pattern：一个Pattern是一个正则表达式经编译后的表现模式。"><a href="#Pattern：一个Pattern是一个正则表达式经编译后的表现模式。" class="headerlink" title="Pattern：一个Pattern是一个正则表达式经编译后的表现模式。"></a>Pattern：一个Pattern是一个正则表达式经编译后的表现模式。</h4><p><img src="/images/regex/pattern%E7%B1%BB%E6%96%B9%E6%B3%95.jpg"></p>
<h4 id="Matcher：一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。"><a href="#Matcher：一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。" class="headerlink" title="Matcher：一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。"></a>Matcher：一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。</h4><p><img src="/images/regex/matcher%E7%B1%BB%E6%96%B9%E6%B3%95.jpg"></p>
<h3 id="方法讲解"><a href="#方法讲解" class="headerlink" title="方法讲解"></a>方法讲解</h3><h4 id="Pattern对象"><a href="#Pattern对象" class="headerlink" title="Pattern对象"></a>Pattern对象</h4><p>表示经编译的正则表达式。</p>
<ol>
<li><p>静态的compile( )方法负责将表示正则表达式的字符串编译成Pattern对象。正如上述例程所示的，只要给Pattern的matcher( )方法送一个字符串就能获取一个Matcher对象。接下来就能用Matcher的方法来查询匹配的结果了。</p>
</li>
<li><p>Pattern还有一个能快速判断能否在input里面找到regex的</p>
</li>
<li><p>能返回String数组的split( )方法，它能用regex把字符串分割开来。</p>
</li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Pattern p &#x3D; Pattern.compile(&quot;\\d+&quot;);</span><br><span class="line"> Matcher matcher &#x3D; p.matcher(&quot;56&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Boolean flag &#x3D; Pattern.matches(&quot;\\d+&quot;, &quot;test string  34 5&quot;);</span><br><span class="line"></span><br><span class="line">String stringSpit &#x3D;&quot;this is a String!&quot;;</span><br><span class="line">String[] arr2 &#x3D; stringSpit.split(&quot;\\n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Matcher对象"><a href="#Matcher对象" class="headerlink" title="Matcher对象"></a>Matcher对象</h4><p>Matcher对象可以通过pattern.matcher(“test”) 传入字符串获得，之后就可以通过matcher对象的方法来查询匹配结果了。</p>
<ol>
<li>boolean matches()  </li>
</ol>
<p>matches( )的前提是Pattern匹配整个字符串</p>
<ol start="2">
<li>boolean lookingAt()</li>
</ol>
<p>lookingAt( )的意思是Pattern匹配字符串的开头。</p>
<ol start="3">
<li>boolean find()</li>
</ol>
<p>find( )的功能是发现CharSequence（传入字符串的）里的，与pattern相匹配的多个字符序列</p>
<ol start="4">
<li>boolean find(int start)</li>
</ol>
<p>它会告诉方法从哪里开始找——即从参数位置开始查找。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line"></span><br><span class="line">    Pattern pattern &#x3D; Pattern.compile(&quot;\\w+&quot;);</span><br><span class="line"></span><br><span class="line">    Matcher matcher &#x3D; pattern.matcher(&quot;Evening is full of the linnet&#39;s wings&quot;);</span><br><span class="line"></span><br><span class="line">    while (matcher.find()) &#123;</span><br><span class="line">        System.out.println(&quot;match find:&quot; + matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while (matcher.find(i)) &#123;</span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h4><p>Group是指里用括号括起来的，能被后面的表达式调用的正则表达式。Group 0 表示整个表达式，group 1表示第一个被括起来的group，以此类推。所以；<br>A(B( C ))D 里面有三个group：group 0是ABCD， group 1是BC，group 2是C。</p>
<p> 下述Matcher方法来使用group：</p>
<ul>
<li>int groupCount( )返回matcher对象中的group的数目。不包括group0。</li>
<li>String group( ) 返回上次匹配操作(比方说find( ))的group 0(整个匹配)</li>
<li>String group(int i)返回上次匹配操作的某个group。如果匹配成功，但是没能找到group，则返回null。</li>
<li>int start(int group)返回上次匹配所找到的，group的开始位置。</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">  public void test3() &#123;</span><br><span class="line"></span><br><span class="line">      String poem &#x3D;</span><br><span class="line">              &quot;Twas brillig, and the slithy toves&#x2F;n&quot; +</span><br><span class="line">                      &quot;Did gyre and gimble in the wabe.&#x2F;n&quot; +</span><br><span class="line">                      &quot;All mimsy were the borogoves,&#x2F;n&quot; +</span><br><span class="line">                      &quot;And the mome raths outgrabe.&#x2F;n&#x2F;n&quot; +</span><br><span class="line">                      &quot;Beware the Jabberwock, my son,&#x2F;n&quot; +</span><br><span class="line">                      &quot;The jaws that bite, the claws that catch.&#x2F;n&quot; +</span><br><span class="line">                      &quot;Beware the Jubjub bird, and shun&#x2F;n&quot; +</span><br><span class="line">                      &quot;The frumious Bandersnatch.&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;换行模式 (?m)</span><br><span class="line">      Pattern pattern &#x3D; Pattern.compile(&quot;(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))&quot;);</span><br><span class="line"></span><br><span class="line">      Matcher matcher &#x3D; pattern.matcher(poem);</span><br><span class="line"></span><br><span class="line">      while (matcher.find()) &#123;</span><br><span class="line">          for (int i &#x3D; 0; i &lt;&#x3D; matcher.groupCount(); i++) &#123;</span><br><span class="line">              System.out.println(matcher.group(i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="start-和end"><a href="#start-和end" class="headerlink" title="start( )和end( )"></a>start( )和end( )</h4><p>如果匹配成功，start( )会返回此次匹配的开始位置，end( )会返回此次匹配的结束位置，即最后一个字符的下标加一。如果之前的匹配不成功(或者没匹配)，那么无论是调用start( )还是end( )，都会引发一个IllegalStateException。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test4() &#123;</span><br><span class="line">        String[] input &#x3D; new String[]&#123;</span><br><span class="line">                &quot;Java has regular expressions in 1.4&quot;,</span><br><span class="line">                &quot;regular expressions now expressing in Java&quot;,</span><br><span class="line">                &quot;Java represses oracular expressions&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        Pattern p1 &#x3D; Pattern.compile(&quot;re\\w*&quot;),</span><br><span class="line">                p2 &#x3D; Pattern.compile(&quot;Java.*&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; input.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;input &quot; + i + &quot;: &quot; + input[i]);</span><br><span class="line">            Matcher</span><br><span class="line">                    m1 &#x3D; p1.matcher(input[i]),</span><br><span class="line">                    m2 &#x3D; p2.matcher(input[i]);</span><br><span class="line">            while (m1.find()) &#123;</span><br><span class="line">                System.out.println(&quot;m1.find() &#39;&quot; + m1.group() +</span><br><span class="line">                        &quot;&#39; start &#x3D; &quot; + m1.start() + &quot; end &#x3D; &quot; + m1.end());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (m2.find()) &#123;</span><br><span class="line">                System.out.println(&quot;m2.find() &#39;&quot; + m2.group() +</span><br><span class="line">                        &quot;&#39; start &#x3D; &quot; + m2.start() + &quot; end &#x3D; &quot; + m2.end());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; No reset() necessary</span><br><span class="line">            if (m1.lookingAt()) &#123;</span><br><span class="line">                System.out.println(&quot;m1.lookingAt() start &#x3D; &quot;</span><br><span class="line">                        + m1.start() + &quot; end &#x3D; &quot; + m1.end());</span><br><span class="line">            &#125;</span><br><span class="line">            if (m2.lookingAt()) &#123;</span><br><span class="line">                System.out.println(&quot;m2.lookingAt() start &#x3D; &quot;</span><br><span class="line">                        + m2.start() + &quot; end &#x3D; &quot; + m2.end());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; No reset() necessary</span><br><span class="line">            if (m1.matches()) &#123;</span><br><span class="line">                System.out.println(&quot;m1.matches() start &#x3D; &quot;</span><br><span class="line">                        + m1.start() + &quot; end &#x3D; &quot; + m1.end());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (m2.matches()) &#123;</span><br><span class="line">                System.out.println(&quot;m2.matches() start &#x3D; &quot;</span><br><span class="line">                        + m2.start() + &quot; end &#x3D; &quot; + m2.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split( )"></a>split( )</h4><p>所谓分割是指将以正则表达式为界，将字符串分割成String数组。</p>
<ul>
<li><p>String[] split(CharSequence charseq)</p>
</li>
<li><p>String[] split(CharSequence charseq, int limit)</p>
</li>
</ul>
<p>第二个split( )会限定分割的次数,正则表达式是如此重要，以至于有些功能被加进了String类，其中包括split( )(已经看到了)，matches( )，replaceFirst( )以及replaceAll( )。这些方法的功能同Pattern和Matcher的相同。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test5() &#123;</span><br><span class="line">    String input &#x3D; &quot;This!!unusual use!!of exclamation!!points&quot;;</span><br><span class="line">    System.out.println(Arrays.asList(Pattern.compile(&quot;!!&quot;).split(input)));</span><br><span class="line">    &#x2F;&#x2F; Only do the first three:</span><br><span class="line">    System.out.println(Arrays.asList(Pattern.compile(&quot;!!&quot;).split(input, 3)));</span><br><span class="line">    System.out.println(Arrays.asList(&quot;Aha! String has a split() built in!&quot;.split(&quot; &quot;)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><ul>
<li>replaceFirst(String replacement)将字符串里，第一个与模式相匹配的子串替换成replacement。</li>
<li>replaceAll(String replacement)，将输入字符串里所有与模式相匹配的子串全部替换成replacement。</li>
<li>appendReplacement(StringBuffer sbuf, String replacement)对sbuf进行逐次替换，而不是像replaceFirst( )或replaceAll( )那样，只替换第一个或全部子串。这是个非常重要的方法，因为它可以调用方法来生成replacement(replaceFirst( )和replaceAll( )只允许用固定的字符串来充当replacement)。有了这个方法，你就可以编程区分group，从而实现更强大的替换功能。<br>调用完appendReplacement( )之后，为了把剩余的字符串拷贝回去，必须调用appendTail(StringBuffer sbuf)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">   public void test6() &#123;</span><br><span class="line"></span><br><span class="line">       String s &#x3D; &quot;! Here&#39;s a block of text to use as input to\n&quot; +</span><br><span class="line">               &quot;  the regular expression matcher. Note that we&#39;ll\n&quot; +</span><br><span class="line">               &quot;  first extract the block of text by looking for\n&quot; +</span><br><span class="line">               &quot;  the special delimiters, then process the\n&quot; +</span><br><span class="line">               &quot;  extracted block. !&quot;;</span><br><span class="line">       Matcher mInput &#x3D; Pattern.compile(&quot;&#x2F;*!(.*)!*&#x2F;&quot;, Pattern.DOTALL).matcher(s);</span><br><span class="line">       &#x2F;&#x2F; Captured by parentheses</span><br><span class="line">       if (mInput.find())&#123;</span><br><span class="line">           s &#x3D; mInput.group(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Replace two or more spaces with a single space:</span><br><span class="line">       s &#x3D; s.replaceAll(&quot; &#123;2,&#125;&quot;, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Replace one or more spaces at the beginning of each</span><br><span class="line">       &#x2F;&#x2F; line with no spaces. Must enable MULTILINE mode:</span><br><span class="line">       s &#x3D; s.replaceAll(&quot;(?m)^ +&quot;, &quot;&quot;);</span><br><span class="line">       System.out.println(s);</span><br><span class="line">       s &#x3D; s.replaceFirst(&quot;[aeiou]&quot;, &quot;(VOWEL1)&quot;);</span><br><span class="line">       StringBuffer sbuf &#x3D; new StringBuffer();</span><br><span class="line">       Pattern p &#x3D; Pattern.compile(&quot;[aeiou]&quot;);</span><br><span class="line">       Matcher m &#x3D; p.matcher(s);</span><br><span class="line">       &#x2F;&#x2F; Process the find information as you</span><br><span class="line">       &#x2F;&#x2F; perform the replacements:</span><br><span class="line">       while (m.find())</span><br><span class="line">           m.appendReplacement(sbuf, m.group().toUpperCase());</span><br><span class="line">       &#x2F;&#x2F; Put in the remainder of the text:</span><br><span class="line">       m.appendTail(sbuf);</span><br><span class="line">       System.out.println(sbuf);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mInput的功能是匹配’/<em>!’ 和 ‘!</em>/‘ 之间的文本(注意一下分组用的括号)。接下来，我们将所有两个以上的连续空格全都替换成一个，并且将各行开头的空格全都去掉(为了让这个正则表达式能对所有的行，而不仅仅是第一行起作用，必须启用多行模式)。这两个操作都用了String的replaceAll( )(这里用它更方便)。注意，由于每个替换只做一次，因此除了预编译Pattern之外，程序没有额外的开销。</p>
<p>replaceFirst( )只替换第一个子串。此外，replaceFirst( )和replaceAll( )只能用常量(literal)来替换，所以如果每次替换的时候还要进行一些操作的话，它们是无能为力的。碰到这种情况，得用appendReplacement( )，它能在进行替换的时候想写多少代码就写多少。在上面那段程序里，创建sbuf的过程就是选group做处理，也就是用正则表达式把元音字母找出来，然后换成大写的过程。通常你得在完成全部的替换之后才调用appendTail( )，但是如果要模仿replaceFirst( )(或”replace n”)的效果，你也可以只替换一次就调用appendTail( )。它会把剩下的东西全都放进sbuf。</p>
<p>你还可以在appendReplacement( )的replacement参数里用”$g”引用已捕获的group，其中’g’ 表示group的号码。不过这是为一些比较简单的操作准备的，因而其效果无法与上述程序相比。</p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset( )"></a>reset( )</h4><p>可以用reset( )方法给现有的Matcher对象配上个新的CharSequence。<br>如果不给参数，reset( )会把Matcher设到当前字符串的开始处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">   public void test7() &#123;</span><br><span class="line">       Matcher m &#x3D; Pattern.compile(&quot;[frb][aiu][gx]&quot;)</span><br><span class="line">               .matcher(&quot;fix the rug with bags&quot;);</span><br><span class="line"></span><br><span class="line">       while (m.find()) &#123;</span><br><span class="line">           System.out.println(m.group());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       m.reset(&quot;fix the rig with rags&quot;);</span><br><span class="line"></span><br><span class="line">       while (m.find()) &#123;</span><br><span class="line">           System.out.println(m.group());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="回溯模式-上面有例子"><a href="#回溯模式-上面有例子" class="headerlink" title="回溯模式 (上面有例子)"></a>回溯模式 (上面有例子)</h4><p>‘\1’回溯上一个匹配的结果</p>
<p>Pattern pattern =Pattern.compile(“\b(\w+)\s+\1\b”,</p>
<h4 id="模式标志-上面有例子"><a href="#模式标志-上面有例子" class="headerlink" title="模式标志(上面有例子)"></a>模式标志(上面有例子)</h4><p>‘$’表示一行的结尾。但是’$’通常表示整个字符串的结尾，所以这里要明确地告诉正则表达式注意换行符。这一点是由’(?m)’标志完成的</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/allwefantasy/article/details/3136570/">参考资料：JAVA正则表达的必读篇</a></p>
<p><a target="_blank" rel="noopener" href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html">参考资料：正则表达式手册</a></p>
<p><a target="_blank" rel="noopener" href="http://tool.oschina.net/regex/">在线正则表达式测试工具</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenwj.cn/2017-11-10/SQL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%20%E6%9F%A5%E8%AF%A2%E5%85%A5%E9%97%A8%20%E8%BF%87%E6%BB%A4%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="陈伟杰">
      <meta itemprop="description" content="学习，坚持。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茄子的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-11-10/SQL%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%20%E6%9F%A5%E8%AF%A2%E5%85%A5%E9%97%A8%20%E8%BF%87%E6%BB%A4%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">《SQL基础》SQL学习指南学习笔记二 查询入门 过滤 多表查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-10 23:22:30" itemprop="dateCreated datePublished" datetime="2017-11-10T23:22:30+08:00">2017-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-21 01:03:09" itemprop="dateModified" datetime="2020-08-21T01:03:09+08:00">2020-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sql/" itemprop="url" rel="index"><span itemprop="name">sql</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查询机制"><a href="#查询机制" class="headerlink" title="查询机制"></a>查询机制</h2><p>当使用如下命令连接上数据库后，会提示你的connecttion id 是多少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zhuningning@ubuntu:~$ mysql -u lrngsql -p </span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.20 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在执行你的语句之前，要进行以下验证</p>
<ul>
<li>用户是否有权限执行以下语句；</li>
<li>用户是否有权限访问目标数据；</li>
<li>语句的语法是否正确；</li>
</ul>
<p>通过了以上测试，语句会传递给查询优化器（负责查询到最有效率的执行方式），之后执行查询。</p>
<h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>查询语句由以下子句组成</p>
<ul>
<li>select： 确定结果集中应该包含哪些列。</li>
<li>from：指明所要提取数据的表，以及这些表时如何连接的。</li>
<li>where：过滤不需要的表。</li>
<li>group by ：用于对具有相同列值的行进行分组。</li>
<li>having：过滤不需要的组。</li>
<li>order by：按一个或者多个列，对最后的结果集中的行进行排序。</li>
</ul>
<h3 id="select子句"><a href="#select子句" class="headerlink" title="select子句"></a>select子句</h3><p>该子句用于在所有的可能的列中，选择查询结果集包包含哪些列。<br>在该子句中可以包括字符串、表达式、内建函数等。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select emp_id,&#39;active&#39;,emp_id*3.14159,upper(lname) from employee;</span><br><span class="line">+--------+--------+----------------+--------------+</span><br><span class="line">| emp_id | active | emp_id*3.14159 | upper(lname) |</span><br><span class="line">+--------+--------+----------------+--------------+</span><br><span class="line">|      1 | active |        3.14159 | SMITH        |</span><br><span class="line">|      2 | active |        6.28318 | BARKER       |</span><br><span class="line">|      3 | active |        9.42477 | TYLER        |</span><br><span class="line">|      4 | active |       12.56636 | HAWTHORNE    |</span><br><span class="line">|      5 | active |       15.70795 | GOODING      |</span><br><span class="line">|      6 | active |       18.84954 | FLEMING      |</span><br><span class="line">|      7 | active |       21.99113 | TUCKER       |</span><br><span class="line">|      8 | active |       25.13272 | PARKER       |</span><br><span class="line">|      9 | active |       28.27431 | GROSSMAN     |</span><br><span class="line">|     10 | active |       31.41590 | ROBERTS      |</span><br><span class="line">|     11 | active |       34.55749 | ZIEGLER      |</span><br><span class="line">|     12 | active |       37.69908 | JAMESON      |</span><br><span class="line">|     13 | active |       40.84067 | BLAKE        |</span><br><span class="line">|     14 | active |       43.98226 | MASON        |</span><br><span class="line">|     15 | active |       47.12385 | PORTMAN      |</span><br><span class="line">|     16 | active |       50.26544 | MARKHAM      |</span><br><span class="line">|     17 | active |       53.40703 | FOWLER       |</span><br><span class="line">|     18 | active |       56.54862 | TULMAN       |</span><br><span class="line">+--------+--------+----------------+--------------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只是执行内置函数，就不需要加后面的子句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version(),user(),database();</span><br><span class="line">+-----------+----------+------------+</span><br><span class="line">| version() | user()   | database() |</span><br><span class="line">+-----------+----------+------------+</span><br><span class="line">| 5.7.20    | lrngsql@ | bank       |</span><br><span class="line">+-----------+----------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h4><ul>
<li>列的别名,可以在查询的字段后使用 as 或者直接在列后添加别名。为了增加可读性，建议添加as关键字。</li>
</ul>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select emp_id,&#39;active&#39; as active,emp_id*3.14159 as empid_x_pi,upper(lname) as last_name_upper from employee;</span><br><span class="line">+--------+--------+------------+-----------------+</span><br><span class="line">| emp_id | active | empid_x_pi | last_name_upper |</span><br><span class="line">+--------+--------+------------+-----------------+</span><br><span class="line">|      1 | active |    3.14159 | SMITH           |</span><br><span class="line">|      2 | active |    6.28318 | BARKER          |</span><br><span class="line">|      3 | active |    9.42477 | TYLER           |</span><br><span class="line">|      4 | active |   12.56636 | HAWTHORNE       |</span><br><span class="line">|      5 | active |   15.70795 | GOODING         |</span><br><span class="line">|      6 | active |   18.84954 | FLEMING         |</span><br><span class="line">|      7 | active |   21.99113 | TUCKER          |</span><br><span class="line">|      8 | active |   25.13272 | PARKER          |</span><br><span class="line">|      9 | active |   28.27431 | GROSSMAN        |</span><br><span class="line">|     10 | active |   31.41590 | ROBERTS         |</span><br><span class="line">|     11 | active |   34.55749 | ZIEGLER         |</span><br><span class="line">|     12 | active |   37.69908 | JAMESON         |</span><br><span class="line">|     13 | active |   40.84067 | BLAKE           |</span><br><span class="line">|     14 | active |   43.98226 | MASON           |</span><br><span class="line">|     15 | active |   47.12385 | PORTMAN         |</span><br><span class="line">|     16 | active |   50.26544 | MARKHAM         |</span><br><span class="line">|     17 | active |   53.40703 | FOWLER          |</span><br><span class="line">|     18 | active |   56.54862 | TULMAN          |</span><br><span class="line">+--------+--------+------------+-----------------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h4><p>去除重复行，可以使用distinct关键字。注意 ** 产生无重复结果集需要首先对数据进行排序 ,这对于大的结果是相当耗时的。因此当有需求时再使用DISTINCT关键字，否则没必要。 **</p>
<h3 id="from-子句"><a href="#from-子句" class="headerlink" title="from 子句"></a>from 子句</h3><p>from子句定义了查询中所使用的表，以及连接这些表的方式。</p>
<p>表的概念:</p>
<ul>
<li>永久表（create table语句创建的表）;</li>
</ul>
<p>从表中查询数据时，可以在表名后加 as 别名 为表添加一个实例的别名。</p>
<ul>
<li>临时表（子查询所返回的表）；</li>
</ul>
<p>子查询可以出现在select语句中的各个部分，并且别包含在圆括号中。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select e.emp_id,e.fname,e.lname from (select emp_id,fname,lname,start_date,title from employee) e;</span><br><span class="line">+--------+----------+-----------+</span><br><span class="line">| emp_id | fname    | lname     |</span><br><span class="line">+--------+----------+-----------+</span><br><span class="line">|      1 | Michael  | Smith     |</span><br><span class="line">|      2 | Susan    | Barker    |</span><br><span class="line">|      3 | Robert   | Tyler     |</span><br><span class="line">|      4 | Susan    | Hawthorne |</span><br><span class="line">|      5 | John     | Gooding   |</span><br><span class="line">|      6 | Helen    | Fleming   |</span><br><span class="line">|      7 | Chris    | Tucker    |</span><br><span class="line">|      8 | Sarah    | Parker    |</span><br><span class="line">|      9 | Jane     | Grossman  |</span><br><span class="line">|     10 | Paula    | Roberts   |</span><br><span class="line">|     11 | Thomas   | Ziegler   |</span><br><span class="line">|     12 | Samantha | Jameson   |</span><br><span class="line">|     13 | John     | Blake     |</span><br><span class="line">|     14 | Cindy    | Mason     |</span><br><span class="line">|     15 | Frank    | Portman   |</span><br><span class="line">|     16 | Theresa  | Markham   |</span><br><span class="line">|     17 | Beth     | Fowler    |</span><br><span class="line">|     18 | Rick     | Tulman    |</span><br><span class="line">+--------+----------+-----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个不是使用的例子，但可以表示临时表的用处。</p>
<ul>
<li>虚拟表 （使用create view子句所创建的视图）</li>
</ul>
<p>视图时存储在数据字典中的查询。它的行为表现的像一个表，但实际上并不是一个表。当查询视图时，该查询会被绑定到视图定义上。</p>
<p>视图的作用：</p>
<ul>
<li>用户隐藏列，简化数据库设计。</li>
</ul>
<p>如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建视图</span><br><span class="line">mysql&gt; create view employee_vw  as select emp_id,fname,lname,year(start_date) start_year from employee;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查询视图</span><br><span class="line">mysql&gt; SELECT * from employee_vw;</span><br><span class="line">+--------+----------+-----------+------------+</span><br><span class="line">| emp_id | fname    | lname     | start_year |</span><br><span class="line">+--------+----------+-----------+------------+</span><br><span class="line">|      1 | Michael  | Smith     |       2001 |</span><br><span class="line">|      2 | Susan    | Barker    |       2002 |</span><br><span class="line">|      3 | Robert   | Tyler     |       2000 |</span><br><span class="line">|      4 | Susan    | Hawthorne |       2002 |</span><br><span class="line">|      5 | John     | Gooding   |       2003 |</span><br><span class="line">|      6 | Helen    | Fleming   |       2004 |</span><br><span class="line">|      7 | Chris    | Tucker    |       2004 |</span><br><span class="line">|      8 | Sarah    | Parker    |       2002 |</span><br><span class="line">|      9 | Jane     | Grossman  |       2002 |</span><br><span class="line">|     10 | Paula    | Roberts   |       2002 |</span><br><span class="line">|     11 | Thomas   | Ziegler   |       2000 |</span><br><span class="line">|     12 | Samantha | Jameson   |       2003 |</span><br><span class="line">|     13 | John     | Blake     |       2000 |</span><br><span class="line">|     14 | Cindy    | Mason     |       2002 |</span><br><span class="line">|     15 | Frank    | Portman   |       2003 |</span><br><span class="line">|     16 | Theresa  | Markham   |       2001 |</span><br><span class="line">|     17 | Beth     | Fowler    |       2002 |</span><br><span class="line">|     18 | Rick     | Tulman    |       2002 |</span><br><span class="line">+--------+----------+-----------+------------+</span><br><span class="line">18 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h3><p>在结果集中过滤掉不需要的行。</p>
<p>当where子句中有多个条件时，可以使用AND或者OR进行连接。当混合使用不同的操作符时，开发者应当使用圆括号来分割成组的条件。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select emp_id,fname,lname,start_date,title from employee where (title &#x3D;&#39;Head Teller&#39; AND start_date &gt;&#39;2003-01-01&#39;)  or (title&#x3D;&#39;Teller&#39; AND start_date &gt;&#39;2004-01-01&#39;);</span><br><span class="line">+--------+-------+---------+------------+-------------+</span><br><span class="line">| emp_id | fname | lname   | start_date | title       |</span><br><span class="line">+--------+-------+---------+------------+-------------+</span><br><span class="line">|      6 | Helen | Fleming | 2004-03-17 | Head Teller |</span><br><span class="line">|      7 | Chris | Tucker  | 2004-09-15 | Teller      |</span><br><span class="line">+--------+-------+---------+------------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="group-by子句和having子句"><a href="#group-by子句和having子句" class="headerlink" title="group by子句和having子句"></a>group by子句和having子句</h3><p>此例子是表示在服务器返回结果集之前对数据再一次进行提炼。</p>
<p>**where group by  和having的区别 ** </p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/Shine_rise/article/details/54934242">参考</a>  该文章中最后两行是错误的，详细看下文中的执行顺序。</p>
<p>where：数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p>
<p>group by：对select查询出来的结果集按照某个字段或者表达式进行分组（这里不能说明select语句时在group by中执行，<br>意思时说group by的字段必须在select的字段中存在。），获得一组组的集合，然后从每组中取出一个指定字段或者<br>表达式的值。 </p>
<p>在说group by的时候，我们还需要了解聚合函数，聚合函数是SQL语言中一种特殊的函数。例如：</p>
<ul>
<li>count(*)：获取数量</li>
<li>sum()：求和(这里要注意求和是忽略null值的，null与其他数值相加结果为null，所以可以通过ifnull(xxx,0)将null的值赋为0）</li>
<li>avg()：求平均数</li>
<li>max()：求最大值</li>
<li>min()：求最小值</li>
</ul>
<p>这些函数和其它函数的根本区别就是它们一般作用在多条记录上。<br>我们需要注意的是：在使用group by的SQL语句中，select中返回的字段，必须满足以下两个条件之一：(不太确定，欢迎讨论)</p>
<ul>
<li>包含在group by语句的后面，作为分组的依据；</li>
<li>这些字段包含在聚合函数中。</li>
</ul>
<p>having：用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。 </p>
<p><strong>所以having的使用需要注意以下几点：</strong></p>
<ul>
<li>having只能用于group by（分组统计语句中）分组包括显示分组group by 和隐式分组 如name =’张三’；</li>
<li>where 是用于在初始表中筛选查询，having用于在where和group by 结果分组中查询</li>
<li>having 子句中的每一个元素也必须出现在select列表中</li>
<li>having语句可以使用聚合函数，而where不使用。</li>
<li>where子句中不能使用聚合函数</li>
<li>当在包含group by子句的查询中增加过滤条件时，需要考虑过滤是针对原始数据（应该放在where子句中），还是针对分组后的数据（放到having子句中）</li>
</ul>
<p>回到开头的那个问题：当一个语句中同时含有where、group by 、having及聚集函数时，执行顺序如下：</p>
<p>执行where子句查找符合条件的数据；<br>使用group by 子句对数据进行分组；对group by 子句形成的组运行聚集函数计算每一组的值；<br>最后用having 子句去掉不符合条件的组，having处理的是分组数据，而不是原始数据。</p>
<p>需要注意的是:</p>
<ul>
<li>having 子句中的每一个元素也必须出现在select列表中。有些数据库例外，如oracle.</li>
<li>having子句和where子句都可以用来设定限制条件以使查询结果满足一定的条件限制。</li>
<li>having子句限制的是组，而不是行。where子句中不能使用聚集函数，而having子句中可以。</li>
</ul>
<p>在group by子句中使用with rollup修改后的查询</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select product_cd,open_branch_id,sum(avail_balance) tot_balance</span><br><span class="line">    -&gt; from account group by product_cd,open_branch_id with rollup;</span><br><span class="line">+------------+----------------+-------------+</span><br><span class="line">| product_cd | open_branch_id | tot_balance |</span><br><span class="line">+------------+----------------+-------------+</span><br><span class="line">| BUS        |              2 |     9345.55 |</span><br><span class="line">| BUS        |              4 |        0.00 |</span><br><span class="line">| BUS        |           NULL |     9345.55 |</span><br><span class="line">| CD         |              1 |    11500.00 |</span><br><span class="line">| CD         |              2 |     8000.00 |</span><br><span class="line">| CD         |           NULL |    19500.00 |</span><br><span class="line">| CHK        |              1 |      782.16 |</span><br><span class="line">| CHK        |              2 |     3315.77 |</span><br><span class="line">| CHK        |              3 |     1057.75 |</span><br><span class="line">| CHK        |              4 |    67852.33 |</span><br><span class="line">| CHK        |           NULL |    73008.01 |</span><br><span class="line">| MM         |              1 |    14832.64 |</span><br><span class="line">| MM         |              3 |     2212.50 |</span><br><span class="line">| MM         |           NULL |    17045.14 |</span><br><span class="line">| SAV        |              1 |      767.77 |</span><br><span class="line">| SAV        |              2 |      700.00 |</span><br><span class="line">| SAV        |              4 |      387.99 |</span><br><span class="line">| SAV        |           NULL |     1855.76 |</span><br><span class="line">| SBL        |              3 |    50000.00 |</span><br><span class="line">| SBL        |           NULL |    50000.00 |</span><br><span class="line">| NULL       |           NULL |   170754.46 |</span><br><span class="line">+------------+----------------+-------------+</span><br><span class="line">21 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应着open_branch_id 为null的行即为对所有product_cd相同的行的合计。</p>
<p>**多个子句的执行顺序 **</p>
<p>SQL查询处理的步骤序号：</p>
<ol>
<li>FROM <left_table>  </li>
<li><join_type> JOIN <right_table> </li>
<li>ON <join_condition> </li>
<li>WHERE <where_condition> </li>
<li>GROUP BY <group_by_list>  （这个过程需要排序）</li>
<li>聚合函数 {CUBE | ROLLUP} </li>
<li>HAVING <having_condition> </li>
<li>SELECT  </li>
<li>DISTINCT   （这个过程需要排序）</li>
<li>ORDER BY <order_by_list></li>
<li>limit  <select_list></li>
</ol>
<p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在查询中指定某一个子句，将跳过相应的步骤。</p>
<p>逻辑查询处理阶段简介：</p>
<ol>
<li>FROM：对FROM子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表VT1。</li>
<li>ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。</li>
<li>OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。</li>
<li>WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。</li>
<li>GROUP BY：按GROUP BY子句中的列列表对TV4中的行进行分组，生成TV5。</li>
<li>聚合函数：把超组插入VT5，生成VT6。</li>
<li>HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。</li>
<li>SELECT：处理SELECT列表，产生VT8。</li>
<li>DISTINCT：将重复的行从VT8中删除，产品VT9。</li>
<li>ORDER BY：将VT9中的行按ORDER BY子句中的列列表顺序，生成一个游标(VC10)。</li>
<li>limit：从VC10的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。</li>
</ol>
<h3 id="order子句"><a href="#order子句" class="headerlink" title="order子句"></a>order子句</h3><p>用于对结果集中的原始列数据或者根据列数据计算的表达式结果进行排序。</p>
<p>默认的 order by 字段A，对字段A进行升序排列（ASC），如果需要对数据将序排列，需要在字段后加DESC关键字。</p>
<p>如下例子：需要首先根据open_emp_id升序排列，然后根据product_cd进行降序排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT open_emp_id,product_cd FROM account ORDER BY open_emp_id,product_cd DESC;</span><br><span class="line">+-------------+------------+</span><br><span class="line">| open_emp_id | product_cd |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|           1 | SAV        |</span><br><span class="line">|           1 | MM         |</span><br><span class="line">|           1 | MM         |</span><br><span class="line">|           1 | CHK        |</span><br><span class="line">|           1 | CHK        |</span><br><span class="line">|           1 | CHK        |</span><br><span class="line">|           1 | CD         |</span><br><span class="line">|           1 | CD         |</span><br><span class="line">|          10 | SAV        |</span><br><span class="line">|          10 | SAV        |</span><br><span class="line">|          10 | CHK        |</span><br><span class="line">|          10 | CHK        |</span><br><span class="line">|          10 | CD         |</span><br><span class="line">|          10 | CD         |</span><br><span class="line">|          10 | BUS        |</span><br><span class="line">|          13 | SBL        |</span><br><span class="line">|          13 | MM         |</span><br><span class="line">|          13 | CHK        |</span><br><span class="line">|          16 | SAV        |</span><br><span class="line">|          16 | CHK        |</span><br><span class="line">|          16 | CHK        |</span><br><span class="line">|          16 | CHK        |</span><br><span class="line">|          16 | CHK        |</span><br><span class="line">|          16 | BUS        |</span><br><span class="line">+-------------+------------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>过滤查找条件可以分为 相等查找、不等条件、范围条件、成员条件和匹配条件。</p>
<p>其中范围查找中的 between and 查找需要注意：</p>
<ol>
<li>必须先制定范围的下限（在between后面），然后制定 范围的上限（在end后面），否则会查出空集合。</li>
<li>beeween and操作符是，包含边界值的。</li>
</ol>
<p>成员条件可以使用or关键字或者 in、not in关键字。</p>
<p>匹配条件是指使用通配符查找。</p>
<ol>
<li>正好匹配一个字符。使用 ‘_’</li>
<li>匹配任意数目的字符(包括0个)，使用’%’</li>
</ol>
<p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name LIKE pattern;</span><br><span class="line">例如：</span><br><span class="line">    like  ‘K% ’  表示以K开头的字符串。</span><br><span class="line">    like  &#39;%D&#39;  表示以D结尾的字符串。</span><br><span class="line">    like ‘_oogle’  表示以任一一个字符开始的，然后时oogle的字符串。如google</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NULL关键字"><a href="#NULL关键字" class="headerlink" title="NULL关键字"></a>NULL关键字</h2><p>表示值的缺失：</p>
<ol>
<li>没有合适的值，比如ATM机上的自助交易并不需要employee ID列。</li>
<li>值未确定 比如在客户创建行的时候不知道他的id</li>
<li>值未定义 比如为某个还未添加到数据库的产品创建账户。</li>
</ol>
<p>注意：</p>
<ol>
<li>表达式可以为null，但是不能等于null </li>
<li>两个NUll值彼此不能判断为相等。</li>
</ol>
<p><strong>使用NULL时应注意：</strong></p>
<ul>
<li>普通的值一般都可能进行运算符操作,例如:ID列为int,所以可以这样:ID=ID+1等,但如果一列的值为null,<br>null+1=null,就是说null与任何运算符运算后都为null,这就是大家说的黑洞,会吃掉所有的东西.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update testNull</span><br><span class="line">set b&#x3D;b+1</span><br><span class="line">where b is null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论:查询后发现b的值没有变化,仍然为null.</p>
<ul>
<li>普通的值可以进行”=”操作,例如条件中一般都会这样出现:sUserName=’张三’,如果sUserName的值为null,<br>要想找出所有名字为null的记录时,不能这样用:sUserName=null,因为null不是一个具体的值,任何值与它比较<br>时都会返回false.此时可借用is null 或者是is not null.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from testNull where a&#x3D;null --返回空结果集</span><br><span class="line">select * from testNull where b is null --返回结果集 2 2 NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论:说明null是不能用”=”来比较,可用is null来替换</p>
<ul>
<li>在用统计函数count时会不同,例如count(ID):统计记录数.当统计的记录中的包含有null值时,它会忽略null值.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select count(*),count(b) from testNull 它的返回值为2 1</span><br><span class="line">select count(*),count(isnull(b,&#39;&#39;)) from testNull 它的返回值为2 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论:对于列包含null 时,统计行数是可用count(*),或者是先把null值转换成对应的值再统计,例如count(isnull(b,’’));</p>
<ul>
<li>对于in 的影响不同.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from testNull</span><br><span class="line">where b in(null) --没有任何记录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论:in在查询时会忽略null的记录,查询的时候可用is not null来查询.</p>
<ul>
<li>排序时顺序有不同:当使用ORDER BY时，首先呈现NULL值。如果你用DESC以降序排序，NULL值最后显示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select emp_id ,fname,lname,superior_emp_id from employee  order by superior_emp_id;</span><br><span class="line">+--------+----------+-----------+-----------------+</span><br><span class="line">| emp_id | fname    | lname     | superior_emp_id |</span><br><span class="line">+--------+----------+-----------+-----------------+</span><br><span class="line">|      2 | Susan    | Barker    |            NULL |</span><br><span class="line">|      3 | Robert   | Tyler     |            NULL |</span><br><span class="line">|      1 | Michael  | Smith     |            NULL |</span><br><span class="line">|      4 | Susan    | Hawthorne |               3 |</span><br><span class="line">|     10 | Paula    | Roberts   |               4 |</span><br><span class="line">|     16 | Theresa  | Markham   |               4 |</span><br><span class="line">|     13 | John     | Blake     |               4 |</span><br><span class="line">|      6 | Helen    | Fleming   |               4 |</span><br><span class="line">|      5 | John     | Gooding   |               4 |</span><br><span class="line">|      8 | Sarah    | Parker    |               6 |</span><br><span class="line">|      9 | Jane     | Grossman  |               6 |</span><br><span class="line">|      7 | Chris    | Tucker    |               6 |</span><br><span class="line">|     11 | Thomas   | Ziegler   |              10 |</span><br><span class="line">|     12 | Samantha | Jameson   |              10 |</span><br><span class="line">|     14 | Cindy    | Mason     |              13 |</span><br><span class="line">|     15 | Frank    | Portman   |              13 |</span><br><span class="line">|     17 | Beth     | Fowler    |              16 |</span><br><span class="line">|     18 | Rick     | Tulman    |              16 |</span><br><span class="line">+--------+----------+-----------+-----------------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>永远不会有什么数据等于NULL。1不等于NULL，2也一样。但NULL也不等于NULL。所以我们只能比较它“是”或“不是”。</p>
</li>
<li><p>count(*)表示统计行数，而count(某一个字段)表示对该值的内容统计，如果它的值为null，则该列不计数。</p>
</li>
</ul>
<h2 id="case-when-else-end-条件逻辑语句"><a href="#case-when-else-end-条件逻辑语句" class="headerlink" title="case when else end 条件逻辑语句"></a>case when else end 条件逻辑语句</h2><p>简单的说，条件逻辑语句时程序执行时从多个路径中选择其一的能。</p>
<h3 id="case表达式返回字符串的例子"><a href="#case表达式返回字符串的例子" class="headerlink" title="case表达式返回字符串的例子"></a>case表达式返回字符串的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    c.cust_id,</span><br><span class="line">    c.fed_id,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN c.cust_type_cd &#x3D; &#39;I&#39; THEN CONCAT(i.fname, &#39; &#39;, i.lname)</span><br><span class="line">        WHEN c.cust_type_cd &#x3D; &#39;B&#39; THEN b.name</span><br><span class="line">        ELSE &#39;Unknown&#39;</span><br><span class="line">    END name</span><br><span class="line">FROM</span><br><span class="line">    customer c</span><br><span class="line">        LEFT JOIN</span><br><span class="line">    individual i ON c.cust_id &#x3D; i.cust_id</span><br><span class="line">        LEFT JOIN</span><br><span class="line">    business b ON c.cust_id &#x3D; b.cust_id;</span><br><span class="line"></span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">| cust_id | fed_id      | name                   |</span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">|      10 | 04-1111111  | jamesd &#39;hand           |</span><br><span class="line">|      11 | 04-2222222  | Northeast Cooling Inc. |</span><br><span class="line">|      12 | 04-3333333  | Superior Auto Body     |</span><br><span class="line">|      13 | 04-4444444  | AAA Insurance Inc.     |</span><br><span class="line">|       1 | 111-11-1111 | James Hadley           |</span><br><span class="line">|       2 | 222-22-2222 | Susan Tingley          |</span><br><span class="line">|       3 | 333-33-3333 | Frank Tucker           |</span><br><span class="line">|       4 | 444-44-4444 | John Hayward           |</span><br><span class="line">|       5 | 555-55-5555 | Charles Frasier        |</span><br><span class="line">|       6 | 666-66-6666 | John Spencer           |</span><br><span class="line">|       7 | 777-77-7777 | Margaret Young         |</span><br><span class="line">|       8 | 888-88-8888 | Louis Blake            |</span><br><span class="line">|       9 | 999-99-9999 | Richard Farley         |</span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="case表达式返回表达式类型的例子"><a href="#case表达式返回表达式类型的例子" class="headerlink" title="case表达式返回表达式类型的例子"></a>case表达式返回表达式类型的例子</h3><p>例子1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    c.cust_id,</span><br><span class="line">    c.fed_id,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN</span><br><span class="line">            c.cust_type_cd &#x3D; &#39;I&#39;</span><br><span class="line">        THEN</span><br><span class="line">            (SELECT </span><br><span class="line">                    CONCAT(i.fname, &#39; &#39;, i.lname)</span><br><span class="line">                FROM</span><br><span class="line">                    individual i</span><br><span class="line">                WHERE</span><br><span class="line">                    i.cust_id &#x3D; c.cust_id)</span><br><span class="line">        WHEN</span><br><span class="line">            c.cust_type_cd &#x3D; &#39;B&#39;</span><br><span class="line">        THEN</span><br><span class="line">            (SELECT </span><br><span class="line">                    b.name</span><br><span class="line">                FROM</span><br><span class="line">                    business b</span><br><span class="line">                WHERE</span><br><span class="line">                    b.cust_id &#x3D; c.cust_id)</span><br><span class="line">        ELSE &#39;Unknown&#39;</span><br><span class="line">    END name</span><br><span class="line">FROM</span><br><span class="line">    customer c;</span><br><span class="line"></span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">| cust_id | fed_id      | name                   |</span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">|       1 | 111-11-1111 | James Hadley           |</span><br><span class="line">|       2 | 222-22-2222 | Susan Tingley          |</span><br><span class="line">|       3 | 333-33-3333 | Frank Tucker           |</span><br><span class="line">|       4 | 444-44-4444 | John Hayward           |</span><br><span class="line">|       5 | 555-55-5555 | Charles Frasier        |</span><br><span class="line">|       6 | 666-66-6666 | John Spencer           |</span><br><span class="line">|       7 | 777-77-7777 | Margaret Young         |</span><br><span class="line">|       8 | 888-88-8888 | Louis Blake            |</span><br><span class="line">|       9 | 999-99-9999 | Richard Farley         |</span><br><span class="line">|      10 | 04-1111111  | jamesd &#39;hand           |</span><br><span class="line">|      11 | 04-2222222  | Northeast Cooling Inc. |</span><br><span class="line">|      12 | 04-3333333  | Superior Auto Body     |</span><br><span class="line">|      13 | 04-4444444  | AAA Insurance Inc.     |</span><br><span class="line">+---------+-------------+------------------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子2</p>
<p>查询某个表达式的结果的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    c.cust_id,</span><br><span class="line">    c.fed_id,</span><br><span class="line">    c.cust_type_cd,</span><br><span class="line">    CASE (SELECT </span><br><span class="line">            COUNT(*)</span><br><span class="line">        FROM</span><br><span class="line">            account a</span><br><span class="line">        WHERE</span><br><span class="line">            a.cust_id &#x3D; c.cust_id)</span><br><span class="line">        WHEN 0 THEN &#39;none&#39;</span><br><span class="line">        WHEN 1 THEN &#39;1&#39;</span><br><span class="line">        WHEN 2 THEN &#39;2&#39;</span><br><span class="line">        ELSE &#39;3+&#39;</span><br><span class="line">    END num_accounts</span><br><span class="line">FROM</span><br><span class="line">    customer c;</span><br><span class="line"></span><br><span class="line">+---------+-------------+--------------+--------------+</span><br><span class="line">| cust_id | fed_id      | cust_type_cd | num_accounts |</span><br><span class="line">+---------+-------------+--------------+--------------+</span><br><span class="line">|       1 | 111-11-1111 | I            | 3+           |</span><br><span class="line">|       2 | 222-22-2222 | I            | 2            |</span><br><span class="line">|       3 | 333-33-3333 | I            | 2            |</span><br><span class="line">|       4 | 444-44-4444 | I            | 3+           |</span><br><span class="line">|       5 | 555-55-5555 | I            | 1            |</span><br><span class="line">|       6 | 666-66-6666 | I            | 2            |</span><br><span class="line">|       7 | 777-77-7777 | I            | 1            |</span><br><span class="line">|       8 | 888-88-8888 | I            | 2            |</span><br><span class="line">|       9 | 999-99-9999 | I            | 3+           |</span><br><span class="line">|      10 | 04-1111111  | B            | 2            |</span><br><span class="line">|      11 | 04-2222222  | B            | 1            |</span><br><span class="line">|      12 | 04-3333333  | B            | 1            |</span><br><span class="line">|      13 | 04-4444444  | B            | 1            |</span><br><span class="line">+---------+-------------+--------------+--------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表查询-需要使用连接。"><a href="#多表查询-需要使用连接。" class="headerlink" title="多表查询 需要使用连接。"></a>多表查询 需要使用连接。</h3><p>连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。<br>左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。<br>外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配<br>的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，<br>左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select e.fname,e.lname,d.name from employee e join department d on e.dept_id &#x3D; d.dept_id;</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">| fname    | lname     | name           |</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">| Susan    | Hawthorne | Operations     |</span><br><span class="line">| Helen    | Fleming   | Operations     |</span><br><span class="line">| Chris    | Tucker    | Operations     |</span><br><span class="line">| Sarah    | Parker    | Operations     |</span><br><span class="line">| Jane     | Grossman  | Operations     |</span><br><span class="line">| Paula    | Roberts   | Operations     |</span><br><span class="line">| Thomas   | Ziegler   | Operations     |</span><br><span class="line">| Samantha | Jameson   | Operations     |</span><br><span class="line">| John     | Blake     | Operations     |</span><br><span class="line">| Cindy    | Mason     | Operations     |</span><br><span class="line">| Frank    | Portman   | Operations     |</span><br><span class="line">| Theresa  | Markham   | Operations     |</span><br><span class="line">| Beth     | Fowler    | Operations     |</span><br><span class="line">| Rick     | Tulman    | Operations     |</span><br><span class="line">| John     | Gooding   | Loans          |</span><br><span class="line">| Michael  | Smith     | Administration |</span><br><span class="line">| Susan    | Barker    | Administration |</span><br><span class="line">| Robert   | Tyler     | Administration |</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上列子是内连接查询的结果，如果一个表中的dept_id 列中存在某个值，但这个值在另一个表的dept_id列中不存在，<br>那么相关行的链接会失败，在结果集中会排除包含该值的行。</p>
<ul>
<li>ANSI连接语法</li>
</ul>
<p>这种旧的连接方式不包含on子句，而是在from子句中定义个表的别名。并使用逗号隔开。</p>
<p>它具有以下优点：</p>
<ol>
<li>连接条件和过滤条件被分割到on子句和where子句，使查询语句容易被理解。</li>
<li>每两个表之间的连接条件都在自己的on子句中列出，这样不容易忽略这些条件。</li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT e.fname,e.lname,d.name from employee e ,department d where e.dept_id &#x3D;d.dept_id;</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">| fname    | lname     | name           |</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">| Susan    | Hawthorne | Operations     |</span><br><span class="line">| Helen    | Fleming   | Operations     |</span><br><span class="line">| Chris    | Tucker    | Operations     |</span><br><span class="line">| Sarah    | Parker    | Operations     |</span><br><span class="line">| Jane     | Grossman  | Operations     |</span><br><span class="line">| Paula    | Roberts   | Operations     |</span><br><span class="line">| Thomas   | Ziegler   | Operations     |</span><br><span class="line">| Samantha | Jameson   | Operations     |</span><br><span class="line">| John     | Blake     | Operations     |</span><br><span class="line">| Cindy    | Mason     | Operations     |</span><br><span class="line">| Frank    | Portman   | Operations     |</span><br><span class="line">| Theresa  | Markham   | Operations     |</span><br><span class="line">| Beth     | Fowler    | Operations     |</span><br><span class="line">| Rick     | Tulman    | Operations     |</span><br><span class="line">| John     | Gooding   | Loans          |</span><br><span class="line">| Michael  | Smith     | Administration |</span><br><span class="line">| Susan    | Barker    | Administration |</span><br><span class="line">| Robert   | Tyler     | Administration |</span><br><span class="line">+----------+-----------+----------------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>连接两次使用同一张表时，可以为表取别名。别名即表的实例，数据库服务器可以区分所引用的实例。</p>
</li>
<li><p>自连接</p>
</li>
</ul>
<p>一张表中存这雇员的信息和一个指向本表的外键。<br>此时要查询每个雇员的姓名和主管道的姓名，即可使用自连接。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select e.fname,e_mgr.fname as emgrName from employee e  inner join employee e_mgr on e.superior_emp_id &#x3D;e_mgr.emp_id;</span><br><span class="line">+----------+----------+</span><br><span class="line">| fname    | emgrName |</span><br><span class="line">+----------+----------+</span><br><span class="line">| Susan    | Robert   |</span><br><span class="line">| John     | Susan    |</span><br><span class="line">| Helen    | Susan    |</span><br><span class="line">| Chris    | Helen    |</span><br><span class="line">| Sarah    | Helen    |</span><br><span class="line">| Jane     | Helen    |</span><br><span class="line">| Paula    | Susan    |</span><br><span class="line">| Thomas   | Paula    |</span><br><span class="line">| Samantha | Paula    |</span><br><span class="line">| John     | Susan    |</span><br><span class="line">| Cindy    | John     |</span><br><span class="line">| Frank    | John     |</span><br><span class="line">| Theresa  | Susan    |</span><br><span class="line">| Beth     | Theresa  |</span><br><span class="line">| Rick     | Theresa  |</span><br><span class="line">+----------+----------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>自连接的不等连接</li>
</ul>
<p>每一个组中的成员与组里的别的成员进行一场象棋比赛。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;这样会产生重复记录，即a VS b  和b VS a</span><br><span class="line">mysql&gt; select e1.fname,e1.lname, &#39;VS&#39; vs , e2.fname,e2.lname from employee e1 inner join employee e2 on e1.emp_id  !&#x3D;e2.emp_id where e1.title &#x3D;&#39;Teller&#39; and e2.title &#x3D;&#39;Teller&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所以需要过滤，采用&gt;的条件</span><br><span class="line"></span><br><span class="line">mysql&gt; select e1.fname,e1.lname, &#39;VS&#39; vs , e2.fname,e2.lname from employee e1 inner join employee e2 on e1.emp_id  &gt;e2.emp_id where e1.title &#x3D;&#39;Teller&#39; and e2.title &#x3D;&#39;Teller&#39;;</span><br><span class="line">+----------+----------+----+----------+----------+</span><br><span class="line">| fname    | lname    | vs | fname    | lname    |</span><br><span class="line">+----------+----------+----+----------+----------+</span><br><span class="line">| Sarah    | Parker   | VS | Chris    | Tucker   |</span><br><span class="line">| Jane     | Grossman | VS | Chris    | Tucker   |</span><br><span class="line">| Jane     | Grossman | VS | Sarah    | Parker   |</span><br><span class="line">| Thomas   | Ziegler  | VS | Chris    | Tucker   |</span><br><span class="line">| Thomas   | Ziegler  | VS | Sarah    | Parker   |</span><br><span class="line">| Thomas   | Ziegler  | VS | Jane     | Grossman |</span><br><span class="line">| Samantha | Jameson  | VS | Chris    | Tucker   |</span><br><span class="line">| Samantha | Jameson  | VS | Sarah    | Parker   |</span><br><span class="line">| Samantha | Jameson  | VS | Jane     | Grossman |</span><br><span class="line">| Samantha | Jameson  | VS | Thomas   | Ziegler  |</span><br><span class="line">| Cindy    | Mason    | VS | Chris    | Tucker   |</span><br><span class="line">| Cindy    | Mason    | VS | Sarah    | Parker   |</span><br><span class="line">| Cindy    | Mason    | VS | Jane     | Grossman |</span><br><span class="line">| Cindy    | Mason    | VS | Thomas   | Ziegler  |</span><br><span class="line">| Cindy    | Mason    | VS | Samantha | Jameson  |</span><br><span class="line">| Frank    | Portman  | VS | Chris    | Tucker   |</span><br><span class="line">| Frank    | Portman  | VS | Sarah    | Parker   |</span><br><span class="line">| Frank    | Portman  | VS | Jane     | Grossman |</span><br><span class="line">| Frank    | Portman  | VS | Thomas   | Ziegler  |</span><br><span class="line">| Frank    | Portman  | VS | Samantha | Jameson  |</span><br><span class="line">| Frank    | Portman  | VS | Cindy    | Mason    |</span><br><span class="line">| Beth     | Fowler   | VS | Chris    | Tucker   |</span><br><span class="line">| Beth     | Fowler   | VS | Sarah    | Parker   |</span><br><span class="line">| Beth     | Fowler   | VS | Jane     | Grossman |</span><br><span class="line">| Beth     | Fowler   | VS | Thomas   | Ziegler  |</span><br><span class="line">| Beth     | Fowler   | VS | Samantha | Jameson  |</span><br><span class="line">| Beth     | Fowler   | VS | Cindy    | Mason    |</span><br><span class="line">| Beth     | Fowler   | VS | Frank    | Portman  |</span><br><span class="line">| Rick     | Tulman   | VS | Chris    | Tucker   |</span><br><span class="line">| Rick     | Tulman   | VS | Sarah    | Parker   |</span><br><span class="line">| Rick     | Tulman   | VS | Jane     | Grossman |</span><br><span class="line">| Rick     | Tulman   | VS | Thomas   | Ziegler  |</span><br><span class="line">| Rick     | Tulman   | VS | Samantha | Jameson  |</span><br><span class="line">| Rick     | Tulman   | VS | Cindy    | Mason    |</span><br><span class="line">| Rick     | Tulman   | VS | Frank    | Portman  |</span><br><span class="line">| Rick     | Tulman   | VS | Beth     | Fowler   |</span><br><span class="line">+----------+----------+----+----------+----------+</span><br><span class="line">36 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LEFT JOIN (等价于LEFT OUT JOIN) 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。</span><br><span class="line">如果右表中没有匹配，则结果为 NULL。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">SELECT  websites.name, access_log.count, access_log.date</span><br><span class="line">FROM   websites  LEFT JOIN　access_log ON websites.id &#x3D; access_log.site_id　ORDER BY access_log.count DESC;</span><br><span class="line"></span><br><span class="line">+---------------+-------+------------+</span><br><span class="line">| name          | count | date       |</span><br><span class="line">+---------------+-------+------------+</span><br><span class="line">| Facebook      |   545 | 2016-05-16 |</span><br><span class="line">| Google        |   230 | 2016-05-14 |</span><br><span class="line">| 菜鸟教程      |   220 | 2016-05-15 |</span><br><span class="line">| Facebook      |   205 | 2016-05-14 |</span><br><span class="line">| 菜鸟教程      |   201 | 2016-05-17 |</span><br><span class="line">| 菜鸟教程      |   100 | 2016-05-13 |</span><br><span class="line">| Google        |    45 | 2016-05-10 |</span><br><span class="line">| 微博          |    13 | 2016-05-15 |</span><br><span class="line">| 淘宝          |    10 | 2016-05-14 |</span><br><span class="line">| stackoverflow |  NULL | NULL       |</span><br><span class="line">+---------------+-------+------------+</span><br><span class="line"></span><br><span class="line">RIGHT JOIN 与INNER JOIN的意思相同，不做过多的解释。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="union和union-all关键字"><a href="#union和union-all关键字" class="headerlink" title="union和union all关键字"></a>union和union all关键字</h3><ul>
<li>要使用UNION或者UNION all 必须满足以下两个条件：</li>
</ul>
<p>两个数据集合必须具有相同的列；<br>两个数据集中对应的列的数据类型必须时一致的（或者时服务器中数据类型可以转换）；</p>
<ul>
<li>区别：</li>
</ul>
<p>union对连接后的集合排序并去除重复项，而union all保留重复项。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select &#39;ind&#39; type_cd,cust_id,lname name from individual union all select &#39;bus&#39; type_cd,cust_id,name from business;</span><br><span class="line">+---------+---------+------------------------+</span><br><span class="line">| type_cd | cust_id | name                   |</span><br><span class="line">+---------+---------+------------------------+</span><br><span class="line">| ind     |       1 | Hadley                 |</span><br><span class="line">| ind     |       2 | Tingley                |</span><br><span class="line">| ind     |       3 | Tucker                 |</span><br><span class="line">| ind     |       4 | Hayward                |</span><br><span class="line">| ind     |       5 | Frasier                |</span><br><span class="line">| ind     |       6 | Spencer                |</span><br><span class="line">| ind     |       7 | Young                  |</span><br><span class="line">| ind     |       8 | Blake                  |</span><br><span class="line">| ind     |       9 | Farley                 |</span><br><span class="line">| bus     |      10 | Chilton Engineering    |</span><br><span class="line">| bus     |      11 | Northeast Cooling Inc. |</span><br><span class="line">| bus     |      12 | Superior Auto Body     |</span><br><span class="line">| bus     |      13 | AAA Insurance Inc.     |</span><br><span class="line">+---------+---------+------------------------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对复合查询结果排序</li>
</ul>
<p>如果需要对复合查询的结果进行排序，那么可以在最后一个查询后面增加order by 子句。当在order by 子句中指定要排序的列时，需要从复合查询的第一个查询中选取列名。所以，建议对两个查询的各列定义不同的别名。</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询返回的结果集类型决定了它可能如何被使用。任何查询返回的数据在包含语句执行完成之后都会被丢弃，说这事的则查询像一个具有作用域的临时表。这意味着sql执行完毕，子查询结果所占用的内存将会被清空。</p>
<h4 id="非关联子查询"><a href="#非关联子查询" class="headerlink" title="非关联子查询"></a>非关联子查询</h4><p>非关联子查询是指，它可以单独执行不需要引用包含语句中的任何内容。</p>
<ul>
<li>如果在等式条件下使用子查询，而子查询返回多行结果，则会出错。</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select account_id,product_cd,cust_id from account where open_emp_id &lt;&gt; (select e.emp_id from employee e inner join  branch b on e.assigned_branch_id &#x3D;b.branch_id where e.title&#x3D;&#39;Teller&#39; AND b.city&#x3D;&#39;Woburn&#39;);</span><br><span class="line">ERROR 1242 (21000): Subquery returns more than 1 row</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>错误的原因时open_emp_id 不能等于结果集。</p>
<ul>
<li>多行单列子查询，即多行结果可以在非等式的 IN和NOT IN 运算符中使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select branch_id ,name,city from branch where name In (&#39;HeadQuarters&#39;,&#39;Quincy Branch&#39;);</span><br><span class="line">+-----------+---------------+---------+</span><br><span class="line">| branch_id | name          | city    |</span><br><span class="line">+-----------+---------------+---------+</span><br><span class="line">|         1 | Headquarters  | Waltham |</span><br><span class="line">|         3 | Quincy Branch | Quincy  |</span><br><span class="line">+-----------+---------------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ALL和ANY运算符（不常用。一般使用IN和NOT IN代替。）</li>
</ul>
<p>all运算符用于将某单值与集合中的每个值比较，而any用于个结果集中的每个成员比较。与all不同的时，any运算符中，只要有一个比较成立，则条件为真。all需要每一个都成立，才为真。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select emp_id,fname,lname,title from employee where emp_id &lt;&gt; all (select superior_emp_id from employee where superior_emp_id is NOT NULL);</span><br><span class="line">+--------+----------+----------+----------------+</span><br><span class="line">| emp_id | fname    | lname    | title          |</span><br><span class="line">+--------+----------+----------+----------------+</span><br><span class="line">|      1 | Michael  | Smith    | President      |</span><br><span class="line">|      2 | Susan    | Barker   | Vice President |</span><br><span class="line">|      5 | John     | Gooding  | Loan Manager   |</span><br><span class="line">|      7 | Chris    | Tucker   | Teller         |</span><br><span class="line">|      8 | Sarah    | Parker   | Teller         |</span><br><span class="line">|      9 | Jane     | Grossman | Teller         |</span><br><span class="line">|     11 | Thomas   | Ziegler  | Teller         |</span><br><span class="line">|     12 | Samantha | Jameson  | Teller         |</span><br><span class="line">|     14 | Cindy    | Mason    | Teller         |</span><br><span class="line">|     15 | Frank    | Portman  | Teller         |</span><br><span class="line">|     17 | Beth     | Fowler   | Teller         |</span><br><span class="line">|     18 | Rick     | Tulman   | Teller         |</span><br><span class="line">+--------+----------+----------+----------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><ul>
<li>与非关联子查询不同，关联子查询不是在包含语句执行前执行一次，而是为每一个候选行都执行一次。</li>
</ul>
<p>下面的例子中首先关联查询计算每个客户的账户数，接着包含查询检索出哪些拥有两个账户。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select c.cust_id,c.cust_type_cd,c.city from customer c where 2 &#x3D;(select count(*) from account a where a.cust_id &#x3D;c.cust_id);</span><br><span class="line">+---------+--------------+---------+</span><br><span class="line">| cust_id | cust_type_cd | city    |</span><br><span class="line">+---------+--------------+---------+</span><br><span class="line">|       2 | I            | Woburn  |</span><br><span class="line">|       3 | I            | Quincy  |</span><br><span class="line">|       6 | I            | Waltham |</span><br><span class="line">|       8 | I            | Salem   |</span><br><span class="line">|      10 | B            | Salem   |</span><br><span class="line">+---------+--------------+---------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>exists运算符</li>
</ul>
<p>如果只关心存在关系，而不在乎数量就可以使用exists关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;以下时exists和not exists的用法。</span><br><span class="line">mysql&gt; select a.account_id ,a.product_cd,a.cust_id,a.avail_balance from account a where not exists (select 1 from transaction t where t.account_id &#x3D;a.account_id and t.txn_date &#x3D;&#39;2008-09-22&#39;);</span><br><span class="line">+------------+------------+---------+---------------+</span><br><span class="line">| account_id | product_cd | cust_id | avail_balance |</span><br><span class="line">+------------+------------+---------+---------------+</span><br><span class="line">|          1 | CHK        |       1 |       1057.75 |</span><br><span class="line">|          2 | SAV        |       1 |        500.00 |</span><br><span class="line">|          3 | CD         |       1 |       3000.00 |</span><br><span class="line">|          4 | CHK        |       2 |       2258.02 |</span><br><span class="line">|          5 | SAV        |       2 |        200.00 |</span><br><span class="line">|          7 | CHK        |       3 |       1057.75 |</span><br><span class="line">|          8 | MM         |       3 |       2212.50 |</span><br><span class="line">|         10 | CHK        |       4 |        534.12 |</span><br><span class="line">|         11 | SAV        |       4 |        767.77 |</span><br><span class="line">|         12 | MM         |       4 |       5487.09 |</span><br><span class="line">|         13 | CHK        |       5 |       2237.97 |</span><br><span class="line">|         14 | CHK        |       6 |        122.37 |</span><br><span class="line">|         15 | CD         |       6 |      10000.00 |</span><br><span class="line">|         17 | CD         |       7 |       5000.00 |</span><br><span class="line">|         18 | CHK        |       8 |       3487.19 |</span><br><span class="line">|         19 | SAV        |       8 |        387.99 |</span><br><span class="line">|         21 | CHK        |       9 |        125.67 |</span><br><span class="line">|         22 | MM         |       9 |       9345.55 |</span><br><span class="line">|         23 | CD         |       9 |       1500.00 |</span><br><span class="line">|         24 | CHK        |      10 |      23575.12 |</span><br><span class="line">|         25 | BUS        |      10 |          0.00 |</span><br><span class="line">|         27 | BUS        |      11 |       9345.55 |</span><br><span class="line">|         28 | CHK        |      12 |      38552.05 |</span><br><span class="line">|         29 | SBL        |      13 |      50000.00 |</span><br><span class="line">+------------+------------+---------+---------------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a.account_id ,a.product_cd,a.cust_id,a.avail_balance from account a where exists (select 1 from transaction t where t.account_id &#x3D;a.account_id and t.txn_date &#x3D;&#39;2008-09-22&#39;);</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子查询可能返回1或者0 ，使用1代表是否至少能返回一行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>update语句的关联查询</li>
</ul>
<p>例子：</p>
<p>查询出每个账户的最新交易日期，然后修改账户的每一行的last_activity_date字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; update account a set a.last_activity_date &#x3D;(select max(t.txn_date) from transaction t where t.account_id &#x3D;a.account_id);</span><br><span class="line">Query OK, 19 rows affected (0.15 sec)</span><br><span class="line">Rows matched: 24  Changed: 19  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>delete语句中的关联查询</li>
</ul>
<p>mysql中的delete语句使用关联子查询时，无论如何都不能使用表的别名。(暂时不知道原因)</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; delete from department where not exists (select 1 from employee  where employee.dept_id&#x3D;department.dept_id);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="如何使用子查询"><a href="#如何使用子查询" class="headerlink" title="如何使用子查询"></a>如何使用子查询</h4><ul>
<li>子查询作为数据源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select d.dept_id ,d.name ,e_ent.how_many num_employees from department d inner join (select dept_id ,count(*) how_many from employee group by dept_id) e_ent on d.dept_id&#x3D;e_ent.dept_id;</span><br><span class="line">+---------+----------------+---------------+</span><br><span class="line">| dept_id | name           | num_employees |</span><br><span class="line">+---------+----------------+---------------+</span><br><span class="line">|       1 | Operations     |            14 |</span><br><span class="line">|       2 | Loans          |             1 |</span><br><span class="line">|       3 | Administration |             3 |</span><br><span class="line">+---------+----------------+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子查询在from子句中必须是非关联的，它必须首先执行，然后一直保存在内存中直至包含查询执行完毕。</p>
<ul>
<li>子查询作为过滤条件</li>
</ul>
<p>子查询作为过滤条件出现在having条件中，不会出现在where条件中。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    open_emp_id, COUNT(*) how_many</span><br><span class="line">FROM</span><br><span class="line">    account</span><br><span class="line">GROUP BY open_emp_id</span><br><span class="line">HAVING COUNT(*) &#x3D; (SELECT </span><br><span class="line">        MAX(emp_cnt.how_many)</span><br><span class="line">    FROM</span><br><span class="line">        (SELECT </span><br><span class="line">            COUNT(*) how_many</span><br><span class="line">        FROM</span><br><span class="line">            account</span><br><span class="line">        GROUP BY open_emp_id) emp_cnt);</span><br><span class="line"></span><br><span class="line">+-------------+----------+</span><br><span class="line">| open_emp_id | how_many |</span><br><span class="line">+-------------+----------+</span><br><span class="line">|           1 |        8 |</span><br><span class="line">+-------------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>子查询作为表达式生成器</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    emp.emp_id,</span><br><span class="line">    CONCAT(emp.fname, &#39; &#39;, emp.lname) emp_name,</span><br><span class="line">    (SELECT </span><br><span class="line">            CONCAT(boss.fname, &#39; &#39;, boss.lname)</span><br><span class="line">        FROM</span><br><span class="line">            employee boss</span><br><span class="line">        WHERE</span><br><span class="line">            boss.emp_id &#x3D; emp.superior_emp_id) boss_name</span><br><span class="line">FROM</span><br><span class="line">    employee emp</span><br><span class="line">WHERE</span><br><span class="line">    emp.superior_emp_id IS NOT NULL</span><br><span class="line">ORDER BY (SELECT </span><br><span class="line">        boss.lname</span><br><span class="line">    FROM</span><br><span class="line">        employee boss</span><br><span class="line">    WHERE</span><br><span class="line">        boss.emp_id &#x3D; emp.superior_emp_id) , emp.lname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------+------------------+-----------------+</span><br><span class="line">| emp_id | emp_name         | boss_name       |</span><br><span class="line">+--------+------------------+-----------------+</span><br><span class="line">|     14 | Cindy Mason      | John Blake      |</span><br><span class="line">|     15 | Frank Portman    | John Blake      |</span><br><span class="line">|      9 | Jane Grossman    | Helen Fleming   |</span><br><span class="line">|      8 | Sarah Parker     | Helen Fleming   |</span><br><span class="line">|      7 | Chris Tucker     | Helen Fleming   |</span><br><span class="line">|     13 | John Blake       | Susan Hawthorne |</span><br><span class="line">|      6 | Helen Fleming    | Susan Hawthorne |</span><br><span class="line">|      5 | John Gooding     | Susan Hawthorne |</span><br><span class="line">|     16 | Theresa Markham  | Susan Hawthorne |</span><br><span class="line">|     10 | Paula Roberts    | Susan Hawthorne |</span><br><span class="line">|     17 | Beth Fowler      | Theresa Markham |</span><br><span class="line">|     18 | Rick Tulman      | Theresa Markham |</span><br><span class="line">|     12 | Samantha Jameson | Paula Roberts   |</span><br><span class="line">|     11 | Thomas Ziegler   | Paula Roberts   |</span><br><span class="line">|      4 | Susan Hawthorne  | Robert Tyler    |</span><br><span class="line">+--------+------------------+-----------------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>













































































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈伟杰"
      src="/images/favicon.ico">
  <p class="site-author-name" itemprop="name">陈伟杰</p>
  <div class="site-description" itemprop="description">学习，坚持。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenwj1103" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenwj1103" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈伟杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">638k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
